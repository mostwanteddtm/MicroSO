<!-- Created and Copyright(C)2000,2001,2002,2003,2004,2005 by Daniel B. Sedory -->
<html><head><title>An MS-DEBUG Tutorial</title>
<meta http-equiv="keywords" content="MS-DEBUG, x86, Assembly, Disassembler">
<meta http-equiv="description" content="An MS-DEBUG Tutorial">
<meta http-equiv="author" content="Daniel B. Sedory">
<meta http-equiv="copyright" content="Copyright(C)2004,2005 by Daniel B. Sedory">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
.bl {color:#0000FF;}
</style>
</head>
<body bgcolor="#FFFFFF" leftmargin="33">
<CENTER><DIV>Sponsoring website: <a href="http://prime-expert.com/ebcd/">Emergency Boot CD</a></DIV></CENTER><HR>

<BR><BR>
<HR>
<font size="4" color="#FF00FF"> 
<UL>
  <b>I hope you enjoy the Assembly coding examples used on this pag</b>e.<b> If 
  you have any questions about them, <a href="../../Feedback.html" target=FB>use 
  this online form to e-mail me</a>. </b> ( Opens in a new window. ) 
</UL>
</font> 
<HR>
<p align="center"><font size="6"><b>A Guide to DEBUG<br>
  (Page Two)</b></font><font face="Times New Roman" size="5"><b><br>
  <font size="7">A DEBUG Tutorial</font></b></font><br>
  <font face="Verdana" size="4"><b>Copyright&copy;2005,2009 by Daniel B. Sedory</b></font> 
  <BR>
  <BR>
  <font face="Arial" size="4" color="#CC0000"><b><font color="#0000FF">This page 
  may be freely copied for PERSONAL use ONLY !</font><br>
  ( It may NOT be used for ANY other purpose unless you have<br>
  first <a href="../../Feedback.html" target="FB">contacted</a> and received permission 
  from the author! )</b></font></p>
<HR>
<UL>
  <li><a href="#ALPHA"><FONT size="4">Each Command -- Listed Alphabetically</FONT></a></li>
  <ul>
    <li><a href="#TOC"><FONT size="4"><b><i>Quick Links</i></b> to Command Help</FONT></a><br>
      <br>
    </li>
  </ul>
  <li><a href="#CMDS"><FONT size="4"><b><i>How to Use</i></b> the COMMANDS</FONT></a></li>
  <ul>
    <li><a href="#PARMS"><FONT size="4">Meaning of Command Parameters</FONT></a><br>
      <br>
    </li>
    <li><a href="#DETS"><FONT size="4"><b><i>Detailed Help</i></b> on each Command 
      (begins here)</FONT></a></li>
    <ul>
      <li><a href="#PLAY"><FONT size="4">An Example Program for you to Enter, 
        Run and Edit under DEBUG.</FONT></a></li>
      <li><a href="#IHC"><FONT size="4">A <b><i>Note</i></b> about Win 9x's '<b>IHC</b>' 
        string in Diskette Boot Sectors</FONT></a><br>
        <br>
      </li>
    </ul>
  </ul>
  <li><a href="../../asm/debug/8086REGs.htm" target=REGS><FONT size="4">Appendixes</FONT></a></li>
  <ul>
    <li> <a href="../../asm/debug/8086REGs.htm#REGS" target=REGS><FONT size="4">The 
      <b>8086</b> CPU <b><i>Registers</i></b></FONT></a></li>
    <li><a href="../../asm/debug/8086REGs.htm#FLAGS" target=REGS><FONT size="4">The 
      <b><i>FLAGS Register</i></b></FONT></a></li>
    <li><a href="../../asm/debug/Segments.html" target="SO"><font size="4">The 
      <b>Segment:Offset Addressing</b> method used by DEBUG</font></a></li>
  </ul>
  <p><br>
  </p>
</UL>
<HR><A NAME=ALPHA></A><p>&nbsp; </p>
<H1 align="center"><FONT FACE="Verdana"><i>Help</i> on DEBUG Commands</FONT></H1>
<br>
<p><font face="Comic Sans MS" size="4">For a reminder of all the commands (and 
  most of the parameters) that are available while inside of DEBUG, simply enter 
  a question mark (<b><font color="#0000FF">?</font></b>) at the DEBUG prompt; 
  when using <b>DOS 5.0</b> or later. <b>(</b> Note: Expanded Memory commands 
  are rarely <i>if ever</i> used and will not be discussed here.<b>)</b></font></p>
<h2><font face="Verdana, Arial, Helvetica, sans-serif">Quick Alphabetical Links</font><font face="Comic Sans MS" size="4"><br>
  <font color="#008000">Click on a command here for all its details:</font></font></h2>
<UL>
<PRE><b><A NAME=TOC><font size="4">-<font color="#008000">?</font></font></A><font size="4">
<A HREF="#A"><font color="blue">assemble    A [address]</font></A>
<A HREF="#C"><font color="blue">compare     C range address</font></A>
<A HREF="#D"><font color="blue">dump        D [range]</font></A>
<A HREF="#E"><font color="blue">enter       E address [list]</font></A>
<A HREF="#F"><font color="blue">fill        F range list</font></A>
<A HREF="#G"><font color="blue">go          G [=address] [addresses]</font></A>
<A HREF="#H"><font color="blue">hex         H value1 value2</font></A>   (<font size="3">Learn 2's Complement!</font>)
<A HREF="#I"><font color="blue">input       I port</font></A>
<A HREF="#L"><font color="blue">load        L [address] [drive] [firstsector] [number]</font></A>
<A HREF="#M"><font color="blue">move        M range address</font></A>
<A HREF="#N"><font color="blue">name        N [pathname] [arglist]</font></A>
<A HREF="#O"><font color="blue">output      O port byte</font></A>
<A HREF="#P"><font color="blue">proceed     P [=address] [number]</font></A>
<A HREF="#Q"><font color="blue">quit        Q</font></A> . . . . . . . . . (<font color="#FF0000">Learn this first!</font>)
<A HREF="#R"><font color="blue">register    R [register]</font></A>
<A HREF="#S"><font color="blue">search      S range list</font></A>
<A HREF="#T"><font color="blue">trace/step  T [=address] [number]</font></A>
<A HREF="#U"><font color="blue">unassemble  U [range]</font> </A>
<A HREF="#W"><font color="blue">write       W [address] [drive] [firstsector] [number]</font></A>
</font></b>
<BR><A NAME=CMDS><BR><BR></A>
</PRE></UL>
<HR>
<p ALIGN=CENTER><font face="Comic Sans MS" size="7">H o w &nbsp; t o  &nbsp; 
u s e &nbsp; t h e <BR> C O M M A N D S </font></p>
<HR><A NAME=PARMS></A>
<p>&nbsp; </p>
<H1 align="center"><FONT FACE="Verdana">P a r a m e t e r s</FONT></H1>
<br>
<p><font face="Arial" size="4">&nbsp; &nbsp; &nbsp; 
NOTE: &nbsp; Parameters listed in brackets ( [ &nbsp; ] ) are optional.
 &nbsp; Optional parameters usually 
indicate there are a number of different ways  a command could be used. 
I've listed the meanings of all the parameters here for you:</font><BR>
<BR>
<font face="Verdana" size="5"><b>address</b> - </font><font face="Arial" 
size="4">Memory location specified in hexadecimal. You can use either a 
simple Offset all by itself (in which case, the present CS 'Code Segment' 
will be assumed), or you can enter the full Segment:Offset location using 
either all hex numbers or substituting the name of a segment register for a 
number. Leading zeros are not required;  thus 1F all by itself would be the 
location 'CS:001F' ( CS meaning whatever the CS happened to be at the time 
you entered this ). Examples:</font></p>
<PRE><font size="4"><b>    100    DS:12    SS:0    198A:1234</b></font></PRE>
<font face="Verdana" size="4">For a detailed discussion, see: <b><a href="../../asm/debug/Segments.html" target="SO">Segment:Offset 
notation</a></b>.</font><BR>
<BR>
<font face="Verdana" size="5"><b>&nbsp; &nbsp; range</b> - </font><font 
face="Arial" size="4">Two hexadecimal addresses separated by a single space. 
They may be listed as either full Segment:Offset pairs or just an Offset 
alone ( in which case, the Segment is assumed to be that of the present CS 
or &quot;Code Segment&quot; ). NOTE: Some commands, such as <a href="#C">
Compare (C)</a>, may require  the second address be given only as an 
offset.</font><BR><BR>
<font face="Verdana" size="5"><b>&nbsp; &nbsp; &nbsp; &nbsp; list</b> - 
</font><font face="Arial" size="4">A string of Hexadecimal bytes separated 
by a space, or ASCII data enclosed within single or double quote marks. You 
can list any number of bytes from a single one up whatever number fits on 
the line before having to press the Enter key. A single byte, such as 00 is 
most often used with the <a href="#F">FILL (f)</a> command whereas an 
<a href="#E">ENTER (e)</a> command will most likely have a string of many 
hex bytes or ASCII characters per line; for example:
</font><PRE><font size="4"><b>    e 100 31 C0 B4 09 BA 50 02 CD 21 B8 4C 00 CD 21

    e 250 'This is an ASCII data string.$'
</b></font></PRE>
<p><font face="Verdana" size="5"> &nbsp;<b>number</b> - </font><font face="Arial" size="4">Remember 
  all numbers and values used in any DEBUG command are understood as being Hexadecimal only! That
  includes the number of sectors in the LOAD or WRITE commands and even the number of instructions
  you want DEBUG to step through in the TRACE or PROCEED commands. <b>It's all HEX all the time when
  using DEBUG!</b></font></p>
<p><BR>
</p>
<HR size="3">
<A NAME=DETS></A>
<h1 align="center"><font face="Verdana, Arial, Helvetica, sans-serif">A Simple 
  DEBUG Tutorial</font></h1>
<H1 align="center"><FONT FACE="Verdana">Details of each Command</FONT></H1>
<br>
<HR>
<p><font face="Arial" size="4"><b>NOTE:</b> In the Examples below, commands which 
  are entered by a user are shown in <b>bold</b> type; data displayed in response 
  by DEBUG is in normal type. DEBUG (from MS-DOS<b> 5.0 or later</b> (which is 
  true for the DEBUG version used by Windows&#153; XP) will display the following 
  <i>usage</i> message, if you enter<font face="Courier New"><b>&nbsp;<font color="#0000FF">debug 
  /<font face="Arial">?</font></font><font face="Arial">&nbsp; </font></b></font> 
  at a DOS prompt:</font></p>
<PRE>C:\WINDOWS><b>debug /?</b>
Runs Debug, a program testing and editing tool.

DEBUG [[drive:][path]filename [testfile-parameters]]

  [drive:][path]filename  Specifies the file you want to test.
  testfile-parameters     Specifies command-line information required by
                          the file you want to test.</PRE>

<HR size="3">
<A NAME=Q></A><PRE><font size="5"><b><font color="blue">    Quit:</font>  Q</b>
</font></PRE>
<p><font face="Arial" size="4">&nbsp; &nbsp; Immediately quits (exits) the Debug 
  program! No questions ever asked... should be the first command you remember 
  along with the &quot;<b><font color="#0000FF">?</font></b>&quot; command.</font><b> 
  </b></p>
<b><PRE>
<a href="#TOC">Back to TOC</a>

<HR><A NAME=H></A>
<font size="5"><font color="blue">    Hex:</font>  H  value1  value2
</font></PRE>
</b><font face="Arial" size="4">&nbsp; &nbsp; A very simple (add and subtract 
only) Hex calculator. Never forget that all numbers inside of DEBUG are always 
Hexadecimal. Enter two Hex values (no more than four digits each) and DEBUG shows 
<b>first</b> the SUM, then the DIFFERENCE of those values. Examples:</font> 
<PRE><font size="4">   -<b>h aaa 531    </b>-<b>h fff 3</b>      -<b>h dbf ace</b>
   0FDB  0579    1002  0FFC    188D  02F1
   -             -             -</font></PRE>
<p><font face="Arial" size="4"><b>Differences</b> are always the second value 
  <i>subtracted from</i> the first;<font face="Courier New, Courier, mono"> <b>AAA</b></font> 
  - <b><font face="Courier New, Courier, mono">531</font></b> = <b><font face="Courier New, Courier, mono">579</font></b>. 
  There are no <i>carries</i> past four digits.</font></p>
<p><font face="Arial" size="4"><b>Two's Complement</b> arithmetic is always used 
  in this calculator, so think of it as being limited to a <i>maximum</i> of <i>plus</i> 
  7FFFh (+ 32,767) or a <i>minimum</i> of <i>minus</i> 8000h (- 32,768). Positive 
  values are represented by exactly the same digits as their numbers for 0000h 
  through 7FFFh. A <i>minus</i> 7FFFh, however, is represented by the Hex digits 
  <b><font face="Courier New, Courier, mono" size="5">8001</font></b>, and a <i>minus</i> 
  1h (-1) is represented by the Hex digits <b><font size="5" face="Courier New, Courier, mono">FFFF</font></b>. 
  Thus, the output of DEBUG after entering &quot;<b><font face="Courier New, Courier, monospace">h 4 fffc</font></b>&quot; would be a <i>zero</i> 
  and an 8, because <b><font size="5" face="Courier New, Courier, mono">FFFC</font></b> 
  represents a <i>minus</i> 4h (-4) and <b><font face="Courier New, Courier, mono">4 
  -</font></b> (<b><font face="Courier New, Courier, mono">-4</font></b>) = <b><font face="Courier New, Courier, mono">8</font></b>. 
  &nbsp;Examples:</font></p>
<PRE><font size="4">   -<b>h 4 fffc</b>    -<b>h 100 123</b>    -<b>h 7fff 8000</b>
   0000 0008    0223  FFDD    FFFF FFFF
   -            -             -</font></PRE>
<font face="Arial" size="4">Note the difference between 100h and 123h; 
what does   
<font face="Courier New, Courier, mono"> <font size="5"> <b>FFDD</b></font></font> represent? To find the numerical value of a Two's Complement number, 
first invert every bit (or find its logical inverse); that would be <font face="Courier New, Courier, mono"><b>0022</b></font>, 
then <b>add 1</b>. So, this represents a <i><b>negative</b></i><b> 23</b>h. Both 
the <b>sum</b> and the <b>difference</b> of 7FFFh and 8000h are a <b>negative 
1</b> (or <b><font face="Courier New, Courier, mono" size="5">FFFF</font></b>); which can be  arrived at using: 7FFFh + (- 8000h) = -1. 
However, it's much easier to  think of the <b>sums</b> as having nothing to do with  Two's 
Complement notation; thus, 7FFFh + 8000h = FFFFh (32,767 + 32,768 = 65,535). This 
will even hold true for the differences<i> <b>if </b>the second value is less 
than the first</i>. But any   difference which produces a negative number, 
must be represented in Two's Complement.<br>
<br></font> 
<PRE><b><a href="#TOC">Back to TOC</a></b>

<HR><A NAME=D></A>
<font size="5"><b><font color="blue">   Dump:</font>  D  [range]
          D  [address]  [length]</b></font></PRE>
<p><font face="Arial" size="4">&nbsp; &nbsp; Displays the contents of a block 
  of memory. The Memory locations near the beginning of Segment <b><font face="Courier New, Courier, mono" size="5">C000</font></b> 
  (even under Windows 2000/XP) should display information about the kind of video 
  card installed on your PC. The first example below shows what a Matrox video 
  card on our system displayed.<br>
  <br>
  Examples:</font></p>
<PRE>-<b>d c000:0010</b>
C000:0010 24 12 FF FF 00 00 00 00-60 00 00 00 00 20 49 42  $.......`.... <b>IB</b>
C000:0020 4D 20 43 4F 4D 50 41 54-49 42 4C 45 20 4D 41 54  <b>M COMPATIBLE MAT</b>
C000:0030 52 4F 58 2F 4D 47 41 2D-47 31 30 30 20 56 47 41  <b>ROX/MGA-G100 VGA</b>
C000:0040 2F 56 42 45 20 42 49 4F-53 20 28 56 31 2E 32 20  <b>/VBE BIOS (V1.2</b>
C000:0050 29 00 87 DB 87 DB 87 DB-87 DB 87 DB 87 DB 87 DB  <b>)</b>...............
C000:0060 50 43 49 52 2B 10 01 10-00 00 18 00 00 00 00 03  PCIR+...........
C000:0070 40 00 12 10 00 80 00 00-38 37 34 2D 32 00 FF FF  @.......874-2...
C000:0080 E8 26 56 8B D8 E8 C6 56-74 22 8C C8 3D 00 C0 74  .&amp;V....Vt&quot;..=..t
-</PRE>

<PRE>-<b>d 100 130</b>
xxxx:0100 EB 24 0D 0A 54 68 69 73-20 69 73 20 6D 79 20 66  .$..This is my f
xxxx:0110 69 72 73 74 20 44 45 42-55 47 20 70 72 6F 67 72  irst DEBUG progr
xxxx:0120 61 6D 21 0D 0A 24 B4 09-BA 02 01 CD 21 B4 00 CD  am!..$......!...
xxxx:0130 21                                               !
-</PRE>
<font face="Arial" size="4">The last example above, is what you'd see after entering 
the code under the <a href="#A"><b>A</b>ssemble</a> command. We could just as 
easily have used the<font face="Courier New"><b> length </b></font>option with 
the command '<font face="Courier New"><b>d 100 l31</b></font>' (that's an 'L' 
in front of the &quot;31&quot;) to produce the same results above. The following 
example shows only the '$'-terminated display string, which has a length of 24h 
bytes (remember numbers in DEBUG are always hexadecimal); so that's 36 in decimal:</font> 
<PRE>
-<b>d 102 l24</b>
xxxx:0100       0D 0A 54 68 69 73-20 69 73 20 6D 79 20 66    ..This is my f
xxxx:0110 69 72 73 74 20 44 45 42-55 47 20 70 72 6F 67 72  irst DEBUG progr
xxxx:0120 61 6D 21 0D 0A 24                                am!..$
-<b>

<a href="#TOC">Back to TOC</a>

<HR><A NAME=S></A>
<font size="5"><font color="blue">  Search:</font>  S  range  list
</font></b></PRE>
<p><font face="Arial" size="4">&nbsp; &nbsp; Searches within a range of addresses 
  for a pattern of one or more byte values given in a list. The list can be comprised 
  of numbers <i>or character strings enclosed by matching single or double quote 
  marks.</i> [ NOTE: In the examples below, if you do find the same data on your 
  computer, the locations could easily vary from ours! ]</font></p>
<p><font face="Arial" size="4">Examples:</font> </p>
<PRE>-<b>s fe00:0 ffff &quot;BIOS&quot;</b>
FE00:<span style="background-color: #CCFFFF">0021</span>
FE00:<span style="background-color: #FFFF00">006F</span>

-<b>d fe00:0</b>
FE00:0000 41 77 61 72 64 20 53 6F-66 74 77 61 72 65 49 42  Award SoftwareIB
FE00:0010 4D 20 43 4F 4D 50 41 54-49 42 4C 45 20 34 38 36  M COMPATIBLE 486
FE00:0020 20 42 49 4F 53 20 43 4F-50 59 52 49 47 48 54 20   <span style="background-color: #CCFFFF">BIOS</span> COPYRIGHT
FE00:0030 41 77 61 72 64 20 53 6F-66 74 77 61 72 65 20 49  Award Software I
FE00:0040 6E 63 2E 6F 66 74 77 61-72 65 20 49 6E 63 2E 20  nc.oftware Inc.
FE00:0050 41 77 03 0C 04 01 01 6F-66 74 77 E9 12 14 20 43  Aw.....oftw... C
FE00:0060 1B 41 77 61 72 64 20 4D-6F 64 75 6C 61 72 20 42  .Award Modular <span style="background-color: #FFFF00">B</span>
FE00:0070 49 4F 53 20 76 34 2E 35-31 50 47 00 DB 32 EC 33  <span style="background-color: #FFFF00">IOS</span> v4.51PG..2.3

-<b>s 0:0 dff 'A20'</b>
0000:<span style="background-color: #FFCCFF">0C42</span>

-<b>d 0:c40</b>
0000:0C40 0D 0A 41 32 30 20 68 61-72 64 77 61 72 65 20 65  ..<span style="background-color: #FFCCFF">A20</span> hardware e
0000:0C50 72 72 6F 72 2E 20 20 43-6F 6E 74 61 63 74 20 74  rror.  Contact t
0000:0C60 65 63 68 6E 69 63 61 6C-20 73 75 70 70 6F 72 74  echnical support
0000:0C70 20 74 6F 20 69 64 65 6E-74 69 66 79 20 74 68 65   to identify the
0000:0C80 20 70 72 6F 62 6C 65 6D-2E 0D 0A 24 1A 00 BA F6   problem...$....

-<b>s 0:0 dff <span style="background-color: #CCFFFF">43 4f 4d</span></b>
0000:0774
0000:07C2
0000:07D4
0000:07E6

-<b>d 0:770</b>
0000:0770 7A 02 A6 02 <span style="background-color: #CCFFFF">43 4F 4D</span> 31-20 20 20 20 8E 00 70 00  z...<span style="background-color: #FFFF00">COM</span>1    ..p.
0000:0780 C0 A0 7A 02 91 02 4C 50-54 31 20 20 20 20 A0 00  ..z...LPT1    ..
0000:0790 70 00 C0 A0 7A 02 98 02-4C 50 54 32 20 20 20 20  p...z...LPT2
0000:07A0 2D 01 70 00 C0 A0 7A 02-9F 02 4C 50 54 33 20 20  -.p...z...LPT3
0000:07B0 20 20 11 EA 27 27 3F FD-CA 00 70 00 00 80 7A 02    ..''?...p...z.
0000:07C0 AC 02 <span style="background-color: #CCFFFF">43 4F 4D</span> 32 20 20-20 20 DC 00 70 00 00 80  ..<span style="background-color: #FFFF00">COM</span>2    ..p...
0000:07D0 7A 02 B2 02 <span style="background-color: #CCFFFF">43 4F 4D</span> 33-20 20 20 20 00 00 6B 03  z...<span style="background-color: #FFFF00">COM</span>3    ..k.
0000:07E0 00 80 7A 02 B8 02 <span style="background-color: #CCFFFF">43 4F-4D</span> 34 20 20 20 20 E8 D2  ..z...<span style="background-color: #FFFF00">COM</span>4    ..


<b><a href="#TOC">Back to TOC</a>

<HR><A NAME=C></A>
<font size="5"><font color="blue">Compare:</font>  C  range  address
</font></b></PRE>
<font face="Arial" size="4">&nbsp; &nbsp; Compares two 
blocks of memory. If there are no differences, then DEBUG simply displays another prompt (-). Here's an example of what happens when there <i>are</i> differences:</font>
<PRE>     -<b>c 140 148 340</b>
     127D:0143  30  6D  127D:0343
     127D:0146  10  63  127D:0346
     127D:0148  49  30  127D:0348</pre>
<font face="Arial" size="4">The bytes at locations 140 through 148 are being compared 
to those at 340 <b>( </b>through 348, <i><b>implied</b></i><b> )</b>; the bytes 
are displayed <b><i>side by side</i></b> for those which are different (with their 
exact locations, including the segment, on either side of them). </font> 
<PRE><b>

<a href="#TOC">Back to TOC</a>

<HR><A NAME=F></A>
<font size="5"><font color="blue">   Fill:</font>  F  range  list
</font></b></PRE>
<font face="Arial" size="4">&nbsp; &nbsp; This command can also be used to <i>clear</i> 
&nbsp;a whole segment of Memory as well as <i>filling</i> smaller areas with a 
continuously repeating phrase or single byte. Examples: </font> 
<PRE>-<b>f 100 12f 'BUFFER'</b>
-<b>d 100 12f</b>
xxxx:0100  42 55 46 46 45 52 42 55-46 46 45 52 42 55 46 46 BUFFERBUFFERBUFF
xxxx:0110  45 52 42 55 46 46 45 52-42 55 46 46 45 52 42 55 ERBUFFERBUFFERBU
xxxx:0120  46 46 45 52 42 55 46 46-45 52 42 55 46 46 45 52 FFERBUFFERBUFFER
   
-<b>f 100 ffff 0</b></PRE>
<p><font face="Arial" size="4">This last example fills <i>almost all</i> of the 
  assigned Segment with zero bytes (which can also be thought of as <i>clearing</i> 
  &nbsp;the Segment). You should use this command whenever you want to be sure 
   the bytes you'll be looking at in DEBUG's Segment are those you  entered or loaded, or  bytes DEBUG has changed; not  soem previously used bytes from memory! If you want to examine 
  a file from a disk in a 'clean' Segment, you'll first have to start DEBUG without 
  any filename, <i>clear the Segment</i> using: &nbsp;<b><font face="Courier New, Courier, mono">f 
  100 ffff 0</font></b> &nbsp;and <i>then</i> finally load the file using the 
  <a href="#N">Name (n)</a> and <a href="#L">Load (L)</a> commands in that order.</font></p>
<p><font face="Arial, Helvetica, sans-serif" size="4"><b><font color="#FF0000">NOTE:</font></b> 
  Filling (clearing) any bytes in the area from <b><font color="#FF0000">00</font></b>h 
  <b><font color="#FF0000">through FF</font></b>h of our Segment can sometimes lead to problems; especially when file <font face="Verdana, Arial, Helvetica, sans-serif">I</font>/O 
  is involved. DEBUG stores data for its own use in those locations, so we recommend 
   you never overwrite bytes in that area; unless you have a reason for doing so!</font></p>
<p><font face="Arial, Helvetica, sans-serif" size="4">Example: A student in an 
  Assembly class was told to enter a string of commands under DEBUG, the last 
  one being: <b>JMP 0</b> which he was supposed to <a href="#T">Trace (T)</a> 
  to the next command and then execute it. He was told it would be an <b><font face="Verdana, Arial, Helvetica, sans-serif">I</font>NT 
  20</b> instruction. Well in most cases this is true, because DEBUG <i>always</i> 
  sets the first two bytes of its working segment to &quot;CD 20&quot; for just 
  this purpose. Let's test this out. First, open a new instance of DEBUG, then 
  enter the following commands:</font></p>
<PRE>-<b>f 100 ffff 0</b>    <font color="#990000"><b>[Zero-out 100 through FFFF]</b></font>
-<b>e 100 e9 fd fe</b>  <b><font color="#990000">[Enters a 'JMP 0' at 100]</font></b>
-<b>u 100 102</b>       <font color="#990000"><b>[Check for correct entry]</b></font>
xxxx:0100 E9FDFE        <b>JMP     0000</b>
-<b>r</b><br>AX=0000  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000<br>DS=xxxx  ES=xxxx  SS=xxxx  CS=xxxx  IP=0100   NV UP EI PL NZ NA PO NC<br>xxxx:0<b>100</b> E9FDFE        JMP     0000
-<b>u 0 1</b>
xxxx:0000 CD20          <b>INT     20</b>
</PRE>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="4">I</font><font face="Arial, Helvetica, sans-serif" size="4">f 
  you don't see &quot;INT 20&quot; after entering &quot;u 0 1&quot;, then restart 
  DEBUG and try again.</font></p>
<PRE>-<b>t</b>  <font color="#990000">[The &quot;<b>T</b>&quot;(Trace) command]</font>

AX=0000  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
DS=xxxx  ES=xxxx  SS=xxxx  CS=xxxx  IP=0000   NV UP EI PL NZ NA PO NC
xxxx:0000 CD20          INT     20
-<b>p</b>  <font color="#990000"><b>[</b>Always make sure you use a &quot;<b>P</b>&quot;(Proceed) command for <b>Interrupts!]</b></font>

Program terminated normally
-<b>q</b>  <font color="#990000"><b>[Quit]</b></font></PRE>
<p><font face="Arial, Helvetica, sans-serif" size="4"> Well, this never worked 
  for those students. Why? Because the teacher had mistakenly told them to <b>F</b>ill 
  the whole segment with zero bytes (<b><font color="#FF0000">f 0 ffff 0</font></b>), 
  in essence telling them to delete the very instruction he'd wanted them to execute!</font></p>
<PRE><b><a href="#TOC">
Back to TOC</a>

<HR><A NAME=E></A>
<font size="5"><font color="blue">  Enter:</font>  E  address  [list]
</font></b></PRE><font face="Arial" size="4">&nbsp; &nbsp; Used to 
enter data or instructions (as <i>machine code</i>) directly into Memory 
locations.<br>
&nbsp; &nbsp; Example. First we'll change a single byte at location <font face="Verdana">CS:<b>FFCB</b></font> 
from whatever it was before to <font face="Verdana"> <b>D2</b></font></font><font size="4"> :
<PRE>   -<b>e ffcb d2</b></PRE>
<font face="Arial">This next example shows that either single(') or double(&quot;) 
quote marks are acceptable for entering ASCII data. By allowing both forms, entry strings  
can be created to include either type of quote mark as data:</font> 
<PRE>   -<b>e 200 'An &quot;ASCII-Z string&quot; is always followed by '</b>
   -<b>e 22a &quot;a zero-byte ('00h').&quot; 0</b></PRE>
<font face="Arial">But in order to enter more than a single line of ASCII data, the 
<a href="#A">A (Assemble) command</a> is more practical since it will calculate the
next offset for you! (See that command for a Memory dump of these bytes.) &nbsp; 
Now we'll examine a string of 11 hex bytes you can enter into Memory at locations 
CS:0100 and following:</font> 
<PRE>   -<b>e 100 B4 09 BA 0B 01 CD 21 B4 00 CD 21</b></PRE>
<font face="Arial">This is actually machine code for a program that will display 
whatever ASCII characters it finds at locations CS:010B and following, until it 
encounters a byte value of 24h (a <b>$</b> sign). If you want to <i>run</i> this 
program, we'd recommend entering 24h at offset location  7EAh of the Segment so the program will  terminate 
there:</font> 
</font>
<PRE><font size="4">   -<b>e 7ea 24</b>
   -<b>g =100</b></font></PRE>
<font size="4"><font face="Arial">And you'll soon see: &quot;<font face="Times New Roman, Times, serif">Program 
terminated normally</font>&quot; on the display screen. Why did we pick 7EAh? Because  many DOS screens are set to display only 25 lines of 80 (50h) characters, and this value  allows you to view  the maximum number of characters  possible on a single screen between the &quot;Go,&quot;  termination and prompt (&quot;-&quot;) lines.</font></font><A NAME=PLAY><br>
</A><br>
<p><font face="Arial" size="4"> Here's something a bit more interesting for you 
  to try out: It's essentially the same program, but the data includes all of 
  the byte values from <b>00</b>h through <b>FF</b>h; except for <b>24</b>h which 
  we placed at the end of the last line. The DEBUG prompt symbol, - , has been 
  purposely excluded from the lines below, so you can <i>copy and paste</i> the 
  whole block into a DEBUG <i>DOS-box </i>(<a href="../../DOS/DOSinWIN.html" target="diw">Help 
  on using DOS-Window controls is here</a> if needed):</font></p>
<PRE><b>e 100 B4 09 BA 0B 01 CD 21 B4 00 CD 21 <font color="blue">0D 0A 0D 0A</font> 00 01 02
e 112 03 04 05 06 07 08 09 <font color="red">20</font> 0B 0C <font color="red">20</font> 0E 0F 10 11 12 13 14
e 124 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 <font color="red">20</font> 25 26
e 136 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 36 37 38
e 148 39 3A 3B 3C 3D 3E 3F <font color="blue">0D 0A 0D 0A</font> 40 41 42 43 44 45 46
e 15a 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53 54 55 56 57 58
e 16c 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A
e 17e 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C
e 190 7D 7E 7F <font color="blue">0D 0A 0D 0A</font> 80 81 82 83 84 85 86 87 88 89 8A
e 1a2 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C
e 1b4 9D 9E 9F a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aA aB aC aD aE
e 1c6 aF b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 bA bB bC bD bE bF <font color="blue">0D</font>
e 1d8 <font color="blue">0A 0D 0A</font> c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 cA cB cC cD cE
e 1ea cF d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 dA dB dC dD dE dF e0
e 1fc e1 e2 e3 e4 e5 e6 e7 e8 e9 eA eB eC eD eE eF f0 f1 f2
e 20e f3 f4 f5 f6 f7 f8 f9 fA fB fC fD fE fF <font color="blue">0D 0A 0D 0A</font> 24
</b></PRE>
<p><font face="Arial" size="4">The bytes <b>0D</b>h and <b>0A</b>h produce a Carriage 
  Return and Linefeed on the display, so we replaced them in the listing above by <b>20</b>h;
  a  SPACE byte. The <b>24</b>h byte was moved to the end of the program with
  another <b>20</b>h  taking its place. The bytes shown above in blue (<font color="blue">0D 0A 0D 0A</font>)
  form blank lines at the beginning of the output and after every 64 bytes for a nice formatted display.</font></p>
<p><font face="Arial" size="4">Therefore, when the program is run, we should see 
  four separate lines of 64 characters each (a few of those being blank spaces  
  as mentioned above), <b>right?</b> Well, let's find out: Start DEBUG in a DOS-Window, 
  <i>copy and paste</i> the lines above into DEBUG at its prompt symbol, then 
  enter the following command:</font> </p>
<PRE><font size="5">     <b>g =100</b></font>    <b>( 'g' followed by a SPACE, then '=100')</b></PRE>
<p><font 
face="Arial" size="4">This will immediately run (see <a href="#G"> Go command</a>) 
  the program, displaying the output lines followed by: &quot;<font face="Courier New, Courier, monospace">Program terminated normally</font>&quot; <b>[</b> Do <b><i>not</i></b> 
  exit DEBUG, just leave the window open. We're going to show you how to 'patch' this code and save the results as a nice little console program <b>]</b>.</font></p>
<p><font face="Arial" size="4">Were you surprised to find more than four spaces on the first line; starting with the very first byte? What about the fact we appear to have
  missing characters at the end of that line? We'll briefly explain why the characters appeared this way on your screen, but in order to create programs
  of your own, you'll need to study about <b>control</b> characters, <b>Interrupts</b> and what effect different <b>BIOS</b> and <b>DOS video</b> functions have on the way
  ASCII characters are displayed. OK, here's what happened:</font></p>
<p><font face="Arial" size="4">First, the Zero byte also displays as a blank space here. The 
  <b>07</b> byte may make a <i>beep</i> or <i>ding</i> sound (but does not display 
  anything), <b>08</b> performs a BACKSPACE (<i>erasing the <b>06</b> byte character</i>) and 
  <b>09</b> is a TAB -- which may jump up to eight columns to the right before 
  reaching the next 'Tab Stop.' But since it just happens to begin in column seven, 
  it only moves one column to the right where our program places the space 
  we substituted for <b>0A</b>h. Lastly, for some reason, when using Function 
  09 of INT 21h (&quot;Display a string of characters until a '$' sign is encountered&quot;), 
  the ESC character (<b>1B</b>h; 27 decimal) doesn't display or do anything. So, after reaching
  the end of the first line, it only appeared as if many of the characters we expected to see
  were never displayed. In reality, the last three characters are there. It's because of the bytes
  <b>07</b>h (displayed nothing), <b>08</b>h (only backspaced over 06h), <b>09</b>h
  (displayed nothing, but moved cursor forward one byte) and <b>1B</b>h (displayed nothing) that
  we saw what we did.<br><br>
  Enter the following two lines into DEBUG (which contain more <i>blank-space</i> 
  substitutions),  run the program again, and you'll see all  the <i>displayable 
characters </i>output on the first line in their correct positions:</font> </p>
<PRE><b>e 10F 00 01 02 03 04 05 06 <font color="red">20 20 20 20</font> 0B 0C <font color="red">20</font>
e 11D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A <font color="red">20</font></b></PRE>
<font face="Arial" size="4">All four rows will display evenly in size, including the last one. But the 
last character, <b>FF</b>h (255 decimal), just like the first, also displays as a blank space here! 
You can prove this by inserting another byte such as <b>2E</b>h (a period '.') after <b>FF</b>h. 
We've created the following patch which effectively <i>moves</i> up the remainder of the program after the
<b>FF</b>h by one:<br><br>
<font face="Courier"><b>e 21b 2e 0d 0a 0d 0a 24</b></font><br><br>
After <i>patching</i> and running it again, the program output should look like this:<br>
<br><center>
  <font face="Arial" size="4"><img src="dEASCII.gif" width=556 height=222></font>
</center><br>If you want to, you can save this code as an executable program by first giving it a path and 
filename (such as, C:\TEMP\ASCIIDSP.COM; see <a href="#N">Name command</a>) and writing the bytes (see 
<a href="#W">Write command</a>) to a file like this:<BR></font>
<PRE><font size="4">   -<b>n c:\temp\asciidsp.com</b>
   -<b>rcx</b>
   CX0000
   :<b>121</b>       <font face="Tahoma">[ Program Length = 220h - 100h + 1 = 121h ]</font>
   -<b>w</b></font></PRE>
<p><font face="Arial" size="4">If you check the file properties of ASCIIDSP.COM, 
  its size should be 289 bytes.</font></p>
<p><a href="#TOC"><b>Back to TOC</b></a> </p>
<HR><A NAME=G></A><PRE><b>
<font size="5"><font color="blue">     Go:</font>  G  [=address]  [<u>addresses</u>]
</font></b></PRE>
<p><font face="Arial" size="4">&nbsp; &nbsp; Go is used to run 
  a program and set <i><u>breakpoints</u></i> in the program's code.<br>
  <br>
  As we saw in an Example for the ENTER command, the '=address' option is used 
  to tell DEBUG where to start executing code. If you use '<b>g</b>' all by itself, execution 
  will begin at whatever location is pointed to by the <font face="Verdana"><b>CS:IP</b></font> registers.<br>
  <br>
  <font face="Verdana"><i>Breakpoints</i></font> are used to HALT the execution of a program we're testing at some
  point of interest before its termination. <b>Up to 10, optional <i>breakpoint addresses</i></b> may be set by
  simply listing them on the '-g' command line; separated by spaces. DEBUG will halt execution just before any of
  breakpoint addresses is about to be executed, and all of them will be 'cleared' at this time as well. (If you
  should somehow attempt to set more than 10 breakpoints, DEBUG will respond with: &nbsp;<font face="Courier New,
  courier, monospace">bp Error</font>.<br>
  <br>
  <b>NOTE:</b> Breakpoints can only be set at an address containing the <b>first byte</b> of a <b><i>valid</i>
  8088/8086 opcode</b>. So don't be surprised if picking some arbitrary address never halts the program;
  especially if you're trying to DEBUG a program containing opcodes DEBUG can't understand (that's any instruction
  which <b><i>requires </i></b>a CPU above an 8088/8086)!</font></p>
<p><font face="Arial" size="4">Using &quot;<b>Go</b>&quot; after setting <i><b>breakpoints</b> </i>at instructions
 you're sure DEBUG understands is one way you can get more use out of this program; for example, when debugging the
 &quot;real&quot; code of a Master Boot Record written for an 80386 or above processor. DEBUG won't be able to
 disassemble, nor step through, such code, <b>but it <i>can</i> pass the code for those type of instructions to the
 CPU for immediate execution</b>, and still stop at the breakpoint(s) you've set for any instruction that it
 <b><i>does</i></b> understand!<br><br>
  <b><font color="#FF0000">CAUTION:</font></b> DEBUG replaces the original instructions of any listed breakpoint
  addresses with <b>CC</b>h (an INT 3). The instructions at these locations are restored to their original bytes
  ONLY if one of the breakpoints is encountered. If DEBUG does <b>not</b> halt on any of the set breakpoint(s), they
  will remain enabled! So, don't ever save the code unless you're sure all breakpoints have been cleared! (Saving
  your work to a backup copy <i>before ever using a breakpoint</i> is the best way to avoid corrupting the code.)<br>
<br><font face="Times New Roman, serif"><b>Technical Notes:</b></font> The &quot;User&quot; stack pointer
 must be valid and have 6 bytes available for this command to function correctly. An <font face="Courier New, Courier,
 monospace"><b>iret</b></font> instruction is used to jump to the first breakpoint encountered. DEBUG sets the User
 Stack Pointer and pushes the user Flags, the Code Segment register and the Instruction Pointer onto the User Stack.
 So if the User Stack is not valid or is too small, the operation might crash.</font></p>


<PRE><b>

<a href="#TOC">Back to TOC</a>

<HR size="3"><A NAME=A></A>
<font size="5"><font color="blue">Assemble:</font>  A  [address]</font></b></PRE>
<p><font face="Arial" size="4"> Creates machine executable code in memory beginning 
  at CS:0100 (or the specified address) from the 8086/8088 (and 8087) Assembly Language 
  instructions which are entered. Although no Macro instructions nor labels are 
  recognized, you can use the <i>pseudo-instructions</i> 'DB' and 'DW' (so you can 
  use the DB opcode to enter ASCII data like this: &nbsp;DB &nbsp; 'This is a string',0D,0A 
); spaces after the commas would make it clearer  but aren't necessary.</font></p>
<p><font face="Arial" size="4">The 'A' command remembers the last location where any data
  was assembled, so successive 'A' commands (when no address is specified) will always
  begin at the next address in the chain of assembled instructions. This aspect of the
  command is similar to the Dump command which remembers the location of its last dump
  (if no new address is specified).<BR>
  <BR>
  The assembly process will stop <b><i>after</i></b> you ENTER an empty line.<br>
  <br>
<b>Example</b>s:</font></p>
<p><font size="4" face="Arial">Using the character string from our <a href="#E">E (Enter) command</a> above:</font></p>
<PRE>      -<b>a 200</b>
      xxxx:0200 <b>db 'An "ASCII-Z string" is always followed by '</b>
      xxxx:022A <b>db "a zero-byte ('00h').", 0</b>
      xxxx:023F
      -<b>d 200 23e</b>
      xxxx:0200  41 6E 20 22 41 53 43 49-49 2D 5A 20 73 74 72 69   An "ASCII-Z stri
      xxxx:0210  6E 67 22 20 69 73 20 61-6C 77 61 79 73 20 66 6F   ng" is always fo
      xxxx:0220  6C 6C 6F 77 65 64 20 62-79 20 61 20 7A 65 72 6F   llowed by a zero
      xxxx:0230  2D 62 79 74 65 20 28 27-30 30 68 27 29 2E 00      -byte ('00h')..</PRE>
	  
<p><font face="Arial" size="4">ENTER the characters in <b>bold blue type</b>; you do <i><b><font color="#990000">not</font></b></i> need to enter the comments after the semi-colon ( ; ) symbols:</font> 
</p>
<PRE>      -<b class="bl">a 100</b>
      xxxx:0100 <b class="bl">jmp 126</b>      ; Jump over data that follows:
      xxxx:0102 <b class="bl">db 0d,0a,"This is my first DEBUG program!"</b>
      xxxx:0123 <b class="bl">db 0d,0a,"$"</b>
      xxxx:0126 <b class="bl">mov ah,9</b>     ; Function 09 of Int 21h:
      xxxx:0128 <b class="bl">mov dx,102</b>   ; DS:DX <font color="#FF0000"><b>-&gt;</b></font> $-terminated string.
      xxxx:012B <b class="bl">int 21</b>       ; Write String to STD Output.
      xxxx:012D <b class="bl">mov ah,0     ;</b> Function 00 of Int 21h:
      xxxx:012F <b class="bl">int 21</b>       ; Terminate Program.
      xxxx:0131
      -<b class="bl">g =100</b>

      This is my first DEBUG program!

      Program terminated normally
      -

</PRE>
<p><font face="Verdana" size="4"><b>NOTE:</b> You can <i>pipe</i> simple 8086/8088 Assembly Language
 <i>&quot;scripts&quot; </i>into DEBUG (You can even include a semi-colon ';' followed by comments on most
 of its lines. For some odd reason though, these comments do not appear to be allowed on DB/DW lines!). For
 example, you can <i>copy and paste</i> the following into DEBUG (after entering an initial &quot;a&quot;
 command) and obtain the same results as above:</font></p>
<PRE><b>jmp 126      ; Jump over data that follows:
db  0d,0a,"This is my first DEBUG program!"
db  0d,0a,"$"
; End of string marker above: "$"=24h
mov ah,9     ; Function 09 of Int 21h:
mov dx,102   ; DS:DX -> $-terminated string.
int 21       ; Write String to STD Output.
mov ah,0     ; Function 00 of Int 21h:
int 21       ; Terminate Program.</b></PRE>
<font face="Verdana" size="4"><UL><LI>DEBUG uses the convention of enclosing operands which refer to 
Memory locations in square brackets '[ ]' (as opposed to an immediate value 
as an operand).</LI>
<br><br>
<LI>DEBUG may require you to explicitly tell it whether or not an operand 
refers to a <i>word</i> or <i>byte</i> in Memory! In such cases, the data 
type must be stated using the prefixes 'WORD PTR' or 'BYTE PTR'</LI>
<br><br>
<LI>For all 8087 Math Coprocessor opcodes, the WAIT or FWAIT prefix must be explicitly 
specified.</LI></UL>
</font><PRE><b><a href="#TOC">Back to TOC</a>

<HR><A NAME=U></A>
<font size="5"><font color="blue"><i>Un</i>assemble:</font>  U  [range]
</font></b></PRE><font face="Arial" size="4">&nbsp; <b><i>Disassembles</i>
</b> machine instructions into 8086 Assembly code. <b>Without the optional 
[range]</b>, it uses <b>Offset 100</b> as its starting point, disassembles 
about 32 bytes and then remembers the next byte it should start with if the 
command is used again. ( The word 'about' was used above, because it may 
be necessary to finish with an odd-number of bytes greater than 32, depending 
upon the last type of instruction DEBUG has to disassemble. )<BR><BR>
&nbsp; &nbsp; &nbsp;<b>NOTE:</b> The user must decide whether the bytes that DEBUG 
disassembles are all 8086 <b>instructions</b>, just <b>data</b> or any  
newer x86 instructions (those for the 80286, 80386 on up to the lastest 
CPU from Intel; which are all beyond the ability of DEBUG to understand)!</font> 
<PRE><font size="4"><b>   Example:

   </b>-<b>u 126 12F</b>
   xxxx:0126 B409          MOV     AH,09
   xxxx:0128 BA0201        MOV     DX,0102
   xxxx:012B CD21          INT     21
   xxxx:012D B400          MOV     AH,00
   xxxx:012F CD21          INT     21
   -</font><b>
   

<a href="#TOC">Back to TOC</a>

<HR><A NAME=I></A>
<font size="5"><font color="blue">  Input:</font>  I  port
</font></b></PRE>
<p><font face="Arial" size="4">The use of <font face="Verdana, Arial, Helvetica, sans-serif">I</font>/O 
  commands while running Windows&#153;9x/Me is <i>just plain</i> unreliable!</font> 
  <font face="Arial" size="4">This is especially true when trying to directly 
  access hard disks! Under Win NT/2000/XP, the <font face="Verdana">I</font>/O 
  commands are only an <b><i>emulation</i></b>; so don't trust them. Though the 
  example below still works under Win2000/XP, it's most likely using some WinAPI 
  code to show what's in the Windows clock area; <i>not</i> directly from an RTC 
  chip.</font></p>
<p><font face="Arial" size="4">Long ago (when DOS was the only OS for PCs), there 
  were dozens of <b>BASIC</b> programs that used <font face="Verdana">I</font>/O 
  commands for handling tasks through parallel and serial ports (e.g., to change 
  the font used by a printer or values in a modem's control registers). Under 
  real DOS, they can still be used for direct communications with keyboards or 
  a floppy drive's control chips along with many other hardware devices.<br>
  &nbsp; &nbsp; Here's an example of how to read the hours and minutes from a 
  computer's &quot;real time clock&quot; (RTC):</font></p>
<pre><font face="Courier New" size="4">    -<b>o 70 04</b>  &lt;-- <font face="Arial">Check the <b>hours</b>.</font>
    -<b>i 71</b>
    18  &lt;----- <font face="Arial">18 hours (or 6 p.m.)</font>
    -<b>o 70 02</b>  &lt;-- <font face="Arial">Check the <b>minutes</b>.</font>
    -<b>i 71</b>
    52  &lt;----- <font face="Arial">52 minutes</font></font></pre>
<font face="Arial" size="4">The first space isn't necessary under most versions 
of DEBUG; so you can try to get away with just &quot;o70&quot; and &quot;i71&quot; 
instead. Here's a page of more complex examples dealing with <a href="../../asm/debug/ATAscript.htm" target="ATA">hard 
drives and the ATA commands for reading info directly from a disk controller</a>!</font> 
<PRE><b><a href="#TOC">Back to TOC</a>

<HR><A NAME=O></A>
<font size="5"><font color="blue">  Output:</font>  O  port  byte
</font></b></PRE>
<p><font face="Arial" size="4">&nbsp; &nbsp; See comments under the<b><font size="5"><font color="blue"> 
  <font face="Courier New"><a href="#I">Input</a></font></font></font></b><font size="5"><font face="Arial" size="4"> 
  command.</font></font></font> </p>
<PRE><b><a href="#TOC">Back to TOC</a>

<HR><A NAME=L></A>
<font size="5"><font color="blue">   Load:</font>
L [address] [drive] [firstsector] [number]<br>&nbsp;&nbsp;&nbsp;<i>or program!</i><font size="4" face="Arial, Helvetica, sans-serif"> (See the <a href="#N">N command</a> for more on this)</font> 
</font></b></PRE>
<p><font face="Arial" size="4">&nbsp; &nbsp; This command will LOAD the selected 
  number of sectors from any disk's Logical Drive under the control of MS-DOS 
  or Windows into Memory. The <b>address</b> is the location in Memory the data 
  will be copied to (use only 4 hex digits to keep it within the memory allocated 
  to DEBUG), the <b>drive</b> number is mapped as: 0=A:, 1=B:, 2=C:, etc., <b>firstsector</b> 
  counts from ZERO to the largest sector in the volume <i>and finally</i> <b>number</b> 
  specifies <b>in hexadecimal</b> the<i> <b>total </b></i><b>number</b> of sectors 
  that will be copied into Memory (so a floppy disk with 0 through 2,879 sectors 
  would be: 0 through <b><font face="Courier New, Courier, mono" size="5">B3F</font></b> 
  in Hex).</font><font face="Arial" size="4"><br>
  </font></p>
<p><font face="Arial" size="4">&nbsp; &nbsp; The terms 'Volume' or 'Logical Drive' 
  used in the definition above mean  you can<b><i>not</i></b> use the 'L' 
  command to load or examine the <b>MBR</b>, or any other sectors outside  the 
  Primary Volumes or Logical Drive Letters assigned by DOS or Windows!&nbsp;For 
  example (under Windows&#153; 9x/ME), if you enter the command: &nbsp; <font face="Courier New"><b>L 
  100 2 0 1</b></font> &nbsp; in DEBUG, instead of seeing the very first sector 
  on that hard disk (the MBR), you'll see the first sector of the Boot Record 
  for the Logical drive C: instead (the first partition that can accessed by a 
  compatible MS-DOS or Windows OS). This and the following comments about diskettes, 
  show that DEBUG has always been quite limited compared to a good disk editor 
  or the UNIX 'dd' program.<br>
  </font></p>
<p><font face="Arial" size="4">Load can still be useful in examining Floppy Disks 
  <i>even under</i> Windows&#153; 2000/XP, <b><i>but (unfortunately), only if 
  the disk can be read by MS-DOS or Windows.</i></b> Once again, this shows how 
  limited DEBUG is compared to any utility that can view the <i>raw data</i> on 
  either a hard drive or diskette. (For those of you who wish to examine the actual 
  contents of a hard disk under Windows&#153; XP, there are free <i><a href="http://en.wikipedia.org/wiki/Disk_editor" target="wiki">disk 
  editors</a></i>, such as <a href="http://mh-nexus.de/hxd/" target="HxD">HxD</a>, 
  which allow you to do so.)</font></p>
<p><font face="Arial" size="4">Unlike hard disks, the very first sector on a floppy 
  disk is an OS Boot sector. Here's what you might see from a Logical disk sector 
  and some <a 
href="#D"><b>d</b><i>umps</i></a> from a couple floppy disks. <br>
  <br>
  Examples:</font></p>
<PRE>-<b>l 100 2 0 1</b>   [ the <b>C:</b> drive. ]
-<b>d 100 10f</b>
xxxx:0100  EB 58 90 4D 53 57 49 4E-34 2E 31 00 02 08 20 00  .X.MSWIN4.1... .
-<b>d 280 2ff</b>
xxxx:0280  01 27 0D 0A 49 6E 76 61-6C 69 64 20 73 79 73 74  .'..Invalid syst
xxxx:0290  65 6D 20 64 69 73 6B FF-0D 0A 44 69 73 6B 20 49  em disk...Disk I
xxxx:02A0  2F 4F 20 65 72 72 6F 72-FF 0D 0A 52 65 70 6C 61  /O error...Repla
xxxx:02B0  63 65 20 74 68 65 20 64-69 73 6B 2C 20 61 6E 64  ce the disk, and
xxxx:02C0  20 74 68 65 6E 20 70 72-65 73 73 20 61 6E 79 20  then press any
xxxx:02D0  6B 65 79 0D 0A 00 00 00-49 4F 20 20 20 20 20 20  key.....IO
xxxx:02E0  53 59 53 4D 53 44 4F 53-20 20 20 53 59 53 7E 01  SYSMSDOS   SYS~.
xxxx:02F0  00 57 49 4E 42 4F 4F 54-20 53 59 53 00 00 55 AA  .WINBOOT SYS..U.
-
-<b>l 100 0 0 1</b>   [ a floppy in the <b>A:</b> drive. ]
-<b>d 100 13d</b>
xxxx:0100  EB 3C 90 29 47 38 71 33-49 48 43 00 02 01 01 00  .<.)G8q3<span style="background-color: #FFDDDD">IHC</span>.....
xxxx:0110  02 E0 00 40 0B F0 09 00-12 00 02 00 00 00 00 00  ...@............
xxxx:0120  00 00 00 00 00 00 29 40-16 D8 13 4E 4F 20 4E 41  ......)@...NO NA
xxxx:0130  4D 45 20 20 20 20 46 41-54 31 32 20 20 20        ME    FAT12   
-
-<b>l 100 0 0 1</b>   [ a different floppy in the <b>A:</b> drive. ]
-<b>d 100 13d</b>
xxxx:0100  EB 3C 90 53 59 53 4C 49-4E 55 58 00 02 01 01 00  .<.SYSLINUX.....
xxxx:0110  02 E0 00 40 0B F0 09 00-12 00 02 00 00 00 00 00  ...@............
xxxx:0120  00 00 00 00 00 00 29 7E-CF 55 3C 20 20 20 20 20  ......)~.U<
xxxx:0130  20 20 20 20 20 20 46 41-54 31 32 20 20 20              FAT12   
-
-<b>d 2d0 2ff</b>
xxxx:02D0  42 3B 16 1A 7C 72 03 40-31 D2 29 F1 EB A7 42 6F  B;..|r.@1.)...Bo
xxxx:02E0  6F 74 20 66 61 69 6C 65-64 0D 0A 00 00 00 00 4C  ot failed......L
xxxx:02F0  44 4C 49 4E 55 58 20 53-59 53 F4 3C 82 3A 55 AA  DLINUX SYS.<.:U.
</PRE>
<p><font face="Arial" size="4">The Linux Boot disk above (note the word: 
  SYSLINUX) is the kind formatted as an MS-DOS diskette and not with a true Linux 
  file system (such as <i>ext2 </i>or <i>ext3</i>). If it had been formatted with 
  some other kind of file system, or had a faulty boot sector, then MS-DEBUG would 
  not be able to read it! Instead you'd see that old &quot;<font face="Courier New">General 
  failure reading drive A / Abort, Retry, Fail?</font>&quot; error message! And 
  when you had finally cleared away that error message, you'd be greeted by DEBUG's 
  &quot;<font face="Courier New">Disk error reading drive A</font>&quot; error message.
  This makes DEBUG almost worthless as far as trying to fix an error in a floppy disk's 
  boot sector! However, if you keep a binary copy of a <i>good</i> floppy disk 
  Boot Sector somewhere, you <i>could</i> use DEBUG to overwrite whatever's on 
  a faulty floppy disk's first sector (see <a href="#W">Write command</a>). <b>But</b> 
  if you really need  to see what's in such a Boot sector (i.e., what is  keeping DEBUG from 
  recognizing it as valid), you'll need to use a <i><a href="http://en.wikipedia.org/wiki/Disk_editor" target="wiki">disk 
  editor</a> </i>such as Symantec's Norton DiskEdit (in <b><i>Physical</i></b> disk Mode only).</font></p>
<p><font face="Arial" size="4"><b>NOTE: </b>Just because a floppy disk can't be 
  read by DOS or opened in DEBUG does NOT necessarily mean it's defective. It 
  might simply have been formatted with a file system it cannot recognize (such 
  as Linux's <i>ext2</i>) and could easily boot-up on its own;  a very 
  good reason for labeling your disks! (CAUTION: Never try booting your system 
  with a disk you're not 100% sure of; unless you disconnect all hard disks and 
  don't have any flash BIOS, since it might contain a nasty <i>boot virus!</i><A NAME=IHC> )</A><BR>
  &nbsp; [ <font size="3">Many floppy disks have the letters &nbsp; <font face="Verdana"><b>IHC</b></font> 
  &nbsp; in their OEM ID field. What kind of OEM Name is that? None. Someone at 
  Microsoft decided that this was where they'd place a new pseudo-random type 
  of identification to make sure that any information cached by '<b>Windows 9x</b>' 
  from one disk wouldn't be mixed up with info from a different one if you <i>swapped 
  disks</i>. The whole string begins with <b>five pseudo-random hex bytes</b>, 
  and always ends with the characters <font face="Verdana"><b>IHC</b></font>. <i>All</i> floppy diskettes 
  that are <b>not</b> write-protected will have any original OEM ID overwritten. 
  Once Windows has written this string, it will remain the same for any future 
  disk reads or writes. However, performing even a <i>quick</i> format under Windows, 
  will change the five hex bytes every time.<BR>
  &nbsp; &nbsp; Some have concluded the characters '<font face="Verdana"><b>IHC</b></font>' are the first 
  three letters of the word &quot;Chicago&quot; <i>in reverse order</i>, since 
  <b><i>Chicago</i></b> was the 'code name' for Windows<font face="Arial" size="4">&trade;</font> <b>95</b> before it was 
  ever released (it would have appeared as '<font face="Courier New, Courier, monospace"> OGACIHC</font>' on the hypothetical
  disk). Although certainly a possibility, I have no proof of that. Due to our interest in some very old Greek Manuscripts,
  we still can't help but see the 3 characters '<font face="Verdana">IHC</font>' as an Iota, Eta and <i>old style</i> Sigma
  since this combination of letters was often used as an abbreviation for the Greek word
  &quot;<font face="Verdana">IHSUS</font>&quot; (Jesus). Just another of many coincidences in our lives.<BR>
&nbsp; &nbsp; <b>REMEMBER:</b> If you really want to preserve all of the contents 
  of an important diskette, you can't even perform a simple Directory read under 
  a Windows OS, UNLESS it is 'write-protected' <b><i>and</i></b> you know the 
  drive's write-protect system is functioning correctly!</font> ]</font></p>
<p>&nbsp;</p>
<PRE><b><a href="#TOC">Back to TOC</a>

<HR><A NAME=M></A>
<font size="5"><font color="blue">   Move:</font>  M  range  address
</font></b></PRE>
<font face="Arial" size="4">&nbsp; &nbsp; This command 
could  be called  COPY (not Move), since it only <i>copies</i> all 
the bytes from within the specified <b>range</b> to a new <b>address</b>.<br>
<br>&nbsp; &nbsp; Examples:</font>
<PRE><font size="4">  <b>1)</b>   -<b>m 7c00 7dff 600</b></font></PRE>
<font face="Arial" size="4">Copies all 512 (200h) of the bytes between Offsets 7C00 and 
7DFF (inclusive) to Offset 0600 and following.</font>
<PRE><font size="4">  <b>2)</b>   -<b>m 100 2ff 200</b></font></PRE>
<p><font face="Arial" size="4">This second 
  example shows  it's very easy to <b><i>overwrite</i></b> much of the 
  same source area you're copying from when using the <i>Move</i> command. However, DEBUG 
  must store all the source bytes in Memory before writing them; otherwise, this 
  example would cause a problem when  overwriting an area   it hadn't 
 copied data from yet, <b><i>if </i></b>it were copying only one byte at a time from that source area! </font><font face="Arial" size="4">The example above copies all  512 bytes of offsets 100h through 2FFh 
  (inclusive) to <b>Offsets 0200</b>h and following; overwriting the last 256 (2FF-200+1 hex) bytes of the source in the 
  process. This is also true under real 16-bit DOS.</font></p>
<p><font face="Arial" size="4"><b>Note:</b> If your <i>Move </i>command produces a situation where offset  FFFFh has already been written to yet there's still more data to write, you may experience unexpected results! Remember, DEBUG is technically assigned  to only one <b>64 KiB</b> Segment. So, the data  will   <b><i>wrap around </i></b>to the beginning of the Segment, possibly <b><i>overwriting </i></b>  some  of the source bytes you  told it to copy from! But other symptoms may occur as well, since the first area to be overwritten <b>after</b> <i>wrapping around </i>(00h through FFh) is sometimes used by DEBUG to keep track of itself.  So do the math  whenever copying bytes to a <b>higher location</b> in Memory, to be sure you don't run out of room at the end of the Segment.</font></p>
<p><font face="Arial" size="4">Copying  bytes to a <b>lower location</b> in the Segment is quite simple though;  DEBUG could actually  copy just one byte at a time in that direction and never  overwrite a  source byte before it was already  copied.</font></p>
<PRE><b><a href="#TOC">Back to TOC</a>

<HR><A NAME=N></A>
<font size="5"><font color="blue">   Name:</font>  N  [pathname]  [arglist]
</font></b></PRE>
<p><font face="Arial" size="4">&nbsp; &nbsp; This command can be used to load 
  files into DEBUG's Memory <i>after</i> you have started the program, but it's 
  main function is to create a new file under control of the Operating System 
  which DEBUG can <a href="#W">WRITE</a> data to.<BR>
  &nbsp; &nbsp; Normally, when you want to 'debug' a file, you'd start DEBUG with 
  a command like this: &nbsp; <font face="Courier New">C:\WINDOWS&gt;<b>debug 
  test.com</b></font> . &nbsp; But it's also possible to load a file into DEBUG's 
  Memory from within DEBUG itself by using the 'N' command <i>and then the</i> 
  <a href="#L">'L' command</a> <b>(</b>with <b>no</b> parameters<b>)</b> like 
  this:<BR>
  <font face="Courier New">&nbsp; &nbsp; -<b>n c:\temp\test.com</b><BR>
  &nbsp; &nbsp; -<b>l</b></font><BR>
  which will load the file test.com into DEBUG's Memory starting at location CS:0100 
  <b>(</b>you cannot specify any other location when using the L command like 
  this!<b>)</b>.</font></p>
<p><font face="Arial" size="4">&nbsp; &nbsp; The 'N' command makes it quite easy 
  to save data or an Assembly program created in DEBUG to a file on your hard 
  drive! For example, the following commands (shown in <b class="bl">bold blue</b> type)
  will create a 68-byte file called <font face="Verdana">DOSWINOK.COM</font> in the
  C:\TEMP folder; <i>even </i>when running DEBUG in a DOS-window. The file names, however,
  are still limited to DOS's <b>eight</b> characters <i>plus </i><b>three</b> for the
  extension (often called an <i>8.3 filename</i>):</font></p>
<PRE>
  -<b class="bl">n c:\temp\doswinok.com</b>
  -<b class="bl">a 100</b>
  <i>cs</i>:0100 <b class="bl">jmp 138</b>
  <i>cs</i>:0102 <b class="bl">db 0d,0a,&quot;It's OK to run this &quot;</b>
  <i>cs</i>:0118 <b class="bl">db &quot;program under DOS or Windows!&quot;</b>
  <i>cs</i>:0135 <b class="bl">db 0d,0a,24</b>
  <i>cs</i>:0138 <b class="bl">mov dx,102</b>
  <i>cs</i>:013B <b class="bl">mov ah,9</b>
  <i>cs</i>:013D <b class="bl">int 21</b>
  <i>cs</i>:013F <b class="bl">mov ax,4c01</b>
  <i>cs</i>:0142 <b class="bl">int 21</b>
  <i>cs</i>:0144 &nbsp; [Press ENTER key.]
  -<b class="bl">rcx</b>
  CX 0000
  :<b class="bl">44</b>
  -<b class="bl">w</b>
  Writing 00044 bytes &nbsp; <FONT face=Georgia>[ 68 bytes in decimal ]</FONT>
  -<b class="bl">q</b></font> 
</PRE>
<p><font face="Arial, Helvetica, sans-serif" size="4">How did we arrive at the value of &quot;44&quot;
 to put into the CX register for writing that many bytes to our new file? Well, if you assemble a program
 in DEBUG using the <a href="#A">Assemble</a> command just as we did above, you can subtract the location
 that we started our programming on from the location DEBUG displays on the line you stopped the assembly
 by pressing the ENTER key. This will save you a bit of thought by not having to remember when you subtract
 the first byte location (of the first instruction) from the last byte location (of the last instruction),
 both bytes being inclusive, that you must then add a 1 to the result to obtain the total number of bytes
 in your program. Or, putting this in terms of the digits involved: &nbsp;
 (144h - 100h ) = (143h - 100h + 1) = 44 hex = 68 decimal.</font></p>

<p><font face="Arial" size="4"><b>NOTE:</b> Unlike other programs listed on this page, this last one used
 the Function 4Ch instead of Function 00 of Interrupt 21h to terminate its execution. This is the preferred
 termination function for most DOS programs, because it can send a &quot;Return Code&quot; (an ERRORLEVEL 
 value; of whatever is in the AL register), <i>and </i>will also close all open files and free all memory
 belonging to the process. However, when you use this function to terminate a program you run under DEBUG,
 it has a tendency to terminate DEBUG itself; thus the reason we rarely use it here!</font></p>

<p><font face="Arial" size="4"><i>Homework:</i> Follow the steps above to <a href="#A">Assemble</a> 
  and save this program under DEBUG, then use DEBUG to <b><i>debug it!</i></b> 
  Use the <a href="#P">P(roceed) command</a> to <b>step through</b> most of the 
  instructions, <b><i>since </i></b> this will keep you from accidentally <i>stepping 
  into</i> an <b>INT</b>(errupt) instruction! If you ever do use the T(race) command 
  on an INT, you'll end up inside nests of <b>BIOS</b> routines which often <i>crashes</i> 
  DEBUG!</font> </p>
<PRE>

<b><a href="#TOC">Back to TOC</a>

<HR><A NAME=R></A>
<font size="5"><font color="blue">Register:</font>  R  [register]</font>
</b></PRE><font face="Arial" size="4">&nbsp; &nbsp; Entering ' r ' all by 
itself will display <i>all</i> of the 8086 register's contents <i>and</i> 
the next instruction which the IP register points to in both machine code 
and an unassembled (Assembly Language) form. For example, if you start 
DEBUG in a Windows 95B DOS-box with the command line:<br> &nbsp; &nbsp; 
<font face="Courier New">&gt;<b>debug c:\windows\command\choice.com</b><br>
</font> and then enter an ' r ' at the first DEBUG prompt, DEBUG will 
display someting similar to this:</font><font size="3"><PRE>
AX=0000  BX=0000  CX=1437  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=0ED8  ES=0ED8  SS=0ED8  CS=0ED8  IP=0100   NV UP EI PL NZ NA PO NC
0ED8:0100 E90E01        JMP     0211
</PRE>
</font><font face="Arial" size="4">For an explanation of the names of 
the registers (AX, BX, CX, etc. and the <I>Flag symbols:</i> NV UP EI PL NZ 
NA PO NC), see the Appendix (<a href="../../asm/debug/8086REGs.htm#REGS" target=REGS>The 8086 CPU Registers</a>). 
 The last line shows  the next CPU instruction (actually the <i>first</i> 
 in this case) to be executed, begins at memory location 100 hex (the offset) 
 in Segment ED8 hex (0ED8:0100) and the Hex bytes E90E01 represent the 
 actual binary machine code of the CPU instruction (JMP 0211 in Assembly 
 language) that <i>would be executed by DEBUG</i> if you entered a 
<a href="#T">Trace (<b>t</b>)</a> or <a href="#P">Proceed (<b>p</b>)</a> 
 command.<br>
<br>If you enter the ' r ' followed by the abbreviation for an 
 8086 register, such as: ' rcx ', then DEBUG will display only the contents 
 of that register followed by a line with a colon symbol (:) on which you can 
 enter a hex number to change the contents of that register. If you simply 
 press the ENTER key, the contents remain the same. For example:<br>
<br>
<font face="Courier New, Courier, monospace">&nbsp; &nbsp; -<b class="bl">rcx</b>
<br>&nbsp; &nbsp; CX 0100<br>&nbsp; &nbsp; :<b class="bl">273</b><br>
&nbsp; &nbsp; -</font><br><br>means the Register command was used to
 change the contents of the CX register from 0100 to 0273. The command <b><font
 face="Courier New, Courier, monospace">rcx</font></b> could also be used again
 to verify the change had indeed taken place.<br>
<br>NOTE: The register command only functions with 16-bit registers; including
 the Flags register, so entering an 8-bit or an invalid register name results in:
 &nbsp; <font face="Courier New, Courier, monospace">br Error</font>.<br>
<br>
 Typing the letter <b>f</b> (for Flags) after the r: <font face="Courier New, Courier,
 monospace"><b>rf</b></font>, causes DEBUG to display all the FLAG register bits and
 its 'prompt' on the same line. This prompt allows you to change all, or none, of the
 individual flag bits. For example, here's how you would display the flags and change
 only the Zero and Carry flag bits from being <b>cleared</b> (a <b>0</b> bit) to being
 <b>set</b> (a <b>1</b> bit) and check them without making any further changes:<br>
<br>
<font face="Courier New, Courier, monospace">&nbsp; &nbsp;-<b class="bl">rf</b><br>&nbsp;
 &nbsp;NV UP EI PL NZ NA PO NC &nbsp;-<b class="bl">zr cy</b><br>&nbsp; &nbsp;-<b
 class="bl">rf</b><br>&nbsp; &nbsp;NV UP EI PL <b>ZR</b> NA PO <b>CY</b> &nbsp;-<br>&nbsp;
 &nbsp;-</font><BR>
 As you can see above the Zero and Carry flags were changed from NZ and NC (both cleared)
 to ZR and CY (both set). See our Appendix: <a href="../../asm/debug/8086REGs.htm#FLAGS"
 target=REGS>The FLAGS Register</a> for an explanation of all the Flag abbreviations.<BR>
<BR>
 Any order, with or without spaces, is acceptable after the 'prompt' (such as: <font
 face="Courier New, Courier, monospace">-<b>zrupcy</b></font>).
<UL><LI>Attempting to enter an incorrect abbreviation for a flag value (even with one or
 more correct names) results in a: &nbsp; <font face="Courier New, Courier, monospace">bf
 Error</font> &nbsp;and no flags are changed.</LI>
<LI>Attempting to enter abbreviations for both clearing and setting the same flag,
 at the same prompt, will cause DEBUG to display the: &nbsp;<font face="Courier New,
 Courier, monospace">df Error</font>.</font></LI></UL>
<PRE><b><a href="#TOC">Back to TOC</a>

<HR><A NAME=T></A>
<font size="5"><font color="blue">   Trace:</font>  T  [=address]  [number]
</font></b></PRE>
<font face="Arial" size="4">&nbsp; &nbsp; The T command is 
used to trace (step through) CPU instructions one at a time. If you enter 
the T command  by itself, it will <i>normally </i>step through only ONE instruction 
beginning at the location specified by your CS:IP registers, halt program 
execution and then display all the CPU registers plus an unassembled version 
of the next instruction to be executed; this is the 'default' mode of the 
TRACE command. Say, however, you wanted DEBUG to trace and execute seven 
instructions beginning at address CS:0205; to do so, you would enter:<br>
<br>
<FONT face="Courier"> &nbsp; &nbsp; -<b>t =205 7</b></font><br><br>
Remember that the value for the number of instructions to execute must be 
given in hexadecimal just as all other values used in DEUBG. (Since the T 
command uses the &quot;hardware trace mode&quot; of the CPU, it's possible 
to step through instructions in a ROM - Read Only Memory - chip; or step into 
<b>BIOS</b> code which has been  <i>shadowed </i>in read-only portions of Memory 
for decades now.) <b>NOTE:</b> If you find yourself stuck inside a long LOOP or 
REPeat string instruction, enter a <a href="#P">P (Proceed) command</a> and it 
will complete the operation and move to the next instruction.</font>
<PRE><b>

<a href="#TOC">Back to TOC</a>

<HR><A NAME=P></A>
<font size="5"><font color="blue"> Proceed:</font>  P  [=address]  [number]
</font></b></PRE>
<font face="Arial" size="4">&nbsp; &nbsp; <i>Proceed</i> 
acts exactly the same as Debug's <a href="#T">T (Trace) command</a> for <i>most </i>instruction types; with these <b>notable</b> <b><i>exceptions: </i></b>&nbsp;Proceed will immediately execute <b>all 
 instructions</b> (rather than stepping through each one) <b>inside any 
</b>subroutine <b>CALL</b>,  <b>LOOP</b>,  <b>REP</b>eat string instruction or any software 
<b>INT</b>errupt. You can still step into an INT or execute all the code contained in a subroutine if you need to, but   with the <i>Proceed </i>(<b>P</b>) 
command you are  <b>not </b>required to do so.<BR>
&nbsp; &nbsp; This means <i>Proceed</i>  &nbsp;will probably be the command of choice for most of  debugging tasks, with Trace  only being used to step through an unfamiliar
subroutine or  check the logic of the first few iterations of long REP string instructions or LOOPs. And it's a must use command when it comes to Interrupts! </font>
<PRE><b><a href="#TOC">Back to TOC</a>

<HR><A NAME=W></A>
<font size="5"><font color="red">Write:</font>
W [address] [drive] [firstsector] [number]</font></b></PRE>

<center><table border="1" width="97%" bgcolor="pink"><tr><td>
<table border="0"><tr><td width="10">&nbsp;</td><td>
<center><font face="Comic Sans MS" size="6">W A R N I N G</font></center>
<font face="Arial" size="4">Do NOT <i>experiment</i> with the <b>W - 
write</b> command in DEBUG. It can be used effectively to create new files 
on your hard drive, but only if you use it properly. Trying to write 
directly to a sector on a hard disk would very RARELY be considered proper 
use of this command!</font></td></tr></table></td></tr></table></center>
<UL>
<font face="Arial" color="red" size="5">Trying to write directly to a hard 
disk using sector numbers will most likely result in loss of data or even 
a non-booting system!</font> <font face="Arial" size="4">(Although Windows XP and 
later prevent direct <i>Sector writes </i>to a hard disk, they are  still allowed  to floppy drive media, i.e., drive letters <b>A:</b> or <b>B:</b>)</font>
</UL>
<font face="Arial" size="4"> &nbsp; &nbsp; The WRITE (W) command is often used 
to save a program to your hard disk from within DEBUG. But the only safe way to 
do so, especially under Windows, is by allowing the OS to decide where to physically 
create that file on the disk. This is done by first using the <a href="#N">Name 
(N) command</a> to set up an <i>optional path</i> and <b>filename</b> for the 
new file (or to overwrite one that already exists). DEBUG will automatically begin 
saving program or data bytes from <font face="Verdana"><b>Offset 0100</b></font> 
of the 64 KiB Segment  the OS allocated for it. The only other requirement 
is to set the size of the file you wish to write by placing the total number of 
bytes in the<a name="bxbk"></a> <b>combined <font face="Verdana">BX</font></b> 
and <b><font 
face="Verdana">CX</font> registers<a href="#bxcx"><font size="5" face="Verdana" color=red>*</font></a></b> 
before executing the WRITE command. The <a href="#R">Register command</a> is used 
to change the value in <b>the CX register</b> in the following example from our 
 <a 
href="../../asm/mbr/MYMBR.ZIP">MyMBR Batch/Debug Script Program</a>.<br>
<br>
<b>EXAMPLE:</b><br>
After creating and running a small program inside of DEBUG which copies the Master 
Boot Record (<b>MBR</b>) to Offset <b>0000</b>h through <b>01FF</b>h, these DEBUG 
commands save the MBR to a file on the hard disk: 
<PRE><font size="4">   -<b>n mymbr.bin</b>
   -<b>rcx</b>
   CX 0001
   :<b>200</b>
   -<b>w 0</b>
   Writing 00200 bytes   <font face="Georgia">[ 512 bytes in decimal ]</font>
   -
</font></PRE></FONT>
<p><font face="Arial" size="4"> <font face="Arial" size="4">The BX register had 
  already been set to zero by a previous instruction, so the CX register was simply 
  set to 200 and the WRITE command executed with <b>an address of 0</b> (if no 
  address is used, the Write command starts saving bytes at <b>Offset 100</b>).<br>
  <br>
  The WRITE command <i>can</i>, however, be used in a <i>relatively safe</i> manner 
  with Floppy disks. For example, you could use the <a href="#L">Load (L) command</a>:<br>
  <font face="Courier New"> &nbsp; &nbsp; <b>l 7c00 0 0 1</b></font><br>
  to load the first sector of an MS-DOS or Windows floppy disk into DEBUG's memory 
  at location 7C00, change some of the code and/or messages (if you know how to 
  do so) and then use the 'W' command:<br>
  <font face="Courier New"> &nbsp; &nbsp; <b>w 7c00 0 0 1</b></font><br>
to write the changes back to the floppy disk's first sector.</font></FONT></p>
<p><font face="Arial" size="4">___________________<br>
  <a name="bxcx"></a><b><font size="5" color="#FF0000" face="Verdana">*</font></b><font face="Times">Although
  the BX and CX registers are often referenced in books on Assembly as <font face="Verdana"><b>BX:CX</b>
  </font> when they discuss this <B>write</b> command, <b>note</b>  that these registers are <b>not</b> being
  used like Segment:Offset pairs in this case! They are a true combination of higher and lower bytes which
  form a 'double word' for a <b><i>theoretical total</i></b> of about <b>4 GB</b> (<b>FFFF FFFF</b>h
  = 4,294,967,295 bytes) that could be written to a file! Whether or not this is true of all versions of
  DEBUG, under <b>DOS 7.1</b>, we've been able to load image files of several hundred KiB and write the whole file
  to a new location!<BR>
  &nbsp; &nbsp; For example, if you load a <b>360 KiB</b>  image file into DEBUG at a DOS prompt, then check the
  registers, <font face="Verdana"><b>BX</b></font> will equal <font face="Verdana"><b>0005</b></font> and
  <font face="Verdana"><b>CX</b></font> will contain <font face="Verdana"><b>A000</b></font>. <font 
  face="Verdana">The major problem here though is the fact DEBUG uses</font> <b>CONVENTIONAL MEMORY</b>,
  so trying to load a file <font face="Verdana">greater than about 400 KiB is bound to elicit an
  &quot;<b>Insufficient Memory</b>&quot; error<b>!</b></font><br>
  <b>[</b> </font></FONT><b><a href="#bxbk">click here to go back to text above</a></b> 
  <font size="4" face="Times"><b>]</b></font><br>
  <br>
  <font size="4"><a href="#TOC">Back to TOC</a></font> <BR>
  <BR>
</p>
<p>&nbsp; </p>
<table border="1" width="97%" bgcolor="#CCFFCC">
  <tr> 
    <td> 
      <table border="0">
        <tr> 
          <td width="10">&nbsp;</td>
          <td>
            <center>
              <font face="Comic Sans MS" size="6">N O T E :</font>
            </center>
            <font face="Arial" size="4">You may have missed this page on: <a href="DOSstub.htm" target="stub">The 
            Windows&#153; DOS <i>Stub</i> Program</a>. And there are  more examples of many DEBUG <i>commands</i> on these <b>x86</b> 
            tutorial pages:<br>
            <a href="../fire/Fire.html" target="fire">FIRE.com: Some MS-DEBUG 
            Tricks</a> and <a href="../eicar/eicarcom.html" target="ei">The EICAR 
            Standard AV Test Program</a> .<br>
            </font></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<p>&nbsp; </p>
<HR><BR><BR><BR>
<font face="Verdana" size="5"><small><i>Updated:</i> <b>September 28, 2007</b>. (28.09.2007)<br>
<i>Previous Update:</i>  <b>August 23, 2010</b>. (23.08.2010)</small><br>
<i>Last Update:</i> <b>September 19, 2010</b>. (19.09.2010)</font>
<HR><center><BR>
  <img src="../../img/left.gif" width=33 height=14> <a href="debug.htm"><b><font size="6"> 
  A Guide to DEBUG (Page One)</font></b></a><BR>
  <BR><img src="../../img/left.gif" width=33 height=14> 
<a href="../../asm/index.html"><b><font size="6">The Starman's Realm Assembly 
Page</font></b></a></center><BR><BR><BR><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>
</body></html>