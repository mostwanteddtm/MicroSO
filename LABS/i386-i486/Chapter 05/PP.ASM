.386p

INCLUDE ..\STRUCT.INC
INCLUDE ..\MACRO1.INC
INCLUDE ..\MACRO2.INC

; STEP 0: DEFINE EQU

	INTNO			EQU		21							; INTERRUPT VECTOR NUMBER
	DSCPSIZE		EQU 	08h							; SIZE OF DESCRIPTOR
	INTSIZE			EQU		04h							; SIZE OF INTERRUPT SERVICE ROUTINE
	TWO				EQU		02h
	PROT_ENABLE		EQU		01h							; PROTECTED MODE ENABLE BIT IN CR0
	ATTRIBUTE		EQU		07h							; DISPLAY CHARACTER ATTRIBUTE
	SPACE			EQU		20h							; ASCII CODE FOR SPACE
	
; STEP 0.1: DEFINE MORE EQU

	PG_ENABLE		EQU		80000000h					; CR0 PAGE ENABLE BIT
	PG_PRESENT		EQU		01h							; PAGE PRESENT BIT
	PDBR_OFFSET		EQU		1000h						; 4K
	PTE_MASK		EQU		07h							; USER LEVEL, READ, WRITE, AND
														; PAGE PRESENT
	READ_ONLY		EQU		0FFFFFFFDh					; READ ONLY
	
STACK SEGMENT STACK USE16
	DB 100 DUP(0)
STACK ENDS

; STEP 1: GLOBAL DESCRIPTOR TABLE

GDT SEGMENT PARA PUBLIC 'GDT' USE16
	
	GDT_TAB			LABEL 	QWORD
		
	NULL_SELEC		EQU		$-GDT_TAB					; NULL SELECTOR
	DSCP			<,,,,,>								; FIRST ONE MUST BE A NULL DESCPRIPTOR
	
	CODE_SELEC		EQU		$-GDT_TAB					; CODE SELECTOR
	DSCP			<0FFFFh,,,09Ah,,>					; DESCRIPTOR
	
	TASK0_TSS_SELEC EQU		$-GDT_TAB					; TSS SEGMENT SELECTOR
	DSCP 			<TASK0_TSS_LIMIT,,,089h,,>			; DESCRIPTOR
	
	STK0_SELEC		EQU		$-GDT_TAB					; LEVEL 0 STACK SEGMENT
														; SELECTOR
	DSCP			<STK0_LIMIT,,,92h,,>				; DESCRIPTOR WITH
														; PRIVILEGE LEVEL 0
	STK1_SELEC		EQU		$-GDT_TAB OR 1				; LEVEL 1 STACK
														; SEGMENT SELECTOR
	DSCP			<STK1_LIMIT,,,0B2h,,>				; DESCRIPTOR WITH
														; PRIVILEGE LEVEL 1
	STK2_SELEC		EQU		$-GDT_TAB OR 2				; LEVEL 2 STACK
														; SEGMENT SELECTOR
	DSCP			<STK2_LIMIT,,,0D2h,,>				; DESCRIPTOR WITH
														; PRIVILEGE LEVEL 2
	DMY_SELEC		EQU		$-GDT_TAB					; DUMMY SEGMENT SELECTOR
	DSCP			<0FFFFh,,,92h,,>					; DESCRIPTOR
	
	VIDEO_SELEC		EQU		$-GDT_TAB OR 3				; VIDEO SEGMENT SELECTOR
	DSCP			<0FFFFh,8000h,0Bh,0F2h,,>			; DESCRIPTOR
	
	GDATA_SELEC		EQU		$-GDT_TAB					; DATA SEGMENT SELECTOR
	DSCP			<GDATA_LIMIT,0000H,00H,0F2H,,>		; DESCRIPTOR
	
	INT_SELEC		EQU		$-GDT_TAB					; INTERRUPT SEGMENT
														; SELECTOR
	DSCP			<0FFFFh,,,09Ah,,>					; DESCRIPTOR
	
; STEP 1.1: DEFINE SELECT BYOUND GDT_LIMIT
	
	PAGE_SELEC		EQU		$-GDT_TAB					; SELECTOR FOR ESPECIFIC PAGE
	DSCP			<0FFFFh,0h,09h,0F2h,,>				; PAGE 90h, OFFSET 0h
	
	CODE3_SELEC		EQU		$-GDT_TAB OR 3				; LEVEL 3 CODE SEGMENT
														; SELECTOR (RPL = 3)
	DSCP			<0FFFFh,,,0FAh,,>					; CODE SEGMENT DESCRIPTOR
														; (DPL = 3)
														
	STK3_SELEC		EQU		$-GDT_TAB OR 3				; LEVEL 3 STACK
														; SEGMENT SELECTOR
	DSCP			<STK3_LIMIT,,,0F2h,,>				; DESCRIPTOR WITH
														; PRIVILEGE LEVEL 3
	GDT_LIMIT		EQU		$-GDT_TAB
		
GDT ENDS

; STEP 2: INTERRUPT DESCRIPTOR TABLE

IDT	SEGMENT PARA PUBLIC 'IDT' USE16
	
	IDT_TAB			EQU		$
	REPT			INTNO								; 21 INTERRUPT ENTRIES
	DSCP			<,INT_SELEC,0,0EEh,,>				; DPL = 3
	ENDM
	IDT_LIMIT		EQU		$
	
IDT ENDS

; DATA SEGMENT

GDATA SEGMENT PARA PUBLIC 'GDATA' USE16

; STEP 3: VARIABLE TO SAVE GDT / IDT LIMIT AND LINEAR ADDRESS

	PGDT			LABEL	FWORD
	PGDT_LIMIT		DW		?							; GDT LIMIT
	PGDT_ADDR		DD		?							; GDT BASE ADDRESS
	
	PIDT			LABEL	FWORD
	PIDT_LIMIT		DW		?							; IDT LIMIT
	PIDT_ADDR		DD		?							; IDT BASE ADDRES
	
	POLD			LABEL	FWORD
	DIDT_LIMIT		DW		03FFh						; DOS IDT LIMIT
	DIDT_ADDR		DD		0							; DOS IDT BASE ADDRESS
	
; STEP 4: TABLE TO DEFINE THE MAPPING OF DESCRIPTOR TO SEGMENT

	GDT_PHYS_TAB	LABEL	WORD
					DW		TASK0_TSS_SELEC				; TSS SEGMENT SELECTOR
					DW		TASK0_TSS					; TSS SEGMENT ADDRESS
					DW		STK0_SELEC					; STK0 SEGMENT SELECTOR
					DW		STK0						; STK0 SEGMENT ADDRESS
					DW		STK1_SELEC					; STK1 SEGMENT SELECTOR
					DW		STK1						; STK1 SEGMENT ADDRESS
					DW		STK2_SELEC					; STK2 SEGMENT SELECTOR
					DW		STK2						; STK2 SEGMENT ADDRESS
					DW		DMY_SELEC					; DUMMY SEGMENT SELECTOR
					DW		DMY							; DUMMY SEGMENT ADDRESS
					DW		CODE_SELEC					; CODE SEGMENT SELECTOR
					DW		CODE						; CODE SEGMENT ADDRESS
					DW		GDATA_SELEC					; DATA SEGMENT SELECTOR
					DW		GDATA						; DATA SEGMENT ADDRESS
					DW 		INT_SELEC					; INTERRUPT SEGMENT SELECTOR
					DW		CODE						; CODE SEGMENT ADDRESS
					
; STEP 4.1: SELECTOR FOR LEVEL 3 CODE AND STACK SEGMENT

					DW		CODE3_SELEC					; CODE SEGMENT SELECTOR
					DW		CODE						; CODE SEGMENT
					DW		STK3_SELEC					; STK3 SEGMENT SELECTOR
					DW		STK3						; STK3 SEGMENT
	
	GDT_TAB_SIZE	EQU		($ - GDT_PHYS_TAB) / 4		; ENTRY NUMBERS IN
														; ABOVE TABLE
														
; STEP 5: MESSAGE DEFINITION AREA

	IN_PROTECTED	DB		'IN PROTECTED MODE ', 0
	INT_MSG			DB		'INTERRUPT   h', 0
	INT_NUM			DB 		0Eh	
	LEVEL_MSG		DB		'Change to user level ', 0

; STEP 5.1: PAGING WORKING AREA

	PDBR			DD		?							; PAGE DIRECTORY LINEAR ADDRES
					
	GDATA_LIMIT		EQU		$
	
GDATA ENDS

; STEP 6: STACK SEGMENT FOR PRIVILEGE LEVEL 0, 1, 2

STK0 SEGMENT PARA PUBLIC 'STK0' USE16
					DB		100h DUP(0)
	STK0_LIMIT		EQU		$
STK0 ENDS

STK1 SEGMENT PARA PUBLIC 'STK1' USE16
					DB		100h DUP(0)
	STK1_LIMIT		EQU		$
STK1 ENDS

STK2 SEGMENT PARA PUBLIC 'STK2' USE16
					DB		100h DUP(0)
	STK2_LIMIT		EQU		$
STK2 ENDS

; STEP 6.1 STACK SEGMENT FOR PRIVILEGE LEVEL 3

STK3 SEGMENT PARA PUBLIC 'STK3' USE16
					DB		100h DUP(0)
	STK3_LIMIT		EQU		$
STK3 ENDS

; STEP 7: TASK STATE SEGMENT

TASK0_TSS SEGMENT PARA PUBLIC 'TASK0' USE16

	TSS_STACK		STK0_SELEC, STK0_LIMIT, STK1_SELEC, STK1_LIMIT, STK2_SELEC, STK2_LIMIT
					
	TSS_CR3												; CR3
	
	TSS_REGS		0, 0, 0, 0, 0, 0, 0, 0, 0, STK0_LIMIT
	TSS_SEG			GDATA_SELEC, CODE_SELEC, STK0_SELEC, GDATA_SELEC, GDATA_SELEC, GDATA_SELEC
					
					DD		0							; LDT FIELD
					DW		0							; TASK TRAP FLAG
					DW		68h							; I/O BASE
					
	TASK0_TSS_LIMIT	EQU		$
	
TASK0_TSS ENDS

; STEP 8: DUMMY SEGMENT

DMY SEGMENT PARA PUBLIC 'DMY' USE16
	DB		128 DUP(0)
DMY ENDS

; STEP 8.1: PAGE SEGMENT

PAGETBL SEGMENT PARA PUBLIC 'PAGETBL' USE16

; STEP 8.2: RESERVE 4K AREA TO ADJUST PAGE TABLE ADDRESS

	DB 		4096 DUP(0)

; STEP 8.3: DEFINE PAGE TABLE ENTRY

	TMP_PTBL	LABEL BYTE
	REPT		256
	DD			(($-TMP_PTBL) / 4 * 1000h + PTE_MASK)
	ENDM
	
; STEP 8.4: PAGE TABLE SIZE

	PAGE_TBL_SIZE	EQU ($-TMP_PTBL) / 4
	
; STEP 8.5: PAGE DIRECTORY	
	
	ORG			TMP_PTBL+PDBR_OFFSET					; 2000h
	DD			?										; FIRST ENTRY FOR PAGE DIRECTORY
	
; STEP 8.6: WORKING AREA TO SAVE PAGE TABLE ADDRESS

	PTBL_ADDR	DW ?
	PAGE_LIMIT	EQU $

PAGETBL ENDS

CODE SEGMENT PARA PUBLIC 'CODE' USE16
	ASSUME CS:CODE, DS:GDATA
	
		MAIN PROC FAR
		
			MOV		AX, GDATA							; GET GDATA SEGMENT ADDRESS
			MOV		DS, AX								; PUT IN DS
			
; STEP 9: INITIALIZE IDT

			MOV		AX, IDT								; GET IDT SEGMENT ADDRESS
			MOV		ES, AX								; PUT IN ES
			MOV		DI, OFFSET IDT_TAB					; GET IDT OFFSET ADDRESS
			MOV		AX, OFFSET INT_ENTRY				; GET INTERRUPT SERVICE
														; ROUTINE ADDRESS
			MOV		CX, INTNO							; GET INTERRUPT NUMBER
		FILLIDT:
			MOV		ES:[DI], AX							; PUT ENTRY ADDRESS IN IDT
			ADD		DI, DSCPSIZE						; ADJUST ADDRESS IN IDT
			ADD		AX, INTSIZE							; ADJUST INTERRUPT SERVICE
														; ROUTINE ADDRESS, THE SIZE OF EACH
														; ROUTINE IS DEFINED IN INTSIZE
			LOOP	FILLIDT								; KEEP FILLING
			
; STEP 9.1: SET PAGE TABLE AND PDBR

			CALL	SETUP_PGTBL							; CALL PROCEDURE TO SETUP
														; PAGE TABLE
														
; STEP 9.2: SET PDBR

			MOV		EAX, PDBR							; GET PAGE DIRECTORY TABLE
														; LINEAR ADDRESS
			MOV		CR3, EAX							; STORE IN CR3

; STEP 10, 11, 12, 13: SET LINEAR ADDRESS FOR DESCRIPTOR IN GDT,
;		GDTR, IDTR AND LDTR THEN SWITCH TO PROTECTED MODE

			BUILD_DTR	GDT, IDT, PGDT, PIDT, GDT_LIMIT, IDT_LIMIT
			BUILD_DT	GDT, GDT_PHYS_TAB, GDT_TAB_SIZE
			CLI
			GOTO_PROT		PGDT, PIDT, CODE_SELEC, STK0_SELEC, STK0_LIMIT, GDATA_SELEC
			
; STEP: 14 DISPLAY MESSAGE IN PROTECTED MODE
														; CLEAR SCREEN FIRST
			MOV		AX, VIDEO_SELEC						; GET VIDEO SEGMENT SELECTOR
			MOV		ES, AX								; PUT IN ES
			MOV		CX, 4000h							; SCREEN SIZE
			XOR		DI, DI								; SCREEN STARTING ADDRESS
			MOV		AH, ATTRIBUTE
			MOV		AL, SPACE							; FILL SPACE AND ATTRIBUTE
			REP		STOSW								; FILL IT
			MOV		SI, OFFSET IN_PROTECTED				; GET PROTECTED MODE
														; MESSAGE ADDRESS
			MOV		DI, 320								; GET DISPLAY ADDRESS
			CALL	DISP_IT								; CALL DISPLAY PROCEDURE
			
; STEP 15: LOAD TSS TO TR

			MOV		AX, TASK0_TSS_SELEC					; GET TSS SELECTOR FOR
														; CURRENT TASK
			LTR		AX									; LOAD INTO TASK REGISTER
			
; STEP 15.1: ENABLE MEMORY PAGING

			MOV		EAX, CR0							; LOAD THE CONTENT OF CR0
			OR		EAX, PG_ENABLE						; ENABLE MEMORY PAGING
			MOV		CR0, EAX							; RESTORE THE CONTENT OF CR0

; STEP 15.2: CHANGE CURRENT TASK TO LEVEL 3 (USER LEVEL)

			MOV		AX, STK3_SELEC						; GET SS WITH LEVEL 3
			PUSH	AX									; PUSH SS
			MOV		AX, OFFSET STK3_LIMIT				; GET SP WITH LEVEL 3
			PUSH	AX									; PUSH SP
			MOV		AX, CODE3_SELEC						; GET CS WITH LEVEL 3
			PUSH	AX									; PUSH CS
			MOV		AX, OFFSET LEVEL					; GET EIP
			PUSH	AX									; PUSH EIP
			RETF										; RETURN FAR
			
; STEP 15.3 DISPLAY CHANGE LEVEL MESSAGE 

		LEVEL:
			MOV		SI, OFFSET LEVEL_MSG				; GET DISPLAY MESSAGE
			MOV		DI, 5 * 160							; GET DISPLAY POSITION
			CALL	DISP_IT								; DISPLAY IT

; STEP 15.4: WRITE DATA TO PAGE READ ONLY

			MOV		AX, PAGE_SELEC						; GET THE ESPECIFIC PAGE SELECTOR
			MOV		ES, AX								; PUT IN ES REGISTER
			MOV		AX, WORD PTR ES:[0100h]				; ACCESS ONE WORD FROM
														; THIS PAGE

														; STEP 16: SWITCH BACK TO REAL MODE ADDRESS
			JMP		GO_EXIT

; STEP 17: INTERRUPT SERVICE ROUTINE

		INT_ENTRY:										; ENTRY POITN FOR
														; INTERRUPT SERVICE ROUTINE
			REPT	INTNO
			CALL	DISP								; CALL THE DISPLAY MESSAGE
			IRET										; PROCEDURE
			ENDM
			
; STEP 18: GET INTERRUPT NUMBER AND DISPLAY IT

		DISP:
			MOV		BX, GDATA_SELEC						; RELOAD DATA SEGMENT
			MOV		DS, BX
			
			MOV		AL, INT_NUM							; GET OFFSET FROM THE

			XOR		ESI, ESI							; ESTA LINHA EU INCLUI, PARA GARANTIR O ENDERECO DA INTERRUPCAO
			MOV		SI, OFFSET INT_MSG[10]				; GET ASCII CODE ADDRESS
			MOV		CX, TWO								; CONVERT TO 2 ASCII CODE
			CALL	HTOA								; CALL CONVERT PROCEDURE
			MOV		SI, OFFSET INT_MSG					; GET INTERRUPT MESSAGE
			
			MOV		DI, 3 * 160
			
			CALL	DISP_IT								; CALL DISPLAY PROCEDURE
			
; STEP 18.1: DISABLE MEMORY PAGING

			MOV		EAX, CR0							; LOAD THE CONTENT OF CR0
			AND		EAX, NOT PG_ENABLE					; DISABLE MEMORY PAGING
			MOV		CR0, EAX							; RESTORE THE CONTENT OF CR0
			
; STEP 19: RETURN TO REAL MODE ADDRESS

		GO_EXIT:
			CLI											; DISABLE INTERRUPT
			MOV		AX, DMY_SELEC						; DUMMY SELECTOR
			MOV		ES, AX
			MOV		DS, AX
			MOV		FS, AX
			MOV		GS, AX
			MOV		SS, AX
			MOV		EAX, CR0							; LOAD THE CONTENT OF CR0
			AND		EAX, NOT PROT_ENABLE				; DISABLE PROTECTED MODE
			MOV		CR0, EAX							; RESTORE THE CONTETENT OF
														; CR0
			DB		0EAh								; FAR JUMP FLUSH
														; INSTRUCTION QUEUE
			DW		OFFSET NEXT_INSTRUCTION				; NEW EIP
			DW		CODE								; NEW CS
			
; STEP 20: EXECUTE IN REAL MODE ADDRESE, SET DS, SS, AND SP

		NEXT_INSTRUCTION:
			MOV		AX, GDATA							; GET DATA SEGMENT ADDRESS
			MOV		DS, AX								; PUT IN DS
			MOV		AX, STK0							; GET STACK SEGMENT ADDRESS
			MOV		SS, AX								; PUT IN SS
			MOV		SP, OFFSET STK0_LIMIT				; SET STACK POINTER
			
; SETP 21: SET IDTR TO DOS INTERRUPT TABLE
			LIDT	[POLD]								; LOAD DOS INTERRUPT VECTOR
														; TABLE TO IDTR REGISTER
			STI											; ENABLE INTERRUPT
			
; STEP 22: TERMINATE THIS PROCESS

			MOV		AX, 4C00H							; TERMINATE PROCESS
			INT		21H									; DOS FUNCTION CALL
		
		MAIN ENDP
		
	; PROCEDURE: DISP_IT
	; DISPLAY STRING IN PROTECTED MODE
	; INPUT DS:SI - STRING ADDRESS, THE END OF THE STRING MUST BE 0
	
		DISP_IT PROC NEAR
			
			MOV		AX, VIDEO_SELEC						; GET VIDEO SEGMENT SELECTOR
			MOV		ES, AX								; PUT IN ES
			MOV		AH, ATTRIBUTE						; DISPLAY ATTRIBUTE
			
		DISP_IT1:
			LODSB										; GET DISPLAY CHARACTER
			STOSW										; PUT IT ON SCREEN
			CMP		AL, 0								; END OF DISPLAY CHARACTER ?
			JNE		DISP_IT1							; NO CONTINUE
			RET											; YES RETURN
			
		DISP_IT ENDP
		
	; PROCEDURE: HTOA
	; CONVERT HEXADECIMAL CODE TO ASCII CODE
	; INPUT: SI- ADDRESS TO PUT ASCII CODE, CX- HEXADECIMAL
	; CODE SIZE, EAX- HEXADECIMAL CODE
	
	HTOA_TAB		DB '0123456789ABCDEF'
		
		HTOA PROC NEAR
		
			XOR		EBX, EBX							; CLEAR EBX
			ADD		SI, CX								; ADJUST TARGET ADDRESS
			DEC		SI
			
		HTOA1:
			MOV		BL, AL								; GET HEXADECIMAL CODE
			AND		BL, 0Fh								; DISTINGUISH IT
			MOV		BL, CS:[HTOA_TAB][EBX]				; GET INDEXED ASCII
														; CHARACTER
			MOV		BYTE PTR [ESI], BL					; PLACE IN TARGET ADDRESS
			DEC		ESI									; ADJUST TARGET ADDRESS
			SHR		EAX, 4								; GET RID OF IT
			LOOP	HTOA1								; CONTINUE
			RET											; RETURN
	HTOA ENDP
	
	; PROCEDURE: SETUP_PGTBL
	; ALIGN THE PREDEFINED PAGE TABLE TO BOUNDARY. SET THE
	; FIRST ENTRY OF PAGE DIRECTORY TABLE TO THIS ALIGNED PAGE
	; TABLE. THEN PAGE DIRECTORY TABLE WILL BE SET BELOW THE PAGE
	; TABLE.
	
	SETUP_PGTBL PROC NEAR
	
			PUSH	DS									; SAVE DS
			PUSH	ES									; SAVE ES
			ASSUME	DS:PAGETBL
			MOV		AX, PAGETBL							; GET PAGE TABLE SEGMENT ADDRESS
			MOV		DS, AX								; PUT IN DS
			MOV		ES, AX								; PUT IN ES
			MOV		CX, PAGE_TBL_SIZE					; GET PAGE TABLE SIZE
			MOV		BX, AX								; BX HAS PAGE TABLE SEGMENT
														; ADDRESS
			AND		BX, 00FFh							; BX IS IN 4K RANGE (SEGMENT)
			XOR 	EDI, EDI							; CLEAR EDI 
			MOV		DI, 100h							; DI AS 4K SIZE (SEGMENT)
			SUB		DI, BX								; ADDRESS FOR 4K BOUNDARY, ALSO
														; PAGE TABLE ADDRESS
			SHL		DI, 4								; CONVERT TO OFFSET
			MOV		PTBL_ADDR, DI						; SAVE PAGE TABLE ADDRESS
			PUSH	DI									; SAVE IT
			MOV		SI, OFFSET TMP_PTBL					; GET PREDEFINED PAGE 
														; TABLE ADDRESS
			REP		MOVSD								; MOVE IT TO THE PAGE BOUNDARY
														; ADDRESS
			POP		DI									; RESTORE DI
		; SET PDBR & PDIR
			XOR		EBX, EBX							; CLEAR EBX
			MOV		BX, AX								; GET PAGE TABLE SEGMENT ADDRESS
			SHL		EBX, 4								; CONVERT TO 20-BIT ADDRESS
			ADD 	EBX, EDI							; PAGE TABLE LINEAR ADDRESS
			OR		BL, PTE_MASK						; USER LEVEL, READ-WRITE, PRESENT
			MOV		DWORD PTR [DI].PDBR_OFFSET, EBX		; PUT IN FIRST
														; ENTRY IN PAGE DIRECTORY TABLE
			ADD		EBX, OFFSET PDBR_OFFSET				; PAGE DIRECTORY BASE
														; ADDRESS
			PUSH	DS
			ASSUME	DS:GDATA
			MOV		AX, GDATA							; GET DATA SEGMENT
			MOV		DS, AX								; PUT IN DS
			AND		EBX, 0FFFFF000h						; PDBR
			MOV		PDBR, EBX							; SAVE PAGE DIRECTORY ADDRESS
			POP		DS
			ASSUME	DS:PAGETBL
			MOV		BX, PTBL_ADDR						; GET PAGE TABLE ADDRESS
			ADD		BX, 90h SHL 2 						; GET ENTRY 90h (1 ENTRY HAS 4
														; BYTES)
			AND		[BX][PG_STAT], NOT PG_PRESENT		; SET PAGE 90h
														; NOT PRESENT
			POP		ES									; RESTORE ES
			POP		DS									; RESTORE DS
			RET
			
SETUP_PGTBL ENDP
			
CODE ENDS

END MAIN
