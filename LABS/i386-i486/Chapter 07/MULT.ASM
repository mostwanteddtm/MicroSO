.386p

INCLUDE ..\STRUCT.INC
INCLUDE ..\MACRO1.INC
INCLUDE ..\MACRO2.INC

; STEP 0: DEFINE EQU

	INTNO			EQU		21							; INTERRUPT VECTOR NUMBER
	DSCPSIZE		EQU 	08h							; SIZE OF DESCRIPTOR
	INTSIZE			EQU		04h							; SIZE OF INTERRUPT SERVICE ROUTINE
	TWO				EQU		02h
	PROT_ENABLE		EQU		01h							; PROTECTED MODE ENABLE BIT IN CR0
	ATTRIBUTE		EQU		07h							; DISPLAY CHARACTER ATTRIBUTE
	SPACE			EQU		20h							; ASCII CODE FOR SPACE
	
STACK SEGMENT STACK USE16
	DB 100 DUP(0)
STACK ENDS

; STEP 1: GLOBAL DESCRIPTOR TABLE

GDT SEGMENT PARA PUBLIC 'GDT' USE16
	
	GDT_TAB			LABEL 	QWORD
		
	NULL_SELEC		EQU		$-GDT_TAB					; NULL SELECTOR
	DSCP			<,,,,,>								; FIRST ONE MUST BE A NULL DESCPRIPTOR
	
	CODE_SELEC		EQU		$-GDT_TAB					; CODE SELECTOR
	DSCP			<0FFFFh,,,09Ah,,>					; DESCRIPTOR
	
	TASK0_TSS_SELEC EQU		$-GDT_TAB					; TSS SEGMENT SELECTOR
	DSCP 			<TASK0_TSS_LIMIT,,,089h,,>			; DESCRIPTOR
	
	STK0_SELEC		EQU		$-GDT_TAB					; LEVEL 0 STACK SEGMENT
														; SELECTOR
	DSCP			<STK0_LIMIT,,,92h,,>				; DESCRIPTOR WITH
														; PRIVILEGE LEVEL 0
	STK1_SELEC		EQU		$-GDT_TAB OR 1				; LEVEL 1 STACK
														; SEGMENT SELECTOR
	DSCP			<STK1_LIMIT,,,0B2h,,>				; DESCRIPTOR WITH
														; PRIVILEGE LEVEL 1
	STK2_SELEC		EQU		$-GDT_TAB OR 2				; LEVEL 2 STACK
														; SEGMENT SELECTOR
	DSCP			<STK2_LIMIT,,,0D2h,,>				; DESCRIPTOR WITH
														; PRIVILEGE LEVEL 2
	DMY_SELEC		EQU		$-GDT_TAB					; DUMMY SEGMENT SELECTOR
	DSCP			<0FFFFh,,,92h,,>					; DESCRIPTOR
	
	VIDEO_SELEC		EQU		$-GDT_TAB OR 3				; VIDEO SEGMENT SELECTOR
	DSCP			<0FFFFh,8000h,0Bh,0F2h,,>			; DESCRIPTOR
	
	GDATA_SELEC		EQU		$-GDT_TAB					; DATA SEGMENT SELECTOR
	DSCP			<GDATA_LIMIT,0000H,00H,0F2H,,>		; DESCRIPTOR
	
	INT_SELEC		EQU		$-GDT_TAB					; INTERRUPT SEGMENT
														; SELECTOR
	DSCP			<0FFFFh,,,09Ah,,>					; DESCRIPTOR
	
; STEP 1.1: TASK 1 SELECTOR AND DESCRIPTOR
	
	TASK1_TSS_SELEC	EQU		$-GDT_TAB OR 1				; LEVEL 1 TSS
														; SELECTOR FOR TASK1
	DSCP			<TASK1_TSS_LIMIT,,,0A9h,,>			; DESCRIPTOR (DPL = 1)
	
	TASK1_CODE_SELEC EQU		$-GDT_TAB OR 1			; LEVEL 1 CODE SEGMENT
														; SEGMENT SELECTOR FOR TASK1
	DSCP			<TASK1_SEG_LIMIT,,,0BAh,,>			; DESCRIPTOR (DPL = 1)
															
	GDT_LIMIT		EQU		$-GDT_TAB
		
GDT ENDS	

; STEP 2: INTERRUPT DESCRIPTOR TABLE

IDT	SEGMENT PARA PUBLIC 'IDT' USE16
	
	IDT_TAB			EQU		$
	REPT			INTNO								; 21 INTERRUPT ENTRIES
	DSCP			<,INT_SELEC,0,0EEh,,>				; DPL = 3
	ENDM

; STEP 2.1: DEFINE TASK GATE IN IDT

	DSCP			<, TASK0_TSS_SELEC, 0, 0E5h,,>		; INTERRUPT 21
														; TASK GATE DESCRIPTOR
	IDT_LIMIT		EQU		$
	
IDT ENDS

; DATA SEGMENT

GDATA SEGMENT PARA PUBLIC 'GDATA' USE16

; STEP 3: VARIABLE TO SAVE GDT / IDT LIMIT AND LINEAR ADDRESS

	PGDT			LABEL	FWORD
	PGDT_LIMIT		DW		?							; GDT LIMIT
	PGDT_ADDR		DD		?							; GDT BASE ADDRESS
	
	PIDT			LABEL	FWORD
	PIDT_LIMIT		DW		?							; IDT LIMIT
	PIDT_ADDR		DD		?							; IDT BASE ADDRES
	
	POLD			LABEL	FWORD
	DIDT_LIMIT		DW		03FFh						; DOS IDT LIMIT
	DIDT_ADDR		DD		0							; DOS IDT BASE ADDRESS
	
; STEP 4: TABLE TO DEFINE THE MAPPING OF DESCRIPTOR TO SEGMENT

	GDT_PHYS_TAB	LABEL	WORD
					DW		TASK0_TSS_SELEC				; TSS SEGMENT SELECTOR
					DW		TASK0_TSS					; TSS SEGMENT ADDRESS
					DW		STK0_SELEC					; STK0 SEGMENT SELECTOR
					DW		STK0						; STK0 SEGMENT ADDRESS
					DW		STK1_SELEC					; STK1 SEGMENT SELECTOR
					DW		STK1						; STK1 SEGMENT ADDRESS
					DW		STK2_SELEC					; STK2 SEGMENT SELECTOR
					DW		STK2						; STK2 SEGMENT ADDRESS
					DW		DMY_SELEC					; DUMMY SEGMENT SELECTOR
					DW		DMY							; DUMMY SEGMENT ADDRESS
					DW		CODE_SELEC					; CODE SEGMENT SELECTOR
					DW		CODE						; CODE SEGMENT ADDRESS
					DW		GDATA_SELEC					; DATA SEGMENT SELECTOR
					DW		GDATA						; DATA SEGMENT ADDRESS
					DW 		INT_SELEC					; INTERRUPT SEGMENT SELECTOR
					DW		CODE						; CODE SEGMENT ADDRESS
					
; STEP 4.1: DEFINE LEVEL 1 AND 2 CODE SEGMENT

					DW		TASK1_TSS_SELEC				; TASK1 TSS SEGMENT SELECTOR
					DW		TASK1_TSS					; TASK1 TSS SEGMENT
					DW		TASK1_CODE_SELEC			; TASK1 CODE SEGMENT SELECTOR
					DW		TASK1_SEG					; TASK1 CODE SEGMENT
	
	GDT_TAB_SIZE	EQU		($ - GDT_PHYS_TAB) / 4		; ENTRY NUMBERS IN
														; ABOVE TABLE
														
; STEP 5: MESSAGE DEFINITION AREA FOR TASK SWITCH

	IN_PROTECTED	DB		'In Protected Mode ', 0
	INT_MSG			DB		'Interrupt   h', 0
	INT_NUM			DB 		10h		

; STEP 5.1: PAGING WORKING AREA

	TASK1_MSG		DB		'Switch to Task 1 ', 0
	RETMSG			DB 		'Return to Task 0', 0
					
	GDATA_LIMIT		EQU		$
	
GDATA ENDS

; STEP 6: STACK SEGMENT FOR PRIVILEGE LEVEL 0, 1, 2

STK0 SEGMENT PARA PUBLIC 'STK0' USE16
					DB		100h DUP(0)
	STK0_LIMIT		EQU		$
STK0 ENDS

STK1 SEGMENT PARA PUBLIC 'STK1' USE16
					DB		100h DUP(0)
	STK1_LIMIT		EQU		$
STK1 ENDS

STK2 SEGMENT PARA PUBLIC 'STK2' USE16
					DB		100h DUP(0)
	STK2_LIMIT		EQU		$
STK2 ENDS

; STEP 7: TASK STATE SEGMENT

TASK0_TSS SEGMENT PARA PUBLIC 'TASK0' USE16

	TSS_STACK		STK0_SELEC, STK0_LIMIT, STK1_SELEC, STK1_LIMIT, STK2_SELEC, STK2_LIMIT
					
	TSS_CR3												; CR3
	
	TSS_REGS		0, 0, 0, 0, 0, 0, 0, 0, 0, STK0_LIMIT
	TSS_SEG			GDATA_SELEC, CODE_SELEC, STK0_SELEC, GDATA_SELEC, GDATA_SELEC, GDATA_SELEC
					
					DD		0							; LDT FIELD
					DW		0							; TASK TRAP FLAG
					DW		68h							; I/O BASE
					
	TASK0_TSS_LIMIT	EQU		$
	
TASK0_TSS ENDS

; STEP 7.1: TASK STATE SEGMENT FOR TASK1

TASK1_TSS SEGMENT PARA PUBLIC 'TASK1' USE16

	TSS_STACK		STK0_SELEC, STK0_LIMIT, STK1_SELEC, STK1_LIMIT, STK2_SELEC, STK2_LIMIT
					
	TSS_CR3												; CR3
	
	TSS_REGS		TASK1_ENTRY, 2, 0, 0, 0, 0, 0, 0, 0, STK1_LIMIT
	TSS_SEG			GDATA_SELEC, TASK1_CODE_SELEC, STK1_SELEC, GDATA_SELEC, GDATA_SELEC, GDATA_SELEC
					
					DD		0							; LDT FIELD
					DW		0							; TASK TRAP FLAG
					DW		68h							; I/O BASE
					
	TASK1_TSS_LIMIT	EQU		$
	
TASK1_TSS ENDS

; STEP 8: DUMMY SEGMENT

DMY SEGMENT PARA PUBLIC 'DMY' USE16
	DB		128 DUP(0)
DMY ENDS

CODE SEGMENT PARA PUBLIC 'CODE' USE16
	ASSUME CS:CODE, DS:GDATA
	
		MAIN PROC FAR
		
			MOV		AX, GDATA							; GET GDATA SEGMENT ADDRESS
			MOV		DS, AX								; PUT IN DS
			
; STEP 9: INITIALIZE IDT

			MOV		AX, IDT								; GET IDT SEGMENT ADDRESS
			MOV		ES, AX								; PUT IN ES
			MOV		DI, OFFSET IDT_TAB					; GET IDT OFFSET ADDRESS
			MOV		AX, OFFSET INT_ENTRY				; GET INTERRUPT SERVICE
														; ROUTINE ADDRESS
			MOV		CX, INTNO							; GET INTERRUPT NUMBER
		FILLIDT:
			MOV		ES:[DI], AX							; PUT ENTRY ADDRESS IN IDT
			ADD		DI, DSCPSIZE						; ADJUST ADDRESS IN IDT
			ADD		AX, INTSIZE							; ADJUST INTERRUPT SERVICE
														; ROUTINE ADDRESS, THE SIZE OF EACH
														; ROUTINE IS DEFINED IN INTSIZE
			LOOP	FILLIDT								; KEEP FILLING

; STEP 10, 11, 12, 13: SET LINEAR ADDRESS FOR DESCRIPTOR IN GDT,
;		GDTR, IDTR AND LDTR THEN SWITCH TO PROTECTED MODE

			BUILD_DTR	GDT, IDT, PGDT, PIDT, GDT_LIMIT, IDT_LIMIT
			BUILD_DT	GDT, GDT_PHYS_TAB, GDT_TAB_SIZE
			CLI
			GOTO_PROT		PGDT, PIDT, CODE_SELEC, STK0_SELEC, STK0_LIMIT, GDATA_SELEC
			
; STEP: 14 DISPLAY MESSAGE IN PROTECTED MODE
														; CLEAR SCREEN FIRST
			MOV		AX, VIDEO_SELEC						; GET VIDEO SEGMENT SELECTOR
			MOV		ES, AX								; PUT IN ES
			MOV		CX, 4000h							; SCREEN SIZE
			XOR		DI, DI								; SCREEN STARTING ADDRESS
			MOV		AH, ATTRIBUTE
			MOV		AL, SPACE							; FILL SPACE AND ATTRIBUTE
			REP		STOSW								; FILL IT
			MOV		SI, OFFSET IN_PROTECTED				; GET PROTECTED MODE
														; MESSAGE ADDRESS
			MOV		DI, 320								; GET DISPLAY ADDRESS
			CALL	DISP_IT								; CALL DISPLAY PROCEDURE
			
; STEP 15: LOAD TSS TO TR

			MOV		AX, TASK0_TSS_SELEC					; GET TSS SELECTOR FOR
														; CURRENT TASK
			LTR		AX									; LOAD INTO TASK REGISTER
			
; STEP 15.1: JUMP TO TASK1 THROUGH TASK1 SELECTOR

			JMPF	TASK1_TSS_SELEC						; JUMP TO TASK1 TSS SELECTOR
			
; STEP 15.2: DISPLAY MESSAGE AFTER RETURNING FROM TASK1

			MOV		SI, OFFSET RETMSG				; GET MESSAGE ADDRESS
			MOV		DI, 4 * 160							; GET DISPLAY ADDRESS
			CALL	DISP_IT								; CALL DISPLAY
			
; STEP 16: SWITCH BACK TO REAL MODE ADDRESS

			JMP		GO_EXIT
			
; STEP 17: INTERRUPT SERVICE ROUTINE

		INT_ENTRY:										; ENTRY POITN FOR
														; INTERRUPT SERVICE ROUTINE
			REPT	INTNO
			CALL	DISP								; CALL THE DISPLAY MESSAGE
			IRET										; PROCEDURE
			ENDM
			
; STEP 18: GET INTERRUPT NUMBER AND DISPLAY IT

		DISP:
			MOV		BX, GDATA_SELEC						; RELOAD DATA SEGMENT
			MOV		DS, BX
			
			MOV		AL, INT_NUM							; GET OFFSET FROM THE

			XOR		ESI, ESI							; ESTA LINHA EU INCLUI, PARA GARANTIR O ENDERECO DA INTERRUPCAO
			MOV		SI, OFFSET INT_MSG[10]				; GET ASCII CODE ADDRESS
			MOV		CX, TWO								; CONVERT TO 2 ASCII CODE
			CALL	HTOA								; CALL CONVERT PROCEDURE
			MOV		SI, OFFSET INT_MSG					; GET INTERRUPT MESSAGE
			
			MOV		DI, 3 * 160
			
			CALL	DISP_IT								; CALL DISPLAY PROCEDURE
			
; STEP 19: RETURN TO REAL MODE ADDRESS

		GO_EXIT:
			CLI											; DISABLE INTERRUPT
			MOV		AX, DMY_SELEC						; DUMMY SELECTOR
			MOV		ES, AX
			MOV		DS, AX
			MOV		FS, AX
			MOV		GS, AX
			MOV		SS, AX
			MOV		EAX, CR0							; LOAD THE CONTENT OF CR0
			AND		EAX, NOT PROT_ENABLE				; DISABLE PROTECTED MODE
			MOV		CR0, EAX							; RESTORE THE CONTETENT OF
														; CR0
			DB		0EAh								; FAR JUMP FLUSH
														; INSTRUCTION QUEUE
			DW		OFFSET NEXT_INSTRUCTION				; NEW EIP
			DW		CODE								; NEW CS
			
; STEP 20: EXECUTE IN REAL MODE ADDRESE, SET DS, SS, AND SP

		NEXT_INSTRUCTION:
			MOV		AX, GDATA							; GET DATA SEGMENT ADDRESS
			MOV		DS, AX								; PUT IN DS
			MOV		AX, STK0							; GET STACK SEGMENT ADDRESS
			MOV		SS, AX								; PUT IN SS
			MOV		SP, OFFSET STK0_LIMIT				; SET STACK POINTER
			
; SETP 21: SET IDTR TO DOS INTERRUPT TABLE
			LIDT	[POLD]								; LOAD DOS INTERRUPT VECTOR
														; TABLE TO IDTR REGISTER
			STI											; ENABLE INTERRUPT
			
; STEP 22: TERMINATE THIS PROCESS

			MOV		AX, 4C00H							; TERMINATE PROCESS
			INT		21H									; DOS FUNCTION CALL
		
		MAIN ENDP
		
	; PROCEDURE: DISP_IT
	; DISPLAY STRING IN PROTECTED MODE
	; INPUT DS:SI - STRING ADDRESS, THE END OF THE STRING MUST BE 0
	
		DISP_IT PROC NEAR
			
			MOV		AX, VIDEO_SELEC						; GET VIDEO SEGMENT SELECTOR
			MOV		ES, AX								; PUT IN ES
			MOV		AH, ATTRIBUTE						; DISPLAY ATTRIBUTE
			
		DISP_IT1:
			LODSB										; GET DISPLAY CHARACTER
			STOSW										; PUT IT ON SCREEN
			CMP		AL, 0								; END OF DISPLAY CHARACTER ?
			JNE		DISP_IT1							; NO CONTINUE
			RET											; YES RETURN
			
		DISP_IT ENDP
		
	; PROCEDURE: HTOA
	; CONVERT HEXADECIMAL CODE TO ASCII CODE
	; INPUT: SI- ADDRESS TO PUT ASCII CODE, CX- HEXADECIMAL
	; CODE SIZE, EAX- HEXADECIMAL CODE
	
	HTOA_TAB		DB '0123456789ABCDEF'
		
		HTOA PROC NEAR
		
			XOR		EBX, EBX							; CLEAR EBX
			ADD		SI, CX								; ADJUST TARGET ADDRESS
			DEC		SI
			
		HTOA1:
			MOV		BL, AL								; GET HEXADECIMAL CODE
			AND		BL, 0Fh								; DISTINGUISH IT
			MOV		BL, CS:[HTOA_TAB][EBX]				; GET INDEXED ASCII
														; CHARACTER
			MOV		BYTE PTR [ESI], BL					; PLACE IN TARGET ADDRESS
			DEC		ESI									; ADJUST TARGET ADDRESS
			SHR		EAX, 4								; GET RID OF IT
			LOOP	HTOA1								; CONTINUE
			RET											; RETURN
	HTOA ENDP

CODE ENDS

; STEP 23: TASK1 CODE SEGMENT

TASK1_SEG SEGMENT PARA PUBLIC 'TASK1_SEG' USE16
	ASSUME CS:TASK1_SEG, DS:GDATA
	
		TASK1_ENTRY PROC NEAR
		
; STEP 24: DISPLAY MESSAGE WHEN ENTERING TASK1

			MOV		SI, OFFSET TASK1_MSG				; GET DISPLAY MESSA ADDRESS
			MOV		DI, 3 * 160							; GET DISPLAY POSITION
			CALL	DISP2								; CALL DISPLAY PROCEDURE
		
; STEP 25: SWITCH BACK TO TASK0 USING INTERRUPT INSTRUCTION
; THROUGH TASK GATE

			INT		21									; TASK GATE RESIDE IN IDT (INT 21)
		
		TASK1_ENTRY ENDP

	; PROCEDURE: DISP2
	; DISPLAY STRING IN PROTECTED MODE
	; INPUT DS:SI - STRING ADDRESS, THE END OF THE STRING MUST BE 0
	
	DISP2 PROC NEAR
			
			MOV		AX, VIDEO_SELEC						; GET VIDEO SEGMENT SELECTOR
			MOV		ES, AX								; PUT IN ES
			MOV		AH, ATTRIBUTE						; DISPLAY ATTRIBUTE
			
		DISP21:
			LODSB										; GET DISPLAY CHARACTER
			STOSW										; PUT IT ON SCREEN
			CMP		AL, 0								; END OF DISPLAY CHARACTER ?
			JNE		DISP21								; NO CONTINUE
			RET											; YES RETURN
			
	DISP2 ENDP
		
	TASK1_SEG_LIMIT	EQU $
	
TASK1_SEG ENDS

END MAIN