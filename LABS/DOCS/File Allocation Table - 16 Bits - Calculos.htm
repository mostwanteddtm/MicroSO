
<!-- saved from url=(0053)http://www.beginningtoseethelight.org/fat16/index.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>file allocation table - 16bit</title><style type="text/css"><!--a {  text-decoration: none}a:hover {  text-decoration: underline}font { font-family: "Courier New", Courier, mono; font-size: 12px}td { font-family: "Courier New", Courier, mono; font-size: 12px}--></style></head><body bgcolor="#f0f0f0" text="#000000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0"><br><table width="600" border="0" cellspacing="0" cellpadding="0" align="center" bgcolor="#000000"><tbody><tr><td><table width="600" border="0" cellspacing="2" cellpadding="0" align="center" bgcolor="#000000"><tbody><tr><td width="297"><table border="0" cellspacing="0" cellpadding="0" bgcolor="#f0f0f0" height="23" width="100%"><tbody><tr><td align="center"><b>file allocation table - 16bit</b></td></tr></tbody></table></td><td width="297"><table border="0" cellspacing="0" cellpadding="0" bgcolor="#f0f0f0" height="23" width="100%"><tbody><tr><td align="center"><a href="mailto:clark@hushmail.com">clark@hushmail.com</a> | updates closed</td></tr></tbody></table></td></tr><tr><td colspan="2"><table width="596" border="0" cellspacing="0" cellpadding="5" bgcolor="#f0f0f0"><tbody><tr><td>forewords<br><br>this article is about fat16 with additional comments regarding windows 98. certain things will appear/handle differently in other oses.<br><br>special thanks go to jon fox who helped me out on calculating the volume serial number, the lfn checksum and making some worthy comments while in draft form, i really appreaciate it.</td></tr></tbody></table></td></tr><tr><td colspan="2"><table width="596" border="0" cellspacing="0" cellpadding="5" bgcolor="#f0f0f0"><tbody><tr><td>overview<br><br><table width="98%" border="0" cellspacing="0" cellpadding="0" height="26" align="center"><tbody><tr><td width="271" height="169"><img src="./File Allocation Table - 16 Bits - Calculos_files/overview.gif" width="399" height="179"></td><td width="325" valign="top" align="center"><table width="168" border="0" cellspacing="0" cellpadding="0"><tbody><tr><td width="16"><img src="./File Allocation Table - 16 Bits - Calculos_files/512yellow.gif" width="7" height="9"></td><td width="152">master boot record</td></tr><tr><td width="16"><img src="./File Allocation Table - 16 Bits - Calculos_files/512red.gif" width="7" height="9"></td><td width="152">sectors 1 - 62</td></tr><tr><td width="16"><img src="./File Allocation Table - 16 Bits - Calculos_files/512pink.gif" width="7" height="9"></td><td width="152">boot record</td></tr><tr><td width="16"><img src="./File Allocation Table - 16 Bits - Calculos_files/512green.gif" width="7" height="9"></td><td width="152">fat 1</td></tr><tr><td width="16"><img src="./File Allocation Table - 16 Bits - Calculos_files/512darkgreen.gif" width="7" height="9"></td><td width="152">fat 2</td></tr><tr><td width="16"><img src="./File Allocation Table - 16 Bits - Calculos_files/512orange.gif" width="7" height="9"></td><td width="152">root directory</td></tr><tr><td width="16"><img src="./File Allocation Table - 16 Bits - Calculos_files/512turquoise.gif" width="7" height="9"></td><td width="152">sub directory</td></tr><tr><td width="16"><img src="./File Allocation Table - 16 Bits - Calculos_files/512blue.gif" width="7" height="9"></td><td width="152">data</td></tr></tbody></table><br>1 block = 512 bytes</td></tr></tbody></table><br>this is a scale diagram of the start of the disk with a small fat16 partition at the beginning. this partition is just over 20mb in size, to save space not all the data/subdir/surplus area is shown - there would be 44,815 blocks or ~=896 lines if this part was shown completely.</td></tr></tbody></table></td></tr><tr><td colspan="2"><table width="596" border="0" cellspacing="0" cellpadding="5" bgcolor="#f0f0f0"><tbody><tr><td>master boot record diagram<br><br><table width="98%" border="0" cellspacing="0" cellpadding="0" align="center"><tbody><tr><td align="center"><img src="./File Allocation Table - 16 Bits - Calculos_files/mbr.gif" width="544" height="534"><br><table width="546" border="0" cellspacing="0" cellpadding="3"><tbody><tr><td width="50%" align="left" valign="top"><img src="./File Allocation Table - 16 Bits - Calculos_files/darkgreen.gif" width="20" height="10">-&gt; executable code<br><img src="./File Allocation Table - 16 Bits - Calculos_files/red.gif" width="20" height="10">-&gt; boot indicator<br><img src="./File Allocation Table - 16 Bits - Calculos_files/yellow.gif" width="20" height="10">-&gt; starting head<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkblue.gif" width="20" height="10">-&gt; starting sector &amp; cylinder<br><img src="./File Allocation Table - 16 Bits - Calculos_files/turquoise.gif" width="20" height="10">-&gt; partiton type</td><td width="50%" align="left" valign="top"><img src="./File Allocation Table - 16 Bits - Calculos_files/paleyellow.gif" width="20" height="10">-&gt; ending head<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleblue.gif" width="20" height="10">-&gt; ending sector &amp; cylinder<br><img src="./File Allocation Table - 16 Bits - Calculos_files/green.gif" width="20" height="10">-&gt; the starting sector<br><img src="./File Allocation Table - 16 Bits - Calculos_files/purple.gif" width="20" height="10">-&gt; no. of sectors in partition<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkorange.gif" width="20" height="10" border="0">-&gt; executable signature</td></tr></tbody></table><hr width="580" size="1" align="center"><div align="left">1 partition entry is as follows:<br><img src="./File Allocation Table - 16 Bits - Calculos_files/onentry1.gif" width="544" height="53"><br><br>and reads as:<br><img src="./File Allocation Table - 16 Bits - Calculos_files/onentry2.gif" width="397" height="17"></div></td></tr></tbody></table><hr width="580" size="1" align="center">mbr in general ( =512 bytes )<br><br>the master boot record (mbr) is located in the first data sector on the hard disk. the mbr can have upto 4 primary partitions, each entry occupies 16 bytes. if the slot is unused, the space is filled with 00. each entry sets out the addressing parameters for the partition. hard disks have grown considerably in size since they were first invented, this has caused some strange addressing techniques to be used to ensure compatibility. hard drives used to be addressed by cylinder, head and sector (chs). as cylinders increased, instead of addressing it literally, the addressing values became virtual. example: 16 heads are specified on the drive and in bios, but when opened up there were only 6 physical heads. this is converted by the hard disks controller card to real values. however virtual chs addressing is also limited, when these values are exceeded, logical block addressing (lba) is used by partitions. lba is achieved by addressing each sector on the disk by number, the first sector is 0.<br><hr width="580" size="1" align="center"> executable code ( =446 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkgreen.gif" width="20" height="10"><br><br>this is the first piece of software that runs when a computer loads up. it can be less than 446 bytes; the remainding bytes will filled with 00. the bios checks for the executable signature, if absent a hardware error is displayed, else the code is run. it looks for and loads partition parameters in the four areas and checks that only one is bootable. it then checks the active partition's boot record for the executable signature before running it. if this is absent the error: missing operating system will appear.<br><hr width="580" size="1" align="center">boot indicator ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/red.gif" width="20" height="10"><br><br>determines which partition to boot from. 00 = inactive and 80 = active<br>there must only be one partition marked as 80. if more than one are marked the system will halt with the error: invalid partition table. if none are marked the system will display a hardware error like: operating system not found; this will vary from machine.<br><hr width="580" size="1" align="center">starting head ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/yellow.gif" width="20" height="10"><br><br>states the starting head for the partition in hex.<br>eg, 01 = head 1; and another example: 3f = head 63<br>if these values are incorrect the system will halt with: error loading operating system. the maximum number of heads is 256. if the partition is in lba mode the head will be one less than the maximum.<br><hr width="580" size="1" align="center">starting sector/cylinder ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkblue.gif" width="20" height="10"><br><br>states the sector and cylinder on which the partition begins. though it looks like the first byte states the sector and the second the cylinder in hex, this is not the case.<br>example: 62 sectors and 690 cylinders; from the disk read: be,b2<br>first convert to binary: be,b2 -&gt; 1011 1110,1011 0010<br><br>the last 6 bits of the first byte: 11 1110 = 3e -&gt; decimal = 62 sectors<br>6 bits gives a potential maximum of 63 sectors, 1 - 63 inclusively.<br><br>join the first 2 bits of the first byte with the whole second byte:<br>10 1011 0010 = 2b2 -&gt; decimal = 690 cylinders<br>10 bits gives a potential maximum of 1024 cylinders, 0-1023 inclusively.<br>if these values are incorrect the system will halt with: error loading operating system.<br><hr width="580" size="1" align="center">partition type ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/turquoise.gif" width="20" height="10"><br><br>states the type of partition, there are others, but for different systems.<br>the maximum number of heads = 256, the maximum number of sectors is 63 and the maximum number of cylinder is 1024. hard disk are formatted with 512 byte sectors. therefore the maximum partition is 1024 * 256 * 63 * 512 = 8,455,716,864. anything addressed over this will be a lba partition.<br><br><table width="485" border="0" cellspacing="0" cellpadding="0" align="center" bgcolor="#000000"><tbody><tr><td><table width="485" border="0" cellspacing="1" cellpadding="0" bgcolor="#000000"><tbody><tr><td width="60"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td>&nbsp;</td></tr></tbody></table></td><td width="48"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">fat16</td></tr></tbody></table></td><td width="48"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">fat32</td></tr></tbody></table></td><td width="68"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">extended</td></tr></tbody></table></td><td width="78"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">fat16lba</td></tr></tbody></table></td><td width="70"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">fat32lba</td></tr></tbody></table></td><td width="105"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">extended lba</td></tr></tbody></table></td></tr><tr><td width="60"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">visible</td></tr></tbody></table></td><td width="48"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">06</td></tr></tbody></table></td><td width="48"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">0b</td></tr></tbody></table></td><td width="68"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">05</td></tr></tbody></table></td><td width="78"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">0e</td></tr></tbody></table></td><td width="70"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">0c</td></tr></tbody></table></td><td width="105"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">0f</td></tr></tbody></table></td></tr><tr><td width="60"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">hidden</td></tr></tbody></table></td><td width="48"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">16</td></tr></tbody></table></td><td width="48"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">1b</td></tr></tbody></table></td><td width="68"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">15</td></tr></tbody></table></td><td width="78"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">1e</td></tr></tbody></table></td><td width="70"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">1c</td></tr></tbody></table></td><td width="105"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">1f</td></tr></tbody></table></td></tr></tbody></table></td></tr></tbody></table><br>if a partition is marked as active and has a operating system installed and the partition is marked as hidden the system will load the io.sys and then prompt: type the name of the command interpreter (eg., c:\windows\command.com) a&gt;_<br><hr width="580" size="1" align="center">ending head ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/paleyellow.gif" width="20" height="10"><br><br>as the starting head, but ending.<br><hr width="580" size="1" align="center">ending sector/cylinder ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/paleblue.gif" width="20" height="10"><br><br>as the starting sector/cylinder, but ending.<br><hr width="580" size="1" align="center">the starting sector ( =4 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/green.gif" width="20" height="10"><br><br>this is the logical sector jump to the partition. this sector contains the partition's boot record. from the disk:<br>40,03,07,01 flip -&gt; 01,07,03,40 convert to decimal = sector 17,236,800<hr width="580" size="1" align="center">sectors in the partition ( =4 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/purple.gif" width="20" height="10"><br><br>states the number of sectors in the partition, the last sector will be one less than the total as the first sector is sector 0. from the disk: f0,ae,24,00 flip -&gt; 00,24,ae,fo convert to decimal = 2,404,080 sectors<br><hr width="580" size="1" align="center">executable signature ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkorange.gif" width="20" height="10"><br><br>these two bytes indicate that the sector is executable, the system will check for them. if incorrect a hardware error will be displayed. example; on a toshiba satellite:<br>insert system disk in drive.<br>press any key when ready....<br>and on a hi-grade ultinote: operating system not found; if they are present the code will run.</td></tr></tbody></table></td></tr><tr><td colspan="2"><table width="596" border="0" cellspacing="0" cellpadding="5" bgcolor="#f0f0f0"><tbody><tr><td>sectors 1 - 62 ( =31,744 bytes )<br><br>sectors 1 - 62 inclusively are normally left empty. applications that do use it include: multi boot loaders like ranish advanced boot manager. security programs such as reflex-magnetics disknet. viruses that copy themselves to the master boot record so that they can load every time, sometimes move the real mbr into this area, plus any more virus code. full disk encryption programs and disk translation software for very large hard disks may also reside here.</td></tr></tbody></table></td></tr><tr><td colspan="2"><table width="596" border="0" cellspacing="0" cellpadding="5" bgcolor="#f0f0f0"><tbody><tr><td>boot record diagram<br><br><table width="98%" border="0" cellspacing="0" cellpadding="0" align="center"><tbody><tr><td align="center"><img src="./File Allocation Table - 16 Bits - Calculos_files/br.gif" width="544" height="534"><br><table width="546" border="0" cellspacing="0" cellpadding="3"><tbody><tr><td width="50%" align="left" valign="top"><img src="./File Allocation Table - 16 Bits - Calculos_files/red.gif" width="20" height="10">-&gt; jumpcode<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleblue.gif" width="20" height="10">-&gt; oem/id name<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkturquoise.gif" width="20" height="10">-&gt; bytes per sector<br><img src="./File Allocation Table - 16 Bits - Calculos_files/turquoise.gif" width="20" height="10">-&gt; sectors per allocation<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palered.gif" width="20" height="10">-&gt; resevered sectors<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleturquoise.gif" width="20" height="10">-&gt; no. of fats<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkred.gif" width="20" height="10">-&gt; root entries<br><img src="./File Allocation Table - 16 Bits - Calculos_files/yellow.gif" width="20" height="10">-&gt; total sectors(16)<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palegreen.gif" width="20" height="10">-&gt; media type<br><img src="./File Allocation Table - 16 Bits - Calculos_files/purple.gif" width="20" height="10">-&gt; sectors per fat<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkpurple.gif" width="20" height="10">-&gt; sectors per track</td><td width="50%" align="left" valign="top"><img src="./File Allocation Table - 16 Bits - Calculos_files/paleorange.gif" width="20" height="10">-&gt; no. of heads<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkyellow.gif" width="20" height="10">-&gt; hidden sectors<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleyellow.gif" width="20" height="10">-&gt; total sectors(32)<br><img src="./File Allocation Table - 16 Bits - Calculos_files/green.gif" width="20" height="10">-&gt; drive id<br><img src="./File Allocation Table - 16 Bits - Calculos_files/grey.gif" width="20" height="10">-&gt; nt reserved<br><img src="./File Allocation Table - 16 Bits - Calculos_files/orange.gif" width="20" height="10">-&gt; extended boot signature<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palepurple.gif" width="20" height="10">-&gt; volume serial number<br><img src="./File Allocation Table - 16 Bits - Calculos_files/blue.gif" width="20" height="10">-&gt; volume/partition name<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkblue.gif" width="20" height="10">-&gt; fat type<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkgreen.gif" width="20" height="10">-&gt; executable boot(strap) code<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkorange.gif" width="20" height="10">-&gt; executable signature</td></tr></tbody></table></td></tr></tbody></table><hr width="580" size="1" align="center">jumpcode ( =3 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/red.gif" width="20" height="10"><br><br>the offset jump to the boot(strap) executable code plus a nop. from the disk: eb,3e,90 -&gt; translates to: |jumpshort(to)|offset 3e|no operation|<br><hr width="580" size="1" align="center">oem/id name ( =8 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/paleblue.gif" width="20" height="10"><br><br>some indication to what system formatted the partition, not checked, but set for compatibility. mswin4.0 and mswin4.1 as formatted by windows 95 and 98 respectfully.<br><hr width="580" size="1" align="center">bytes per sector ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkturquoise.gif" width="20" height="10"><br><br>normally set to 512 bytes; from the disk: 00,02 flip -&gt; 02,00 convert to decimal = 512 bytes. 1024, 2048 and 4096 are also valid, but are not generally used.<br><hr width="580" size="1" align="center"> sectors per cluster ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/turquoise.gif" width="20" height="10"><br><br>states the number of sectors per cluster. this will vary depending on the size of the partition. example: 10 convert to decimal = 16 sectors<br>for hard disks:<br><br><table width="424" border="0" cellspacing="0" cellpadding="0" align="center" bgcolor="#000000"><tbody><tr><td><table width="424" border="0" cellspacing="1" cellpadding="0" bgcolor="#000000"><tbody><tr><td width="138"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">size ranges (mb)</td></tr></tbody></table></td><td width="76"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">fat type</td></tr></tbody></table></td><td width="99"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">no. sectors</td></tr></tbody></table></td><td width="106"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">cluster size</td></tr></tbody></table></td></tr><tr><td width="138"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">0 - 15</td></tr></tbody></table></td><td width="76"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">12</td></tr></tbody></table></td><td width="99"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">8</td></tr></tbody></table></td><td width="106"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">4,096 bytes</td></tr></tbody></table></td></tr><tr><td width="138"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">16 - 127</td></tr></tbody></table></td><td width="76"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">16</td></tr></tbody></table></td><td width="99"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">4</td></tr></tbody></table></td><td width="106"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">2,048 bytes</td></tr></tbody></table></td></tr><tr><td width="138"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">128 - 255</td></tr></tbody></table></td><td width="76"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">16</td></tr></tbody></table></td><td width="99"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">8</td></tr></tbody></table></td><td width="106"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">4,096 bytes</td></tr></tbody></table></td></tr><tr><td width="138"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">256 - 511</td></tr></tbody></table></td><td width="76"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">16</td></tr></tbody></table></td><td width="99"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">16</td></tr></tbody></table></td><td width="106"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">8,192 bytes</td></tr></tbody></table></td></tr><tr><td width="138"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">512 - 1023</td></tr></tbody></table></td><td width="76"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">16</td></tr></tbody></table></td><td width="99"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">32</td></tr></tbody></table></td><td width="106"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">16,384 bytes</td></tr></tbody></table></td></tr><tr><td width="138"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">1024 - 2047</td></tr></tbody></table></td><td width="76"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">16</td></tr></tbody></table></td><td width="99"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">64</td></tr></tbody></table></td><td width="106"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">32,768 bytes</td></tr></tbody></table></td></tr></tbody></table></td></tr></tbody></table><br>note that in this table the cluster size is calculated with a sector size of 512, which is most common. cluster sizes should not exceed 32,768 bytes<br><hr width="580" size="1" align="center">resevered sectors ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/palered.gif" width="20" height="10"><br><br>states the number of reserved sectors. on fat12/16: 01,00 flip -&gt; 00,01 convert to decimal = 1 sector - the boot record is this.<br><hr width="580" size="1" align="center">no. of fats ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/paleturquoise.gif" width="20" height="10"><br><br>states the number fats used. normally set to 2 in case of bad sectors, which could lead to data errors. however &gt;=1 is also valid - unsure of maximum.<br><hr width="580" size="1" align="center">root entries ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkred.gif" width="20" height="10"><br><br>states the maximum number of 32byte entries in the root directory; unused for fat32 and set to 00,00; however for fat16: 00,02 flip -&gt; 02,00 convert to decimal = 512; 512 * 32(bytes) = 16384 bytes - data is stored after this point.<br><hr width="580" size="1" align="center">total sectors(16) ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/yellow.gif" width="20" height="10"><br><br>set if the partiton is less than 33,554,432 bytes (32mb) in size - mainly for a floppy disk: 40,0b flip -&gt; 0b,40 convert to decimal = 2880 sectors; fat16 partitions may also use this entry. if number of sectors is above this will be set to 00,00<br><hr width="580" size="1" align="center">media type ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/palegreen.gif" width="20" height="10"><br><br>states the physical media type; f8 = hard drive; f0 = (standard) floppy drive<br><hr width="580" size="1" align="center">sectors per fat ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/purple.gif" width="20" height="10"><br><br>number of sectors in one fat; for a floppy: 09,00 flip -&gt; 00,09 covert to decimal = 9 * 512(bytes per sector) = 4608; there are two copies of the fat thus 4608 * 2 = 9,216 bytes - the jump to the root directory.<br><hr width="580" size="1" align="center">sectors per track ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkpurple.gif" width="20" height="10"><br><br>states the number of sectors per track.<br><hr width="580" size="1" align="center">no. of heads ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/paleorange.gif" width="20" height="10"><br><br>number of disk drive heads; eg on a floppy disk: 02,00 flip -&gt; 02,00 convert to decimal = 2 heads. on a hard disk this will be much more; eg f0,00 flip -&gt; 00,f0 convert to decimal = 240 heads<br><hr width="580" size="1" align="center">hidden sectors ( =4 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkyellow.gif" width="20" height="10"><br><br>this will matchup with the starting sector stated in the partitions' entry in the mbr. it states the number of hidden sectors from the beginning of the drive to the boot record of the partition. normally set to 3f,00,00,00 flip -&gt; 00,00,00,3f convert to decimal = 63, for a primary partition. note that sector 63 will contain the boot record, as sector numbers start at zero. another example from disk: 40,03,07,01 flip -&gt; 01,07,03,40 convert to decimal = 17,236,800<br><hr width="580" size="1" align="center">total sectors(32) ( =4 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/paleyellow.gif" width="20" height="10"><br><br>no of sectors in the partition eg, 10,ec,03,00 flip -&gt; 00,03,ec,10 convert to decimal = 257040 sectors (normally 512 bytes) this entry is used if total sectors(16) is set to 00,00<br><hr width="580" size="1" align="center">drive id ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/green.gif" width="20" height="10"><br><br>set to 00 for floppy disks and 80 for hard disks. also refered to as the logical drive number.<br><hr width="580" size="1" align="center">nt reserved ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/grey.gif" width="20" height="10"><br><br>set at format to 00 and not checked thereafter.<br><hr width="580" size="1" align="center">extended boot signature ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/orange.gif" width="20" height="10"><br><br>set to 29 indicating that the serial, label and type data is present.<br><hr width="580" size="1" align="center">volume serial number ( =4 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/palepurple.gif" width="20" height="10"><br><br>when a partition is formatted; quick or full, it will display the newly assigned serial such as: 15e7-2a35. this is written in reverse on the disk as: 35,2a,e7,15. calculated by combining the date and time at the point of format, it is an unique identifier to keep track of drives in use. it is not possible to retrive the date and time from the serial number.<br><br>time: 2:22:32.50p | date: (oct)10-03-2001 | serial on disk: 35,2a,e7,15<br><br>first byte is calculated as follows:<br>milliseconds + days -&gt; convert to hex<br>50 + 3 = 53 -&gt; = 35<br><br>the second byte is calculated as follows:<br>months + seconds -&gt; convert to hex<br>10 + 32 = 42 -&gt; = 2a<br><br>last two bytes are calculated as follows:<br>(hours [if pm + 12] * 256) + minutes + years -&gt; convert to hex &amp; flip<br>(2 + 12 = 14 * 256 = 3584) + 22 + 2001 = 5607 -&gt; 15,e7 -&gt; e7,15<br><hr width="580" size="1" align="center">volume/partition name ( =11 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/blue.gif" width="20" height="10"><br><br>the volume label can be up to 11 characters. it also has to be referenced in the root directory as a 32 byte entry with the volume attribute to be displayed. "no name" will normally be used when the label is unused.<br><hr width="580" size="1" align="center">fat type ( =8 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkblue.gif" width="20" height="10"><br><br>normally set to: fat12, fat16 and fat(32); this is not used to determine the fat type and can be changed, though some non-ms drivers use it. usefull as a quick reference of the fat type; though not always accurate.<br><hr width="580" size="1" align="center">executable boot code ( =448 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkgreen.gif" width="20" height="10"><br><br>sets out the aforementioned partition infomation and checks for the first file to start the system; normally io.sys. if this is not present; the stated error message (or modified one) will apppear. normally as follows:<br>invalid system disk<br>replace the disk, and then press any key<br>od,oa meaning carriage-return and linefeed respectfully; derived from a typewritters actions. the system will look in two places for this 11 character dos named file, which can be renamed. the first 11 and 2 bytes from the end. the file must have an extension which is &gt;= 1 letter.<br><hr width="580" size="1" align="center">executable signature ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkorange.gif" width="20" height="10"><br><br>the mbr checks for this signature: 55,aa - if absent: "missing operating system" error.</td></tr></tbody></table></td></tr><tr><td colspan="2"><table width="596" border="0" cellspacing="0" cellpadding="5" bgcolor="#f0f0f0"><tbody><tr><td>the fat diagrams<br><br><table width="98%" border="0" cellspacing="0" cellpadding="0" align="center"><tbody><tr><td align="center"><img src="./File Allocation Table - 16 Bits - Calculos_files/clusters.gif" width="544" height="54"><br><table width="546" border="0" cellspacing="0" cellpadding="3"><tbody><tr><td width="50%" align="left" valign="top"><p><img src="./File Allocation Table - 16 Bits - Calculos_files/darkblue.gif" width="20" height="10">-&gt; media type<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleblue.gif" width="20" height="10">-&gt; partition state<br><img src="./File Allocation Table - 16 Bits - Calculos_files/red.gif" width="20" height="10">-&gt; cluster 2<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palered.gif" width="20" height="10">-&gt; cluster 3<br><img src="./File Allocation Table - 16 Bits - Calculos_files/green.gif" width="20" height="10">-&gt; cluster 4<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palegreen.gif" width="20" height="10">-&gt; cluster 5<br><img src="./File Allocation Table - 16 Bits - Calculos_files/yellow.gif" width="20" height="10">-&gt; cluster 6<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleyellow.gif" width="20" height="10">-&gt; cluster 7</p></td><td width="50%" align="left" valign="top"><img src="./File Allocation Table - 16 Bits - Calculos_files/turquoise.gif" width="20" height="10">-&gt; cluster 8<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleturquoise.gif" width="20" height="10">-&gt; cluster 9<br><img src="./File Allocation Table - 16 Bits - Calculos_files/purple.gif" width="20" height="10">-&gt; cluster 10<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palepurple.gif" width="20" height="10">-&gt; cluster 11<br><img src="./File Allocation Table - 16 Bits - Calculos_files/orange.gif" width="20" height="10">-&gt; cluster 12<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleorange.gif" width="20" height="10">-&gt; cluster 13<br><img src="./File Allocation Table - 16 Bits - Calculos_files/grey.gif" width="20" height="10">-&gt; cluster 14<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palegrey.gif" width="20" height="10">-&gt; cluster 15</td></tr></tbody></table></td></tr></tbody></table><hr width="544" size="1" align="center"><table width="98%" border="0" cellspacing="0" cellpadding="0" align="center"><tbody><tr><td align="center"><img src="./File Allocation Table - 16 Bits - Calculos_files/fat.gif" width="544" height="70"><br><table width="546" border="0" cellspacing="0" cellpadding="3"><tbody><tr><td width="50%" align="left" valign="top"><img src="./File Allocation Table - 16 Bits - Calculos_files/darkblue.gif" width="20" height="10">-&gt; media type<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleblue.gif" width="20" height="10">-&gt; partition state<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palegreen.gif" width="20" height="10">-&gt; 1st of a 6 cluster entry<br><img src="./File Allocation Table - 16 Bits - Calculos_files/purple.gif" width="20" height="10">-&gt; 3 cluster entry<br><img src="./File Allocation Table - 16 Bits - Calculos_files/green.gif" width="20" height="10">-&gt; 2 to 5 of a 6 cluster entry</td><td width="50%" align="left" valign="top"><img src="./File Allocation Table - 16 Bits - Calculos_files/yellow.gif" width="20" height="10">-&gt; 10 cluster entry<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkgreen.gif" width="20" height="10">-&gt; last cluster of 6 entry<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleorange.gif" width="20" height="10">-&gt; available cluster<br><img src="./File Allocation Table - 16 Bits - Calculos_files/red.gif" width="20" height="10">-&gt; 2 bad clusters</td></tr></tbody></table></td></tr></tbody></table><hr width="580" size="1" align="center">fat in general<br><br>the file allocation tables (fat) are positioned between the boot record and the root directory. there are normally two identical copies made of the fat; fat1 and fat2; designed to try and prevent storage errors when disks were less reliable. the smallest size fat16 seems to be 256*512bytes<br><hr width="580" size="1" align="center">media type ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkblue.gif" width="20" height="10"><br><br>the first 2 bytes of fat16 state the media type; f8 = hard disk; floppy disks are f0; this value must match up with the media type stated in the boot record.<br><hr width="580" size="1" align="center">partition state ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/paleblue.gif" width="20" height="10"><br><br>set to ff,ff at format and at shut down; it means that the partition is "clean" not mounted or hasn't been written to. browsing the directories, getting properties and opening files will not mount the disk; even if the last accessed date is updated, the disk will not be mounted. however if data or an entry is rename or saved these two bytes will change to ff,f7 indicating that the partition is "dirty" mounted or in use. if a system starting up finds that the partition is still mounted, it will know that the system did not shut down properly and may run scandisk. this only applies to hard disks. jon fox informs me that this section is also used to indicate if an hardware error occurred - i was unable to verify this ;-)<br><hr width="580" size="1" align="center">fat attributes ( varies in size ) <img src="./File Allocation Table - 16 Bits - Calculos_files/palegreen.gif" width="20" height="10"> <img src="./File Allocation Table - 16 Bits - Calculos_files/purple.gif" width="20" height="10"> <img src="./File Allocation Table - 16 Bits - Calculos_files/green.gif" width="20" height="10"> <img src="./File Allocation Table - 16 Bits - Calculos_files/yellow.gif" width="20" height="10"> <img src="./File Allocation Table - 16 Bits - Calculos_files/darkgreen.gif" width="20" height="10"> <img src="./File Allocation Table - 16 Bits - Calculos_files/paleorange.gif" width="20" height="10"> <img src="./File Allocation Table - 16 Bits - Calculos_files/red.gif" width="20" height="10"><br><br>data clusters starts at cluster 2 right after the root directory. on fat16 one cluster represented by 2 bytes in the fat. 2bytes-&gt;16bits-&gt;fat16 - fat32 uses 4 bytes. each 2 bytes in the fat mark a position in the data area of the partition. if the cluster is part of chain of clusters; occupying more than one cluster, they will be numbered in hex order. the numbers range from 03,00 to 99,ff; adding from the left. if the cluster is the last in the chain or if the entry only takes up one cluster it will be marked as ff,ff. if a file is resaved and it exceeds its allocated cluster, the file or directory list will be split onto two, and the extra clusters located elsewhere on the drive. the fat will be changed so that the last cluster in the first chain will point to the start of the next cluster chain. in the diagram above the first cluster points to cluster 6, (though labeled as 07,00 it is cluster 6). this is known as fragmenting, and can slow the system down a little as these pieces need to be reassembled before use. defragmenting will move the data around so that all the chains of clusters are grouped together. if there is no data stored or data has been deleted the fat will be marked as 00,00. sometimes the system cannot keep up with this; if a 20 cluster entry is deleted and then a new 5 cluster one created the data maybe located after the blank entries of the deleted 20 cluster one. a reboot maybe required for the area to be acknowledged. if the fat entries do not completely fill the last sector of the fat the remaining space will be left empty and scandisk will not check it. bad clusters are marked with f7,ff. data will not be written to these areas and a thorough scandisk will not recover these clusters, only report that they are there. data can be hidden in phoney bad clusters, such program needs to keep track of where the data is stored and replace certain fat entries and the data "disappears"</td></tr></tbody></table></td></tr><tr><td colspan="2"><table width="596" border="0" cellspacing="0" cellpadding="5" bgcolor="#f0f0f0"><tbody><tr><td>data entry diagram<br><br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tbody><tr><td align="center"><img src="./File Allocation Table - 16 Bits - Calculos_files/entry.gif" width="544" height="150"><br><table width="546" border="0" cellspacing="0" cellpadding="3" height="63"><tbody><tr><td width="50%" align="left" valign="top" height="1"><img src="./File Allocation Table - 16 Bits - Calculos_files/orange.gif" width="20" height="10">-&gt; ordinal field<br><img src="./File Allocation Table - 16 Bits - Calculos_files/blue.gif" width="20" height="10">-&gt; unicode long file name<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleturquoise.gif" width="20" height="10">-&gt; longfile name attribute<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palegrey.gif" width="20" height="10">-&gt; reserved for future use<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkblue.gif" width="20" height="10">-&gt; dos name check sum<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleyellow.gif" width="20" height="10">-&gt; lfn data location<br><img src="./File Allocation Table - 16 Bits - Calculos_files/paleblue.gif" width="20" height="10">-&gt; dos file name<br><img src="./File Allocation Table - 16 Bits - Calculos_files/turquoise.gif" width="20" height="10">-&gt; entry attributes<br><img src="./File Allocation Table - 16 Bits - Calculos_files/grey.gif" width="20" height="10">-&gt; nt reserved </td><td width="50%" align="left" valign="top" height="1"><img src="./File Allocation Table - 16 Bits - Calculos_files/darkpurple.gif" width="20" height="10">-&gt; create time<br><img src="./File Allocation Table - 16 Bits - Calculos_files/palepurple.gif" width="20" height="10">-&gt; create date<br><img src="./File Allocation Table - 16 Bits - Calculos_files/green.gif" width="20" height="10">-&gt; access date<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkgreen.gif" width="20" height="10">-&gt; access time<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkred.gif" width="20" height="10">-&gt; modified time<br><img src="./File Allocation Table - 16 Bits - Calculos_files/red.gif" width="20" height="10">-&gt; modified date<br><img src="./File Allocation Table - 16 Bits - Calculos_files/yellow.gif" width="20" height="10" border="0">-&gt; data location<br><img src="./File Allocation Table - 16 Bits - Calculos_files/darkorange.gif" width="20" height="10" border="0">-&gt; data length </td></tr></tbody></table></td></tr></tbody></table><hr width="580" size="1" align="center">entries in general<br><br>entries are made up of 32 bytes. if the entry is deleted the first byte is changed to e5; and the sectors are marked as free. basic computer forensics can reveal alot because of this. if this is a risk, check <a href="http://www.fortunecity.com/skyscraper/true/882/Comparison_Shredders.htm" target="_blank">http://www.fortunecity.com/skyscraper/true/882/Comparison_Shredders.htm</a> for prevention programs. defraging the disk will compress the directory entries and clear any redundent ones; it will also rearrange the data so that it is grouped together, but old data will still be there. if the first byte is 00, entries are considered to have ended for that directory.<br>_be aware of that_<br><hr width="580" size="1" align="center">ordinal fields ( =1 byte - every 32 bytes of the lfn) <img src="./File Allocation Table - 16 Bits - Calculos_files/orange.gif" width="20" height="10"><br><br>the first byte of each 32 byte string of the long file name is called the ordinal field. it tells the system which order the entries are to be read in. this is in hex and read from 01. the first byte of the _entire_ entry however is different, it defines the length of the total lfn entry.<br>from the root dir:<br><br><table width="495" border="0" cellspacing="0" cellpadding="0" align="center" bgcolor="#000000"><tbody><tr><td><table width="495" border="0" cellspacing="1" cellpadding="0" bgcolor="#000000"><tbody><tr><td width="62"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">letter</td></tr></tbody></table></td><td width="210"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">the long file name's...</td></tr></tbody></table></td><td width="219"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">no. of 16 byte lines/size</td></tr></tbody></table></td></tr><tr><td width="62"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">a/41<br>b/42<br>c/43<br>d/44<br>e/45<br>f/46<br>g/47<br>h/48<br>i/49<br>j/4a<br>k/4b<br>l/4c<br>m/4d<br>n/4e<br>o/4f<br>p/50<br>q/51<br>r/52<br>s/53<br>t/54</td></tr></tbody></table></td><td width="210"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">length is &gt;=001 &amp; &lt;=013<br>length is &gt;=014 &amp; &lt;=026<br>length is &gt;=027 &amp; &lt;=039<br>length is &gt;=040 &amp; &lt;=052<br>length is &gt;=053 &amp; &lt;=065<br>length is &gt;=066 &amp; &lt;=078<br>length is &gt;=079 &amp; &lt;=091<br>length is &gt;=092 &amp; &lt;=104<br>length is &gt;=105 &amp; &lt;=117<br>length is &gt;=118 &amp; &lt;=130<br>length is &gt;=131 &amp; &lt;=143<br>length is &gt;=144 &amp; &lt;=156<br>length is &gt;=157 &amp; &lt;=169<br>length is &gt;=170 &amp; &lt;=182<br>length is &gt;=183 &amp; &lt;=195<br>length is &gt;=196 &amp; &lt;=208<br>length is &gt;=209 &amp; &lt;=221<br>length is &gt;=222 &amp; &lt;=234<br>length is &gt;=235 &amp; &lt;=247<br>length is &gt;=248 &amp; &lt;=250</td></tr></tbody></table></td><td width="219"><table width="100%" border="0" cellspacing="0" cellpadding="2" bgcolor="#f0f0f0"><tbody><tr><td align="center">02 lines 032 bytes/020<br>04 lines 064 bytes/040<br>06 lines 096 bytes/060<br>08 lines 128 bytes/080<br>10 lines 160 bytes/0a0<br>12 lines 192 bytes/0c0<br>14 lines 224 bytes/0e0<br>16 lines 256 bytes/100<br>18 lines 288 bytes/120<br>20 lines 320 bytes/140<br>22 lines 352 bytes/160<br>24 lines 384 bytes/180<br>26 lines 416 bytes/1a0<br>28 lines 448 bytes/1c0<br>30 lines 480 bytes/1e0<br>32 lines 512 bytes/200<br>34 lines 544 bytes/220<br>36 lines 576 bytes/240<br>38 lines 608 bytes/260<br>40 lines 640 bytes/280</td></tr></tbody></table></td></tr></tbody></table></td></tr></tbody></table><br>the 32 byte blocks are positioned in reverse order with the last section at the beginning of the entire entry.<br><hr width="580" size="1" align="center">the long file name <img src="./File Allocation Table - 16 Bits - Calculos_files/blue.gif" width="20" height="10"><br><br>the name is stored in unicode format. a double byte character system designed to handle all possible foreign and scientific characters. the orginal ascii characters are the same except they are two bytes in size, the second byte is a null; 00. check <a href="http://www.unicode.org/" target="_blank">http://www.unicode.org</a> for a more in depth explaination. there can be up to 13 unicode characters per 32 byte section. if however the long file name does not fill the slot exactly a unicode null (00,00) will be added to the end, followed by ff,ff's until the section is filled. note that entries do not have to have a lfn.<br><br>as you can see from the table above a long file name in the root directory can be between 1 and 250 characters. this is alittle odd as there is still space for 10(?) more characters, also stated by microsoft that files could have upto 255 characters. total path length; tpl refered to in this text is the character length from the drive letter to the folder or file, eg: "c:\new folder" has a tpl of 13. "c:\new folder\test.dat" has a tpl of 22. a large tpl can have strange effects on explorer. a single folder in c:\ can have a tpl of 253 (250 + c:\) it can only contain files &lt;= 4 characters in length. however if there are two folders the tpl can be up to 255, with 2 remaining for files. the maximum valid tpl for 98f16 including a file is 258. note that this value can change alittle, eg one character folders; c:\a\a\a\...etc (122 folders; maximum) can have a tpl length of 254, including 7 for a file; and even this can change, if you paste a file in it can be up to 12 characters for a file. why this varies is unclear. explorer checks the tpl on entry creation to see that it does not exceed an illegal value, however it only checks it up to that point. thus two folders could be created, and the first one renamed to a longer length so that when the subfolder is accessed the tpl is greater than allowed. while a tpl of such length will have stange effects on the system eg, inaccessable, unviewable, unmoveable, undeleteable, false properties of files and folders; scandisk will fix them by either renaming the affected files or folders and/or moving them to the root directory. one combination is of note. create a folder in the root directory with a name of 1 character, save a file of 5 characters in length into the folder, rename the folder so it has 250 characters in the name. tpl is 259. properties are correct for the file and it can be opened and resaved to the same location, however it cannot be moved out of that folder nor renamed or deleted, to do so the foldername must be shortened. this doesn't stop the file being opened and resaved to a different location. scandisk doesn't seem to mind this combination.<br><br>not all ascii (unicode) characters can be used in long file names. names cannot contain the following characters: \/:*?"&lt;&gt;| if the name begins with a space it will be removed, if a fullstop - prompt for a valid name. if the name ends with a fullstop or spaces they will be removed. letters from the extended character set can cause some confusion of explorer in 9x/me systems. the following acsii characters inclusively are of note in 9x: 158, 169, 176-&gt;224, 226-&gt;229, 231-&gt;240, 242-&gt;245, 247, 249, 251-&gt;252 and 254-&gt;255; 75 characters. in me: 176-&gt;180, 185-&gt;188, 191-&gt;197, 200-&gt;206, 213, 217-&gt;220, 223, 242 and 254; 31 characters. if a folder contains any of this characters you cannot access it via explorer; it errors with "the folder 'path' doesn't exist" twice. properties are displayed incorrectly. copying and deletion attempts result in "cannot delete file file system error (1026)." explorer will prevent the entering of these characters by turning them in the underscore. they can be entered in a dosbox. check numlock is on; normally by default, then press alt+type the number on the keypad - laptops normally alt+fn+no. if a file has these characters in, when opened it will prompt "cannot find the 'path\file' do you want to create a new file?" clicking no creates an untitled blank document. clicking yes creates a new blank file, but with the illegal character an underscore in the name - resave it. now, and this is quite interesting; when opening or deleting the illegal file, it will open/delete the one with the underscore in. this means that explorer, on finding a entry with a character in that it cannot handle, scans the current directory for one of the same name, but with an underscore in. folders can also be "redirected" this way and the underscore named entry will be opened with internet explorer. scandisk doesn't seem to mind this.<br><br>some whole words are also a problem. you cannot create directories or files of the following names: aux, con, nul, prn, com1, com2, com3, com4, lpt1, lpt2, lpt3, lpt4, lpt5, lpt6, lpt7, lpt8, lpt9, clock$ and config$ in total, 19 words. it will error with either: unable to create directory or cannot rename thefilename: access is denied. it seems that these values, reserved hardware device/port names, may already be in use by the operating system - they are mentioned in the io.sys. attempts to access a folder with a subfolder of both the same reserved name will crash/freeze the system for: aux\aux, con\con, nul\nul, clock$\clock$ and config$\config$. the others will result in the error: invalid directory. you cannot create files or folders in windows of these reserved words, but you can change them with a hexeditor on the disk, most result in either errors, instant freezing/crashing of the system and nondeletable, noncopiable or inaccessable entries in explorer. a lot of these entries' properties are reported as 112bytes. scandisk will rename most reserved names with a hyphen on the end. however scandisk does seem to mind the following names: lpt4 to lpt9. the names have to be in uppercase or scandisk will error and fix to uppercase. the folder 'path' does not exist error appears twice on attempted access; files cannot be opened. cannot delete file: file system error (1026). properties report the folder as a file of zero bytes. cannot copy file: file system error (1026) note that these may vary as hardware configurations may be different.<br><hr width="580" size="1" align="center">lfn attributes and location <img src="./File Allocation Table - 16 Bits - Calculos_files/paleturquoise.gif" width="20" height="10"> <img src="./File Allocation Table - 16 Bits - Calculos_files/paleyellow.gif" width="20" height="10"><br>( = 1 byte and 2 bytes respectfully; every 32 byte section of the lfn )<br><br>entire entries are read in as 32 byte blocks. to ensure compatiblity with older systems, when they introduced long file names, each section of a long file name had to "pretend" to be an entire entry. to do this the entry attribute and data location are set to the "impossible values" of 0f and 00,00 respectfully. each 32 byte section of the long file name is required to have this slotted in.<br><hr width="580" size="1" align="center">lfn reserved ( =1 byte - every 32 bytes of the lfn ) <img src="./File Allocation Table - 16 Bits - Calculos_files/palegrey.gif" width="20" height="10"><br><br>set to 00 at entry creation. it is reserved for future use; however copying or renaming a file/folder resets it to 00. resaving a file retains any changed values.<br><hr width="580" size="1" align="center">dos name checksum ( =1 byte - every 32 bytes of the lfn ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkblue.gif" width="20" height="10"><br><br>this is for checking that the dos name and the long file name match up correctly. if this value is incorrect, the lfn will be discarded and the dos name subsituted.<br><br>the steps are:<br><br>1. take the ascii value of the first character. this is your first sum<br>2. rotate all the bits of the sum rightward by one bit<br>3. add the ascii value of the next character with the value from above. this is <br>&nbsp;&nbsp;&nbsp;your next sum<br>4.&nbsp;repeat steps 2 through 3 until you are all through with the 11 characters in<br>&nbsp;&nbsp;&nbsp;the 8.3 filename<br><br>note that spaces (ascii value 20) are also included.<br><br>to calculate manually use calc.exe; view scientific, switch to hex mode and select the byte radiobutton under the display.<br><br>dosname: UNTITLEDTXT - lfn checksum: 44<br>in this section "-&gt;" means rotate all the bits, one bit to the right.<br><br>U = 55 = 0101 0101 -&gt; 1010 1010 = AA<br>N = 4E + AA = F8 = 1111 1000 -&gt; 0111 1100 = 7C<br>T = 54 + 7C = D0 = 1101 0000 -&gt; 0110 1000 = 68<br>I = 49 + 68 = B1 = 1011 0001 -&gt; 1101 1000 = D8<br>T = 54 + D8 = 2C = 0010 1100 -&gt; 0001 0110 = 16<br>L = 4C + 16 = 62 = 0110 0010 -&gt; 0011 0001 = 31<br>E = 45 + 31 = 76 = 0111 0110 -&gt; 0011 1011 = 3b<br>D = 44 + 3b = 7f = 0111 1111 -&gt; 1011 1111 = bf<br>T = 54 + bf = 13 = 0001 0011 -&gt; 1000 1001 = 89<br>X = 58 + 89 = e1 = 1110 0001 -&gt; 1111 0000 = f0<br>T = 54 + f0 = 44<br><hr width="580" size="1" align="center">dos file name ( =11 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/paleblue.gif" width="20" height="10"><br><br>dos names can be &gt;=1 and &lt;=11 characters. any remaining bytes will be filled with spaces. if the entry also has a long file name attached the dos name is changed slightly. the name is shortened to 6 characters and a tilde~ and number are added to the end, giving a total of 8 characters. if the first 6 letters are different from all other dos names in that directory then the ending is ~1 however if they are the same the ending number will be different. the system scans the dos names in that directory for the lowest available ending number to use, incrementing by 1 (decimal) as needed. when ~10 is reached the dos name is reduced to 5 characters to make room. if a file is copied to a different directory the dos name and long file name checksum may change, as the system checks both dos and long file names already in use. process referred to in this text as tilded. the last three letters of a dos name are considered the file extension and will be divided off from the rest by a space or a fullstop. all letters are converted to uppercase. if an entry has its dos name converted to lowercase it can cause problems. while files handle okay, attempts to open a folders results in the error: c:\folder is not accessible. this folder was moved or removed. in a dosbox the result is path not found and the volume serial number and name are displayed, it can however be deleted, in dos or explorer. scandisk will fix this by converting back to uppercase. if the name contains spaces, they will be removed and the name tilded. if the name contains a fullstop, upto the first three letters thereafter are considered the extension. if the extension is more than three letters, just the first three will be used plus the name is tilded. if the name contains more than one fullstop the last one is used as the divide between the name and extension. all other fullstops are removed and the name is tilded.<br><br>lfn names cannot contain the following characters: \/:*?"&lt;&gt;| some can be attempted to be used in dos, but they have strange effects. tested in a dosbox; file creator is "copy con filename" typed text "crtl + z","enter"<br>\ creation: path not found; rename: invalid parameter<br>/ creation: invalid switch; rename: anything after and including the forward slash will be removed<br>: creation: to many parameters; rename: file not found<br>* creation: anything after and including the asterisk; but not the extension will be removed. * is a wildcard<br>? creation: the question mark is removed; rename: either the question mark will be substituted for an other letter or it will be removed; how it substitutes is unclear. ? like * is a wildcard<br>" creation: the double quotation mark is removed; rename: as creation<br>&lt; creation: file not found; rename: as creation<br>&gt; creation: splits into two different file at the greater-than sign. the first half contains the text, while the second contains the following text: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 file(s) copied" - the confirmation that appears after the text is saved; rename: as creation, but the second half contains nothing as there isan't a confirmation on rename. the &gt; character pushes screen output to "somewhere" as shown in the example above a file. &gt;&gt; appends to "wherever"<br>| creation: anything after and including the vertical bar will be removed, also on save the message bad command or file name appears; rename: as creation. the | can be used to "pipe" instructions eg: echo y|del *.* &gt;nul will quietly delete all files in the current directory (hidden, readonly and system attribute file are not deleted)<br><hr width="580" size="1" align="center">entry attributes ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/turquoise.gif" width="20" height="10"><br><br>documented attribute values<br>none: 00<br>archive: 20<br>read-only: 01<br>system: 04<br>hidden: 02<br>directory: 10<br>volume: 28 (hdd)<br><br>if attribute = 00 then its treated as a file.<br><br>for archive, hidden and system attributes; add the values together: 26<br><br>archive and directory *can* also be unoffically stated as other values. read in the first nybble and convert it to decimal. if its divisible by 2 its an archive, else its a folder.<br><br>if the second nybble is &gt;=8 and &lt;=e the entry disappears and becomes the volume name. the volume attribute should only be stated once on the partition, offset 15h. sometimes there will be an entry already in root that will override this. this is valid if the entry has no data attached, else scandisk will delete and recover any clusters. n.b: volumes are archives; if stating it in the root (this will only work in root) so f8 is invalid here. there can only be one valid entry in the root that can have the volume attribute.<br><br>if the second nybble is =f the entry disappears completely, however its still a volume. scandisk will error if there is data attached, and delete any data.<br><br>volumes can labelled &lt;=11 characters from explorer, however you can increase the length by saving an entry in the root directory and changing its attributes to a volume, this can have some interesting effects. volume names &gt;=12 and &lt;=32 will prevent renaming of the label via explorer even though the text field will be editable. error: access denied. &gt;=33 the label will be greyed out and uneditable. volume names of &gt;=78 will cause illegal operation errors and not enough available memory errors on attempted format in explorer. volume names of &gt;=83 will cause scandisk to crash in a similar way, and reboot maybe needed even if the volume attribute is removed. all values above these have not been tested, but are believed to be the same. partitions can still be formatted in dos/dosbox.<br><hr width="580" size="1" align="center">ntreserved ( =1 byte ) <img src="./File Allocation Table - 16 Bits - Calculos_files/grey.gif" width="20" height="10"><br><br>set to 00 at entry creation and never modified or checked thereafter.<br>reserved for windows nt. copying the file resets the attribute, but renaming doesn't.<br><hr width="580" size="1" align="center">create time ( =3 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkpurple.gif" width="20" height="10"><br><br>minimum time: 00:00:00 = 00 00 00 if zero, no time in properties<br>maximum time: 23:59:59 = 64 7D BF<br>how it calculates it:<br>the values on the disk are: 64,90,a6 and properties: 8:52:33pm<br>first flip the bytes: 64,90,a6 -&gt; a6,90,64<br>convert to binary: a6,90,64 -&gt; 10100110,10010000,01100100<br>divide up the sections and convert back to decimal: (from left to right)<br>(5bits;hour) 10100 -&gt; = 20hrs (24hr) or - 12 = 8pm<br>(6bits;mins) 110100 -&gt; = 52 minutes<br>(5bits;secs) 10000 -&gt; 16; * 2 = 32 seconds<br>(8bits;mili) 01100100 -&gt; = 100 milliseconds<br>if millisecs &gt;=000 and &lt;=099; seconds is correct + no. of milliseconds<br>if millisecs &gt;=100 and &lt;=199; seconds + 1 = seconds + no. of milliseconds<br>if millisecs &gt;=200; seconds + 2 = seconds (etc) but its considered invalid<br>which gives 33 seconds exactly: 8:52:33pm<br>invalid times such as 2600hours simply roll fowards to become 0200hours in properties, scandisk does not error.<br><hr width="580" size="1" align="center">create date ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/palepurple.gif" width="20" height="10"><br><br>minimum date: 1/1/1980 = 21 00<br>maximum date: 2/7/2106 = 46 FC<br>how it calculates it:<br>the values on the disk are: 14,2b and properties: 20th august 2001<br>first flip the bytes: 14,2b -&gt; 2b,14<br>convert to binary: 2b,14 -&gt; 00101011,00010100<br>divide up the sections and convert back to decimal: (from left to right)<br>(7bits;yr) 0010101 -&gt; 21; + 1980 = 2001<br>(4bits;mt) 1000 -&gt; = 8 or august<br>(5bits;dy) 10100 -&gt; = 20th<br>20th august 2001<br>invalid dates such as the 31st of september simply roll forwards to the 1st of october in properties, scandisk does not error.<br><br>the last possible create date and time is:<br>sunday, february 07, 2106 7:28:15am anything beyond = (unknown)<br>the create date and time seem to be handled together though they are separate entries.<br><hr width="580" size="1" align="center">access date ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/green.gif" width="20" height="10"><br><br>minimum date: 1/1/1980 = 21 00<br>maximum date: 2/7/2106 = 46 FC<br>this date is highly changeable, just right clicking on it will reset to current date, however it can be correctly querried programatically.<br>this is calculated the same way as the modified date (see above)<br><hr width="580" size="1" align="center">access time ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkgreen.gif" width="20" height="10"><br><br>minimum/maximum: 00 00<br>this is a strange entry, it has to be 00 00, if you change it manually, windows changes it back if you view the properties of the file, or if you resave it. therfore you can only get access properties to the day.<br><hr width="580" size="1" align="center">modifed time ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkred.gif" width="20" height="10"><br><br>00:00:00 = 00 00 if zero, no time in properties<br>23:59:58 = 24 28<br>this is calculated the same way as the modified time (see above) except that it does not have the same accuracy; one less byte. thus the modified time is to the nearest 2 seconds.<br><br>the last possible modified date and time is:<br>sunday, february 07, 2106 7:28:14am<br><hr width="580" size="1" align="center">modified date ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/red.gif" width="20" height="10"><br><br>minimum date: 1/1/1980 = 21 00<br>maximum date: 2/7/2106 = 46 FC<br>this is calculated the same way as the modified date (see above)<br><hr width="580" size="1" align="center">data location ( =2 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/yellow.gif" width="20" height="10" border="0"><br><br>the minimum can be 00 - 0 and the maximum ff - 65535<br>the correct value will point the os to the starting cluster of the data.<br>eg, 03 00<br>flip these values: 00 03<br>convert to decimal: 3<br>data starts at the beginning of the third cluster.<br><br>if an entry points to the same cluster they are said to be cross-linked, this is of note regarding folders. foldernames mentioned are only for reference. create a folder in root called folder1, create a subfolder within called folder2. change the location of folder2 to 00. attempts to access folder2 result in explorer looping back to root. scandisk will error and the fix is to move/recover folder2 and its contents to the root directory. scandisk can get a little muddled if you create a subfolder within folder2 called folder3 and point the location of folder3 to folder2. the default fix is to give each file a separate copy of the shared cluster(s) if this is attempted scandisk will loop at each attempt, and any data in folder3 maynot be recovered. there are, however other fix options available which will recover the data, though some directories maybe undeletable due to an exceeded total path length, just shorten the folder name.<br><hr width="580" size="1" align="center">data length ( =4 bytes ) <img src="./File Allocation Table - 16 Bits - Calculos_files/darkorange.gif" width="20" height="10" border="0"><br><br>the minimum can be 00 00 00 00 - 0 and the maximum ff ff ff ff -<br>&nbsp;4,294,967,295<br>gb, mb, kb, by<br><br>this entry will state the length of data to read in.<br>eg, AC 3B 96 00<br>flip these values: 00 96 3B AC<br>convert to decimal: 9,845,676 bytes or 9.38MB<br>folders have a value of: 00 00 00 00<br><br>the maximum is restricted by the size of the partition. the largest partition creatable by fdisk for fat16 is 2047.31mb (2,146,765,824 bytes) entry stated as 00,80,f0,7f. the largest file creatable in this partition is 1.99gb (2,146,467,840 bytes). not all the data area is filled, 18,944 bytes of surplus sectors were left empty at the end.<br><hr width="580" size="1" align="center">subdirectories ( =64 bytes )<br><br> at the beginning of all directories (not root) there will be two folder entries of total 64 bytes before the list of files or folders within that directory. they are dot and dotdot and are visable in dos. dot is the current folder and dotdot is the parent folder. each entry will have the following properties: a dos name of either dot or dotdot; attributes of a folder; the create, access, modified date and time, though only the modified date and time are required; the cluster location of the folder, dot will be the same as the current folder and dotdot will be the same as the parent folder or 00 if root; and a data length of zero. also these entries have to be at the beginning of the directory list. a three dot entry is not valid even though you can change to two folders up. you can add more entire "dot" entries without scandisk erroring, on the condition that the dos name, the directory attribute, the cluster location matchup and the data length is zero. these extra entries will also not be visable in explorer and they do not have to be at the beginning of the directory list. folders seem to handle okay without the dot and dotdot entries and the system doesn't check the location values when changing directory.<br><br>the root directory in fat16 is a fixed at 16,384 bytes in size. in total: 512 dosname entries of 32bytes or 256, 64byte entries with a lfn of upto 13 characters. if the maximum lfn entry is used, a maximum of 24 entries can be listed in the root directory with 256 bytes remaining. at this point errors will occur if any entries are attempted to be added or lengthen. entrycopy: "cannot copy thefile: the directory or file cannot be created." entryrename: "cannot rename thefile: access is denied. make sure the disk is not full or write-protected and that the file is not currently in use."<br><br>subfolders can have many entries. when a subfolder is created, 1 cluster is set aside for entries. when this is exceeded the directory list extends into another cluster, usually one is not avaiable right after the first section, as a result directory lists get fragmented accross the drive.</td></tr></tbody></table></td></tr><tr><td colspan="2"><table border="0" cellspacing="0" cellpadding="0" bgcolor="#f0f0f0" height="23" width="100%"><tbody><tr><td valign="middle" align="center"><font color="#FF0000">you must get permission from the respective author before reproduction</font></td></tr></tbody></table></td></tr></tbody></table></td></tr></tbody></table><br></body></html>