
.386P   																

STACK16SIZ 		EQU 1024
STACK32SIZ 		EQU 1024

DESC STRUCT   				;DEFINE OUR DESCRIPTOR STRUCTURE
	LIMIT_LO 	DW ?    	;LIMIT BITS 15-0
	BASE_LO 	DW ?     	;BASE BITS 15-0
	BASE_MID 	DB ?    	;BASE BITS 23-16
	TYPE1 		DB ?       	;TYPE OF SELECTOR
	LIMIT_HI 	DB ?    	;LIMIT BITS 19-16 AND OTHER INFO
	BASE_HI 	DB ?     	;BASE BITS 31-24
DESC ENDS

;FIRST DEFINE ALL SEGMENTS THAT WILL BE NEEDED

CODE16SEG SEGMENT USE16 'CODE'
CODE16SEG ENDS

DATA16SEG SEGMENT USE16
DATA16SEG ENDS

CODE32SEG SEGMENT USE32 'CODE'
CODE32SEG ENDS

DATA32SEG SEGMENT USE32
DATA32SEG ENDS

STACK16SEG SEGMENT USE16 STACK
	DB 				STACK16SIZ DUP (?)
	TOS16 			EQU $   	;TOP OF STACK
STACK16SEG ENDS

STACK32SEG SEGMENT USE32 'STACK'
	DB 				STACK32SIZ DUP (?)
	TOS32 			EQU $   	;TOP OF STACK
STACK32SEG ENDS

;PUT ALL SEGMENTS IN ONE
SEGS16 GROUP CODE16SEG,DATA16SEG,STACK16SEG
SEGS32 GROUP CODE32SEG,DATA32SEG,STACK32SEG

ASSUME CS:SEGS16,DS:SEGS16,SS:SEGS16,ES:NOTHING

DATA16SEG SEGMENT USE16  	;START DEFINING OUR 16BIT DATA

	;DEFINE OUR GDTR
	GDTR 			LABEL FWORD
	GDT_LIMIT 		DW GDT_SIZE-1
	GDT_ADDR 		DD ?
	
	;DEFINE OUR IDTR
	IDTR 			LABEL FWORD
	IDT_LIMIT 		DW IDT_SIZE-1
	IDT_ADDR 		DD ?
	
	;DEFINE THE DEFAULT IDTR (THIS IS USED WHILE IN RMODE)
	RM_IDTR 		LABEL FWORD
	DW 3FFH  		;LIMIT
	DD 0     		;ADDR


	GDT_START 		EQU $
	
	NULL 			DESC <0,0,0,0,0,0>
	;THIS IS THE 1ST GDT ENTRY CALLED NULL WHICH WE CAN NOT USE
	
	CODE16 			DESC <0FFFFH,?,?,10011010B,0H,?>
	;LIMIT=64 KBS (THIS IS A 16BIT SEGMENT SO ONLY IP IS USED WHILE RUNNING)
	;BASE=? (THIS WILL BE SETUP LATER IN THE PROGRAM)
	;10011?10B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=1 (CODE)
	;            C=1(CONFORMING), R=1 (READABLE), A=0 (NOT ACCESSED)
	;0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	DATA16 			DESC <0FFFFH,?,?,10010010B,0H,?>
	;LIMIT=64 KBS
	;BASE=? (THIS WILL BE SETUP LATER IN THE PROGRAM)
	;10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	;0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	VID 			DESC <0FFFFH,8000H,0BH,10010010B,0H,0>
	;LIMIT=64 KBS
	;BASE=0B8000H (MAKES IT EASY TO ACCESS VIDEO RAM WHILE IN PMODE-16)
	;10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	;0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	CODE32 			DESC <0FFFFH,?,?,10011010B,11001111B,?>
	;LIMIT=4 GBS (0FFFFH * 4K = 4 GBS)
	;BASE=?
	;     THE BEGINNING OF MEMORY)
	;10011110B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=1 (CODE)
	;            C=1(CONFORMING), R=1 (READABLE), A=0 (NOT ACCESSED)
	;11001111B = LIMIT BITS 19-16=0FH, G=1 (4K GRANULARITY), D=1 (32BIT SEGMENT)
	
	DATA32 			DESC <0FFFFH,?,?,10010010B,11001111B,?>
	;LIMIT=4 GBS
	;BASE=?
	;10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	;11001111B = LIMIT BITS 19-16=0FH, G=1 (4K GRANULARITY), D=1 (32BIT SEGMENT)
	
	ZERO32 			DESC <0FFFFH,0,0,10010010B,11001111B,0>
	;LIMIT=4 GBS
	;BASE=0H (EASY ACCESS TO RMODE MEMORY)
	;10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	;11001111B = LIMIT BITS 19-16=0FH, G=1 (4K GRANULARITY), D=1 (32BIT SEGMENT)
	
	GDT_SIZE 		EQU ($-GDT_START)

	;DEFINE OUR IDT
	IDT_START 		EQU $
	IDT 			DESC 256 DUP (<?,SELCODE16,0,10001110B,0,0>)
	IDT_SIZE 		EQU ($-IDT_START)

	;DEFINE OUR INTRMATRIX
	INTS 			DB 256 DUP (0CCH)       ;THIS IS WHAT EACH OF THE DEFAULT
											;INT DESCRIPTORS PTS TO
											;0CCH = INT 3 (ONE-BYTE OPCODE)
											;SO ALL INTS GOTO THE INT 3 HANDLER
											;WHICH WILL DIRECT THE INT TO RMODE

	;DEFINE OUR SELECTORS AS EQU
	SELCODE16 		EQU (OFFSET CODE16 - GDT_START)
	SELDATA16 		EQU (OFFSET DATA16 - GDT_START)
	SELVID 			EQU (OFFSET VID - GDT_START)
	SELDATA32 		EQU (OFFSET DATA32 - GDT_START)
	SELZERO32 		EQU (OFFSET ZERO32 - GDT_START)
	SELCODE32 		EQU (OFFSET CODE32 - GDT_START)
	SELLDT 			EQU (OFFSET LDT - GDT_START)

	;DEFINE OUR SELECTORS AS DW
	_SELCODE16  	DW SELCODE16
	_SELDATA16  	DW SELDATA16
	_SELVID     	DW SELVID
	_SELDATA32  	DW SELDATA32
	_SELZERO32  	DW SELZERO32
	_SELCODE32  	DW SELCODE32

	;DEFINE OUR RAW SWITCHING ROUTINES
	PM_2_RM 		DD OFFSET PM_2_RM_RX    ;BY DEFAULT OUR SWITCHING ROUTINES
					DD SELCODE16            ;WILL BE FOR RAW/XMS BUT LATER IT MAY
			
	RM_2_PM 		DW OFFSET RM_2_PM_RX    ;BECOME VCPI
					DW SEGS16

	;DEFINE OUR PM 2 RM STACKS
	PM2RM_STKEND 	DW ?       				;LAST AVAIL STACK   (SS)
	PM2RM_STKCUR 	DW ?       				;CURRENT            (SS)
	PM2RM_STKLEN 	DW 80H     				;INCREMENTAL(PARA)  (SP)
	PM2RM_STKS 		DW 8         			;# OF STACKS

	
	PRG_BASE16 		DD ?                    ;SEGS16 * 10H
	PRG_BASE32 		DD ?                    ;SEGS32 * 10H

	OLD_INT15H 		DD ?                    ;OLD RMODE INT 15H HANDLER
	OLD_INT21H 		DD ?                    ;OLD RMODE INT 21H HANDLER

	INT3VECTOR 		DD OFFSET INTS+3
					DD SELCODE16
					
	PICSLAVE  		DB 70H                  ; PIC SLAVE BASE INTERRUPT
	PICMASTER 		DB 8H                   ; PIC MASTER BASE INTERRUPT

	PSP 			DW ?                    ;PROGRAM SEGMENT PREFIX
	
DATA16SEG ENDS

CODE16SEG SEGMENT USE16  ;START THE 16BIT CODE SEGMENT

	START16 PROC                      			;THIS IS WHERE OUR PROGRAM STARTS

		PUSH 	ES                         		;SAVE THE PSP

		CLD

		MOV 	AX, CS
		MOV 	DS, AX         
		MOV 	ES, AX                       	;SET DS=ES=CS
		
		MOV		AX, 3
		INT		10h
	
		POP 	PSP                         	;LOAD PSP FROM STACK

		MOV 	AX, 3515H
		INT 	21H            					;GET INT 15H
		MOV 	WORD PTR[OLD_INT15H+2], ES
		MOV 	WORD PTR[OLD_INT15H+0], BX
		PUSH 	DS
		POP 	ES

		MOV 	AX, 2515H
		MOV 	DX, OFFSET INT15H
		INT 	21H            					;SET INT 15H

		;SETUP SOME OTHER VARIABLES
		XOR 	EAX, EAX
		MOV 	AX, CS
		SHL 	EAX, 4                       	; CONVERT TO LINEAR ADDR
		MOV 	PRG_BASE16, EAX

		XOR 	EAX, EAX
		MOV 	AX, SEGS32
		SHL 	EAX, 4                       	; CONVERT TO LINEAR ADDR
		MOV 	PRG_BASE32, EAX

		;SETUP ALL OUR DESCRIPTORS
		MOV 	EAX, PRG_BASE16
		MOV 	CODE16.BASE_LO, AX
		MOV 	DATA16.BASE_LO, AX
		SHR 	EAX, 16
		MOV 	CODE16.BASE_MID, AL
		MOV 	DATA16.BASE_MID, AL

		MOV 	EAX, PRG_BASE32
		MOV 	CODE32.BASE_LO, AX
		MOV 	DATA32.BASE_LO, AX
		SHR 	EAX, 16
		MOV 	CODE32.BASE_MID, AL
		MOV 	DATA32.BASE_MID, AL

		;SETUP GDT AND IDT BASE
		MOV 	EAX, PRG_BASE16
		ADD 	EAX, GDT_START
		MOV 	GDT_ADDR, EAX
		
		MOV 	EAX, PRG_BASE16
		ADD 	EAX, IDT_START
		MOV 	IDT_ADDR, EAX

		MOV 	PM2RM_STKCUR, 1000 ; BX

		;SETUP IDT
		MOV 	DI, OFFSET IDT
		MOV 	SI, OFFSET INTS
		XOR 	CX, CX
		MOV 	DX, WORD PTR PICSLAVE
		
		I1:
		MOV 	[DI], SI
		TEST 	CL, 0F8H
		JZ 		I2             					;1ST 8 INTS?    (WHY? - BUG!)
		MOV 	BL, CL
		AND 	BL, 0F8H       					;ISOLATE HIGH 5 BITS
		CMP 	BL, DH
		JZ 		I2             					;LOW IRQS?
		
		CMP 	BL, DL
		JZ 		I2             					;HIGH IRQS?
		OR 		BYTE PTR[DI+5], 1   			;SET AS A TRAP GATE
		
		I2:
		ADD 	DI, 8
		INC 	SI
		INC 	CL
		JNZ 	I1
		
		;SETUP OTHER INTS
		MOV 	WORD PTR[IDT+3*8], OFFSET INT3H

		;INSTALL OUR INT 21H HANDLER
		MOV 	AX, 3521H
		INT 	21H            					;GET INT 21H
		MOV 	WORD PTR[OLD_INT21H+2], ES
		MOV 	WORD PTR[OLD_INT21H+0], BX
		PUSH 	DS
		POP 	ES

		MOV 	AX, 2521H
		MOV 	DX, OFFSET INT21H_RM
		INT 	21H            					;SET INT 21H

		;WE ARE NOW READY TO MOVE TO 16BIT PMODE  

		CLI   									;NO MORE IRQS ALLOWED PAST THIS POINT

		LIDT 	[IDTR]
		LGDT 	[GDTR]

		;CLEAR NT AND IOPL
		PUSHF
		MOV 	BP, SP
		AND 	WORD PTR [BP+1], 08FH 			;40H = NT BIT , 30H = IOPL BITS
		POPF 

		;GOTO PMODE!
		MOV 	EAX, CR0
		OR 		AL, 1           				;SET PM BIT
		MOV 	CR0, EAX       					;WE ARE NOW IN 16BIT PMODE
		
		;SETUP A IRETD THAT WILL JUMP INTO OUR 32BIT SEGMENT

		PUSHFD
		PUSH 	DWORD PTR SELCODE32
		PUSH 	DWORD PTR OFFSET START32
		IRETD   								;GOTO 32BIT SEGMENT

	START16 ENDP

;-----------------------------------------------------------------------------

	; PM 2 RM & RM 2 PM   SWITCHING PROC FOR RAW/XMS
	; SAVE/RESTORE PROCS

	PM_2_RM_RX PROC  							;SWITCHES TO RMODE  (RAW/XMS)

		;  AX = NEW DS
		;  CX = NEW ES
		;  DX = NEW SS
		;  BX = NEW SP
		;  SI = NEW CS
		;  DI = NEW IP

		PUSH 	AX   							;SAVE AX
		MOV 	DS, CS:_SELZERO32
		XOR 	EAX, EAX
		MOV 	AX, DX
		SHL 	EAX, 4
		MOVZX 	EBX, BX
		ADD 	EAX, EBX
		PUSHF
		CLI
		POP 	DS:[EAX-2]
		MOV 	DS:[EAX-4], SI
		MOV 	DS:[EAX-6], DI
		POP 	DI    							;POP AX INTO DI
		LIDT 	CS:RM_IDTR
		
		MOV 	AX, SELDATA16
		MOV 	DS, AX
		MOV 	ES, AX
		MOV 	FS, AX
		MOV 	GS, AX
		MOV 	SS, AX
		
		SUB 	EBX, 6   						;MAKE ROOM FOR IRET DATA
		MOV 	ESP, EBX
			
		MOV 	EAX, CR0
		AND 	AL, 0FEH
		MOV 	CR0, EAX     					;NOW IN RMODE
		
		DB 		0EAH
		DW 		$+4, SEGS16
		
		MOV 	SS, DX
		MOV 	DS, DI       					;AX WAS POPED INTO DI
		MOV 	ES, CX
		XOR 	AX, AX
		MOV 	FS, AX
		MOV 	GS, AX
		
		IRET            						;GOTO TARGET ADDR IN REAL MODE
	
	PM_2_RM_RX ENDP

	RM_2_PM_RX PROC  							;SWITCHES TO PMODE FROM RMODE

		;  AX  = NEW DS
		;  CX  = NEW ES
		;  DX  = NEW SS
		;  EBX = NEW ESP
		;  SI  = NEW CS
		;  EDI = NEW EIP

		PUSHFD
		CLI
		PUSH 	AX
		
		LGDT 	CS:GDTR
		LIDT 	CS:IDTR
		
		MOV 	EAX, CR0
		OR 		AL, 1
		MOV 	CR0, EAX
		
		DB 		0EAH
		DW 		$+4, SELCODE16
		
		POP 	DS
		MOV 	ES, CX
		XOR 	AX, AX
		MOV 	FS, AX
		MOV 	GS, AX
		POP 	EAX
		MOV 	SS, DX                       	; LOAD PROTECTED MODE SS:ESP
		MOV 	ESP, EBX
		AND 	AH, 0BFH                     	; SET NT=0 IN OLD EFLAGS
		PUSH 	AX                         		; SET CURRENT FLAGS
		POPF
		PUSH 	EAX                        		; STORE OLD EFLAGS
		PUSH 	ESI                        		; STORE PROTECTED MODE TARGET CS
		PUSH 	EDI                        		; STORE PROTECTED MODE TARGET EIP
		IRETD                           		; GO TO TARGED ADDX IN PROTECTED MODE
	
	RM_2_PM_RX ENDP

	SR_STATE_RX PROC
		RETF   									;NOTHING TO SAVE/RESTORE
	SR_STATE_RX ENDP

	;THIS PROC WAS COPIED ALMOST DIRECTLY FROM PMODE V3.07 - WHY REINVENT THE
	;WHEEL?
	INT3H PROC

		MOV 	[ESP+8], EAX                    ; STORE EAX FOR LATER POPAD
		MOV 	EAX, [ESP]                      ; GET ADDRESS IN REDIRECTION MATRIX
		ADD 	ESP, 8                          ; DISCARD EIP AND CS FROM INT 3
		PUSH 	ECX                             ;-+
		PUSH 	EDX                             ; |
		PUSH 	EBX                             ; |
		PUSH 	ESP                             ; |
		PUSH 	EBP                             ; |
		PUSH 	ESI                             ; |
		PUSH 	EDI                             ;STORE REST OF REGISTERS FOR POPAD
		PUSH 	DS                              ;-+
		PUSH 	ES                              ; |
		PUSH 	FS                              ; |
		PUSH 	GS                              ;STORE ALL SEGMENT REGISTERS

		MOV 	DS, CS:_SELZERO32               ; DS -> 0 (BEGINNING OF MEMORY)
		MOV 	EDI, CS:PRG_BASE16              ; EDI = OFFSET OF SEGS16 FROM 0

		MOV 	DX, CS:PM2RM_STKCUR             ; DX = SS FOR REAL MODE REDIRECTION
		XOR 	EBP, EBP                        ;-+
		MOV 	BP, DX                          ; |
		SHL 	EBP, 4                          ; EBP -> TOP OF REAL MODE STACK
	
		MOV 	BX, CS:PM2RM_STKLEN             ; GET SIZE OF REAL MODE STACK
		SUB 	DX, BX                          ; ADJUST DX TO NEXT STACK LOCATION
		SUB 	DS:PM2RM_STKCUR[EDI], BX        ; UPDATE PTR FOR POSSIBLE REENTERANCY
		SHL 	BX, 4                           ; SET REAL MODE SP TO TOP OF STACK
	
		CMP 	DX, CS:PM2RM_STKEND             ; EXCEEDED REAL MODE STACK SPACE?
		JZ 		CRITICAL_ERROR                  ; IF YES, CRITICAL ERROR (HANG)

		MOV 	DS:[EBP-2], SS                  ; STORE SS:ESP ON REAL MODE STACK
		MOV 	DS:[EBP-6], ESP
	
		SUB 	AX, OFFSET INTS+1               ; AX = INT NUMBER
												; THE +1 IS BECAUSE THE NEXT INSTRUCT
												; TO RETURN TO IS AFTER THE ONE-BYTE
												; INT 3 OPCODE
		MOV 	AH, AL                          ;-+
		AND 	AH, 0F8H                        ; AH = HIGH 5 BITS OF INT NUMBER
	
		CMP 	AH, CS:PICSLAVE                 ; HIGH IRQ?
		JZ 		REDIR_IRQ                       ; IF YES, DO IRQ
		CMP 	AH, CS:PICMASTER                ; LOW IRQ?
		JNZ 	REDIR_INT                       ; IF NO, DO INT (WITH GENERAL REGS)
		
		;-----------------------------------------------------------------------------
		REDIR_IRQ:                             	; AN IRQ REDIRECTION
		MOV 	DS:IRQNUM[EDI], AL              ; MODIFY CODE WITH INTERRUPT NUMBER
	
		MOV 	SI, SEGS16                      ; REAL MODE TARGET CS:IP
		MOV 	DI, OFFSET R1       
		SUB 	BX, 6                           ; ADJUST REAL MODE SP FOR STORED VARS

		DB 		66H                             ; JMP DWORD PTR, AS IN 32BIT OFFSET,
		JMP 	WORD PTR CS:PM_2_RM             ;  NOT SEG:16BIT OFFSET

		R1:
		DB 		0CDH                           	; INT IRQNUM
		IRQNUM 	DB ?

		MOV 	AX, SELZERO32                 	; DS SELECTOR VALUE FOR PROTECTED MODE
		MOV 	CX, AX                         	; ES SELECTOR VALUE FOR PROTECTED MODE
		POP 	EBX                            	; GET PROTECTED MODE SS:ESP FROM STACK
		POP 	DX
		MOV 	SI, SELCODE16                  	; TARGET CS:EIP IN PROTECTED MODE
		MOV 	EDI, OFFSET R2
	
		JMP 	CS:RM_2_PM                    	; GO BACK TO PROTECTED MODE
	
		R2:	
		MOV 	EDI, CS:PRG_BASE16             	; RESLEASE REAL MODE STACK
		MOV 	AX, CS:PM2RM_STKLEN
		ADD 	DS:PM2RM_STKCUR[EDI], AX
	
		POP 	GS                               ;-+
		POP 	FS                               ; |
		POP 	ES                               ; |
		POP 	DS                               ; |
		POPAD                                	;RESTORE ALL REGISTERS
		IRETD

		;-----------------------------------------------------------------------------
		REDIR_INT:                             	; AN INT REDIRECTION
		MOV 	DS:INTNUM[EDI], AL            	; MODIFY CODE WITH INTERRUPT NUMBER
	
		MOV 	ES, CS:_SELZERO32            	; COPY REGISTERS FROM PROTECTED MODE
		LEA 	EDI, [EBP-26H]                 	;  STACK TO REAL MODE STACK
		LEA 	ESI, [ESP+8]                   	; ESP+8 => POPAD
		MOV 	ECX, 8
		CLD	
		REP 	MOVSD ES:[EDI], SS:[ESI]      	; NOTE THE SS OVERRIDE!
	
		MOV 	SI, SEGS16                  	; REAL MODE TARGET CS:IP
		MOV 	DI, OFFSET I1
		SUB 	BX, 26H                      	; ADJUST REAL MODE SP FOR STORED VARS

		DB 		66H                         	; JMP DWORD PTR, AS IN 32BIT OFFSET,
		JMP 	WORD PTR CS:PM_2_RM          	;  NOT SEG:16BIT OFFSET

		I1:
		POPAD                                	; LOAD REGS WITH INT CALL VALUES

		DB 		0CDH                         	; INT INTNUM
		INTNUM 	DB ?

		PUSHAD                               	; STORE REGISTERS ON STACK
		PUSHF                                	; STORE FLAGS ON STACK
		CLI
		CLD
        
		XOR 	EAX, EAX                      	; EAX = LINEAR PTR TO SS
		MOV 	AX, SS
		SHL 	EAX, 4
		MOVZX 	EBP, SP                         ; EBP = SP
        
		MOV 	EBX, [BP+22H]                  	; GET PROTECTED MODE SS:ESP FROM STACK
		MOV 	DX, [BP+26H]
        
		ADD 	EBP, EAX                      	; EBP -> STORED REGS ON STACK
        
		MOV 	AX, SELZERO32                 	; DS SELECTOR VALUE FOR PMODE ZERO32
		MOV 	CX, DX                         	; ES SELECTOR VALUE FOR PMODE STACK
		MOV 	SI, SELCODE16                  	; TARGET CS:EIP IN PROTECTED MODE
		MOV 	EDI, OFFSET I2
	    
		JMP 	CS:RM_2_PM                    	; GO BACK TO PROTECTED MODE
	    
		I2:	
		MOV 	AX, DS:[EBP]                  	; MOVE RETURN FLAGS FROM REAL MODE
		AND 	AX, 8D5H                      	;  STACK TO PROTECTED MODE STACK
		MOV 	BX, [ESP+30H]
		AND 	BX, NOT 8D5H
		OR 		AX, BX                        	; MERGE PMODE/RMODE FLAGS
		MOV 	[ESP+30H], AX                 	; PUT FLAGS ONTO IRETD
        
		LEA 	ESI, [EBP+2]                   	;DS:ESI => RMODE PUSHAD
		LEA 	EDI, [ESP+8]                   	;ES:EDI => PMODE POPAD
		MOV 	ECX, 8
		DB 		67H                            	;-+
		REP 	MOVSD                          	; COPY FROM RMODE STACK TO PMODE STACK
        
		MOV 	EDI, CS:PRG_BASE16             	; RELEASE  REAL MODE STACK
		MOV 	AX, CS:PM2RM_STKLEN
		ADD 	DS:PM2RM_STKCUR[EDI], AX
        
		POP 	GS                              ;-+
		POP 	FS                              ; |
		POP 	ES                              ; |
		POP 	DS                              ; |
		POPAD                                	; RESTORE ALL REGS
		IRETD
		
	INT3H ENDP

	CRITICAL_ERROR PROC                    		; SOME UNRECOVERABLE ERROR
		CLI                                  	; MAKE SURE WE ARE NOT INTERRUPTED
		IN 		AL, 61H                        	; BEEP
		OR 		AL, 3
		OUT 	61H, AL
		JMP 	$                             	; NOW HANG
	CRITICAL_ERROR ENDP

	INT21H_RM PROC  							;INT 21H HANDLER (RMODE)
	
		CMP 	AH, 4CH                       	; IS PROGRAM TERMINATING?
		JZ 		EXIT
		JMP 	CS:OLD_INT21H                  	;NO, CONTINUE ON TO OLD INT 21H HANDLER
		
		EXIT:                                  	;YES, PROGRAM IS TERMINATING
		PUSH 	EAX
		XOR 	AX, AX
		MOV 	DS, AX
		MOV 	EAX, CS:OLD_INT21H
		MOV 	DS:[21H*4], EAX              	;RESTORE OLD INT 21H HANDLER

		MOV 	EAX, CS:OLD_INT15H             	;INT 15H CLEAN-UP
		MOV 	DS:[15H*4], EAX               	;RESTORE OLD INT 15H HANDLER
		POP 	EAX
		JMP 	CS:OLD_INT21H
		
	INT21H_RM ENDP
	
	;THIS SECTION IS USED TO REPORT ERRORS AND QUIT THE PROGRAM
	EXIT16ERROR:
		MOV 	AX,4C00H	
		INT 	21H  							;EXIT PROGRAM

	INT15H PROC                       			; THIS IS THE NEW INT 15H HANDLER
	  JMP 	CS:[OLD_INT15H]
	INT15H ENDP

CODE16SEG ENDS

ASSUME CS:SEGS32,DS:SEGS32,SS:SEGS32,ES:NOTHING

DATA32SEG SEGMENT USE32

	X 				DD 0     					;COORDS OF CURSOR ON SCREEN
	Y 				DD 0
	TIMER 			DW 0

												;32BIT MESSAGES
	MSG32_TIMER 	DB ' = TIMER',13,0
	KEY 			DB ?, 0
	
DATA32SEG ENDS

CODE32SEG SEGMENT USE32

	START32 PROC
	
												;RELOAD ALL SEGMENT REGS WITH 32BIT SELECTORS
		MOV 	AX, SELDATA32
		MOV 	DS, AX
		MOV 	SS, AX
		MOV 	FS, AX
		MOV 	GS, AX
		MOV 	ESP, TOS32
		MOV 	AX, SELVID
		MOV 	ES, AX

		MOV 	AX, SELCODE32
		MOV 	EDX, OFFSET TIMER_IRQ
		MOV 	BL, 8
		CALL 	SETINT

		STI  									;ENABLE IRQS

		G1:
		MOV 	ECX, 0FFFFH
		LOOP 	$            					;MAKE A SMALL DELAY SO IRQ#0 WILL HAVE A CHANCE TO
												;OCCUR WHILE IN PMODE

		MOV 	AH, 0BH
		INT 	21H
		CMP 	AL, 0
		JZ 		G1         						;NO KEY AVAIL?

		MOV 	AX, 0
		INT 	16H

		CMP 	AH, 1      						;IS IT THE ESC SCAN CODE?
		JZ 		QUIT       						;YES THEN QUIT
		JMP 	G1

		QUIT:
		MOV 	AX, 4C00H
		INT 	21H  							;QUIT PROGRAM

	START32 ENDP

	TIMER_IRQ PROC
											;THIS IS CARLED DURING IRQ#0
		PUSH 	EAX
		PUSH 	ES
		PUSH 	DS
		MOV 	ES, CS:_SELVID
		MOV 	DS, CS:_SELDATA32
		MOV 	AX, TIMER
		INC 	TIMER
		MOV 	BYTE PTR ES:[0], AL
		MOV 	AL, 20H
		OUT 	20H, AL                        	;ACK IRQ
		POP 	DS
		POP 	ES
		POP 	EAX
		IRETD
		
	TIMER_IRQ ENDP

	SETINT PROC
	
		;SETS ONE OF THE EXCEPTION HANDLERS TO A NEW 32BIT LOCATION
		;BY DEFAULT ALL INTS GOTO RMODE
		;IN : AX=SELECTOR
		;   :EDX=OFFSET
		;   : BL=INT #  (CURRENTLY ONLY 0-31 ARE ALLOWED - WE WILL MAKE OUR IDT
		;                FULL SIZE -256 VEKTORZ- IN THE NEXT TUTORIAL) 
		
		MOVZX 	EBX, BL
		MOV 	CX, SELDATA16
		MOV 	DS, CX
		MOV 	ESI, OFFSET IDT
		MOV 	[ESI+EBX*8], DX                	; SET THE OFFSET (0-15)
		MOV 	[ESI+EBX*8+2], AX              	; SET THE SELECTOR
		SHR 	EDX, 16
		MOV 	[ESI+EBX*8+6], DX             	; SET THE OFFSET (16-31)
		MOV 	CX, SELDATA32
		MOV 	DS, CX
		RET
		
	SETINT ENDP

CODE32SEG ENDS

END START16     ;START PROGRAM IN SEGS16:START16
