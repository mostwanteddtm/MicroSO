comment #*****************************
Program by  Neal Margulis -- Use MASM 5.0
#*************************************

.386p

DATASEG16 SEGMENT USE16 'DATA'
DATASEG16 ENDS

CODESEG16 SEGMENT USE16 'CODE'
CODESEG16 ENDS

SEGS16 GROUP DATASEG16, CODESEG16

GDTDESC STRUCT
    LIMIT_0_15  DW  0      ;  LOWEST 16 BITS OF SEGMENT LIMIT
    BASE_0_15   DW  0      ;  LOWEST 16 BITS OF BASE
    BASE_16_23  DB  0      ;  BASE BITS 16-23
    ACCESS      DB  0      ;  PRESENT BIT, PRIV. LEVEL, TYPE
    GRAN        DB  0      ;  G BIT, D/B BIT , LIMIT BITS 16-19
    BASE_24_31  DB  0      ;  BASE BITS 24-31
GDTDESC ENDS

CODE_SEG_ACCESS EQU 09AH   ; PRESENT, DPL=0, NON-CONFORMING,READ/EXEC
DATA_SEG_ACCESS EQU 092H   ; PRESENT, DPL=0, EXPAND-UP,WRITEABLE

; HAVE SCREENBASE EQUAL B8000H FOR EGA OR B0000H FOR MONOCHROME
SCREENBASE   EQU  0B8000H
SCREENSEG    EQU  0B800H

STKSEG SEGMENT STACK 'STACK'
	DB	100H DUP(?)
STKSEG ENDS

DATASEG16 SEGMENT

	GDTR 			LABEL FWORD		; TAMANHO MÁXIMO DE UMA GDT 65535 BYTES
	GDT_LIMIT 		DW GDT_SIZE-1	; TOTAL DE DESCRITORES 8192 * 8 BYTES CADA = 65536 BYTES | (65536 - 1 = 65535)
	GDT_ADDR 		DD ?			; ENDEREÇO DA MATRIZ DE DESCRITORES: GDTR
	
	GDT_START 		EQU $
	
	NULLDESC  		GDTDESC <,,,,,>  ;   GDT entry 0 (null descriptor)
	CODEDESC32  	GDTDESC <0FFFFH,,,code_seg_access,0C0H,0>  ;  D bit ON
	DATADESC32  	GDTDESC <0FFFFH,,,data_seg_access,08FH,>  ;
	VIDEODESC32     GDTDESC <0FFFFH,0,0,data_seg_access,08FH,0>
	DATADESC16  	GDTDESC <0FFFFH,0,0,data_seg_access,08fH,0>
	CODEDESC16  	GDTDESC <0FFFFH,,,code_seg_access,080H,0>  ;  D bit OFF
	
	GDT_SIZE 		EQU ($-GDT_START)
	
	SELCODEDESC32 	EQU (OFFSET CODEDESC32 - GDT_START)
	SELDATADESC32 	EQU (OFFSET DATADESC32 - GDT_START)
	SELVIDEODESC32 	EQU (OFFSET VIDEODESC32 - GDT_START)
	SELDATADESC16	EQU (OFFSET DATADESC16 - GDT_START)
	SELCODEDESC16 	EQU (OFFSET CODEDESC16 - GDT_START)
	
DATASEG16 ENDS

CODESEG16 segment
	assume  cs:SEGS16,ds:SEGS16

	start:

		MOV		AX, CS
		MOV 		DS, AX

		MOV		AX, 03h
		INT		10h

		; Make entries in GDT for CODESEG32 segment as code or data
		MOV 		AX, SEG CODESEG32
		AND 		EAX, 0FFFFh
		SHL 		EAX, 4h
		MOV 		EBX, EAX
		SHR 		EAX, 16
		MOV 		CODEDESC32.BASE_0_15, BX
		MOV 		DATADESC32.BASE_0_15, BX
		MOV 		CODEDESC32.BASE_16_23, AL
		MOV 		DATADESC32.BASE_16_23, AL

		; Make entry in GDT for CODESEGRM segment as code
		MOV 		AX,SEG CODESEGRM
		AND 		EAX, 0FFFFh
		SHL 		EAX, 4h
		MOV 		EBX, EAX
		SHR 		EAX, 16
		MOV 		CODEDESC16.BASE_0_15, BX
		MOV 		CODEDESC16.BASE_16_23, AL

		; Set up gdtr for lgdt instruction
		XOR		EAX, EAX
		MOV		AX, DATASEG16
		SHL		EAX, 4
		ADD 	EAX, GDT_START
		MOV 	GDT_ADDR, EAX

		LGDT 	[GDTR]  

		CLD                         							; CLEAR DIRECTION FLAG
		CLI                         							; DISABLE INTERRUPTS

		; ENTER PROTECTED MODE
		MOV     EAX,CR0
		OR      EAX,1
		MOV     CR0,EAX            							; ENABLE PROTECTED MODE

															;flush prefetch queue
		DB 0EAh, 0h, 0h, SELCODEDESC32, 0h       			; jmp to PMODE and execute

CODESEG16 ENDS

CODESEG32 SEGMENT PUBLIC USE32 'CODE'
    ASSUME CS:CODESEG32
	
        MOV 	AX, SELVIDEODESC32         					;SELECTOR 18H IS 4 GIGABYTE DATA SEGMENT WITH BASE AT 0
        MOV 	ES, AX
        MOV 	FS, AX
        MOV 	AX, SELDATADESC32         					;  DATA SEGMENT WITH BASE AT 'C2SEG'
        MOV 	DS, AX
		
        MOV     EDI, SCREENBASE  							;  ADDRESSING SCREEN MEMORY FROM PROTECTED MODE
		MOV		AX, 0750h
		STOSW
		MOV		AX, 074Dh
		STOSW		

        db      0EAh, 0h, 0h, 0h, 0h, SELCODEDESC16, 0h 	; jmp to c3 and execute

	COMMENT ^
		ALIGN 16
		PDAT  DB 0ACH
		LASTPM  LABEL DWORD
	^
		
CODESEG32 ENDS

CODESEGRM SEGMENT PUBLIC USE16 'CODE'
    ASSUME CS:CODESEGRM

        MOV 	AX, SELDATADESC16         					; CHANGE SEGMENTS BACK TO HAVE VALID
        MOV 	ES, AX          							;  REAL MODE ATTRIBUTES.
        MOV 	DS, AX
        MOV 	FS, AX
        MOV 	EAX,CR0
        AND 	EAX, 07FFFFFFEh
        MOV 	CR0,EAX               						; ENTER REAL MODE
        JMP 	FAR PTR FLUSHRL       						; FLUSH QUEUE
		
 FLUSHRL:
		MOV 	AX, SCREENSEG        						; ADDRESS SCREEN MEMORY FROM REAL MODE
		MOV		ES, AX
		MOV		DI, 0A0h
		
		MOV		AX, 0752h
		STOSW
		
		MOV		AX, 074Dh
		STOSW
		
		MOV 	DH, 1
		MOV 	DL, 0
		MOV 	BH, 0
		MOV 	AH, 2
		INT 	10h
		
A20_OFF:

        MOV 	AH, 04Ch                    				;  DOS termination
        MOV 	AL, 01h
        INT 	21h
CODESEGRM ENDS

END START
