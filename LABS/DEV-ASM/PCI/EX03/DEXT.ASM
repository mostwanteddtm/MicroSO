;THIS PROGRAM GOES DIRECTLY TO PMODE FROM RMODE.
;THIS PROGRAM WILL NOT WORK IF A VCPI OR DPMI DRIVER IS LOADED.
;SO YOU CAN NOT HAVE EMM386,QEMM,386MAX,WINDOZE, OS/2 OR ANYTHING LOADED
;WHILE USING THIS LITTLE EXAMPLE (DON'T WORRY, EVENTUALLY THIS WILL
;RUN UNDER THOSE PROGRAMS BUT NOT YET).

; STAGE #2 
; - ADDED SUPPORT FOR XMS
; - NOW ALL INTS (AND IRQS) ARE REDIR TO RMODE
; - INT 21H AH=4CH WILL CLEAN-UP AND EXIT TO RMODE

; NOTES:
; - THIS NEXT STAGE SPENDS A LOT OF TIME IN RMODE SO THE PMODE TIMER WILL
;   SEEM REALLY SLOW.  THAT'S BECAUSE RMODE IRQS ARE NOT PASSED UP TO
;   PMODE YET. I'LL DO THAT LATER. (IF I DON'T EVEN PUT A SMALL DELAY LOOP
;   IN PMODE THE TIMER SEEMS TO STOP COMPLETE, BUT IT IS NOT, IT'S JUST OCCURING
;   MOST OF THE TIME IN RMODE)

; NEW FUNCS SEE:
; INT21H_RM PROC - THIS WILL CLEAN-UP ON EXIT
; INT3H PROC - PASSES ALL INTS/IRQS TO RMODE
; XMS_INSTALLED: - INIT WHEN XMS IS PRESENT (V2.0 SO FAR ONLY)

;ALLOW USE32 AND 386 INSTRUCTIONS
.386P   																

STACK16SIZ 		EQU 1024
STACK32SIZ 		EQU 1024

ERROR 			EQU -1

DESC STRUCT   				;DEFINE OUR DESCRIPTOR STRUCTURE
	LIMIT_LO 	DW ?    	;LIMIT BITS 15-0
	BASE_LO 	DW ?     	;BASE BITS 15-0
	BASE_MID 	DB ?    	;BASE BITS 23-16
	TYPE1 		DB ?       	;TYPE OF SELECTOR
	LIMIT_HI 	DB ?    	;LIMIT BITS 19-16 AND OTHER INFO
	BASE_HI 	DB ?     	;BASE BITS 31-24
DESC ENDS

CALLSTRUCT STRUCT  			;USED IN CALLING RMODE
	_EDI 		DD ?     	;0
	_ESI 		DD ?     	;4
	_EBP 		DD ?     	;8
	_RES 		DD ?     	;0CH RESERVED
	_EBX 		DD ?     	;10H
	_EDX 		DD ?     	;14H
	_ECX 		DD ?     	;18H
	_EAX 		DD ?     	;1CH
	_FLG 		DW ?     	;20H FLAGS
	_ES 		DW ?      	;22H SEGMENTS (NOT SELECTORS)
	_DS 		DW ?      	;24H "
	_FS 		DW ?      	;26H "
	_GS 		DW ?      	;28H "
	_IP 		DW ?      	;2AH IGNORED WHEN CALLING INT
	_CS 		DW ?      	;2CH "
	_SP 		DW ?      	;2EH MUST BE 0 TO USE SYSTEM STACKS
	_SS 		DW ?      	;30H "
CALLSTRUCT ENDS

;FIRST DEFINE ALL SEGMENTS THAT WILL BE NEEDED

CODE16SEG SEGMENT USE16 'CODE'
CODE16SEG ENDS

DATA16SEG SEGMENT USE16
DATA16SEG ENDS

CODE32SEG SEGMENT USE32 'CODE'
CODE32SEG ENDS

DATA32SEG SEGMENT USE32
DATA32SEG ENDS

STACK16SEG SEGMENT USE16 STACK
	DB 				STACK16SIZ DUP (?)
	TOS16 			EQU $   	;TOP OF STACK
STACK16SEG ENDS

STACK32SEG SEGMENT USE32 'STACK'
	DB 				STACK32SIZ DUP (?)
	TOS32 			EQU $   	;TOP OF STACK
STACK32SEG ENDS

;PUT ALL SEGMENTS IN ONE
SEGS16 GROUP CODE16SEG,DATA16SEG,STACK16SEG
SEGS32 GROUP CODE32SEG,DATA32SEG,STACK32SEG

ASSUME CS:SEGS16,DS:SEGS16,SS:SEGS16,ES:NOTHING

DATA16SEG SEGMENT USE16  	;START DEFINING OUR 16BIT DATA

	;DEFINE OUR GDTR
	GDTR 			LABEL FWORD
	GDT_LIMIT 		DW GDT_SIZE-1
	GDT_ADDR 		DD ?
	
	;DEFINE OUR IDTR
	IDTR 			LABEL FWORD
	IDT_LIMIT 		DW IDT_SIZE-1
	IDT_ADDR 		DD ?
	
	;DEFINE THE DEFAULT IDTR (THIS IS USED WHILE IN RMODE)
	RM_IDTR 		LABEL FWORD
	DW 3FFH  		;LIMIT
	DD 0     		;ADDR


	GDT_START 		EQU $
	
	NULL 			DESC <0,0,0,0,0,0>
	;THIS IS THE 1ST GDT ENTRY CALLED NULL WHICH WE CAN NOT USE
	
	CODE16 			DESC <0FFFFH,?,?,10011010B,0H,?>
	;LIMIT=64 KBS (THIS IS A 16BIT SEGMENT SO ONLY IP IS USED WHILE RUNNING)
	;BASE=? (THIS WILL BE SETUP LATER IN THE PROGRAM)
	;10011?10B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=1 (CODE)
	;            C=1(CONFORMING), R=1 (READABLE), A=0 (NOT ACCESSED)
	;0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	DATA16 			DESC <0FFFFH,?,?,10010010B,0H,?>
	;LIMIT=64 KBS
	;BASE=? (THIS WILL BE SETUP LATER IN THE PROGRAM)
	;10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	;0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	VID 			DESC <0FFFFH,8000H,0BH,10010010B,0H,0>
	;LIMIT=64 KBS
	;BASE=0B8000H (MAKES IT EASY TO ACCESS VIDEO RAM WHILE IN PMODE-16)
	;10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	;0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	CODE32 			DESC <0FFFFH,?,?,10011010B,11001111B,?>
	;LIMIT=4 GBS (0FFFFH * 4K = 4 GBS)
	;BASE=?
	;     THE BEGINNING OF MEMORY)
	;10011110B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=1 (CODE)
	;            C=1(CONFORMING), R=1 (READABLE), A=0 (NOT ACCESSED)
	;11001111B = LIMIT BITS 19-16=0FH, G=1 (4K GRANULARITY), D=1 (32BIT SEGMENT)
	
	DATA32 			DESC <0FFFFH,?,?,10010010B,11001111B,?>
	;LIMIT=4 GBS
	;BASE=?
	;10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	;11001111B = LIMIT BITS 19-16=0FH, G=1 (4K GRANULARITY), D=1 (32BIT SEGMENT)
	
	ZERO32 			DESC <0FFFFH,0,0,10010010B,11001111B,0>
	;LIMIT=4 GBS
	;BASE=0H (EASY ACCESS TO RMODE MEMORY)
	;10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	;11001111B = LIMIT BITS 19-16=0FH, G=1 (4K GRANULARITY), D=1 (32BIT SEGMENT)
	
	LDT 			DESC <0,0,0,10000010B,0H,0>
	;THIS IS WHAT WILL BE LOADED INTO OUR LDTR.  BECAUSE WE DON'T WANT
	;TO USE THE LDT THIS IS SETUP SO THAT OUR LDT IS EMPTY
	;LIMIT=1 BYTE (LIMITS OF 0 ARE NOT POSSIBLE)
	;BASE=0
	;10000010B = P=1 (PRESENT), DPL=0, S=0(SYSTEM SEGMENT), TYPE=2 (LDT)
	;       0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	GDT_SIZE 		EQU ($-GDT_START)

	;DEFINE OUR IDT
	IDT_START 		EQU $
	IDT DESC 		256 DUP (<?,SELCODE16,0,10001110B,0,0>)
	IDT_SIZE 		EQU ($-IDT_START)

	;DEFINE OUR INTRMATRIX
	INTS 			DB 256 DUP (0CCH)       ;THIS IS WHAT EACH OF THE DEFAULT
											;INT DESCRIPTORS PTS TO
											;0CCH = INT 3 (ONE-BYTE OPCODE)
											;SO ALL INTS GOTO THE INT 3 HANDLER
											;WHICH WILL DIRECT THE INT TO RMODE

	;DEFINE OUR SELECTORS AS EQU
	SELCODE16 		EQU (OFFSET CODE16 - GDT_START)
	SELDATA16 		EQU (OFFSET DATA16 - GDT_START)
	SELVID 			EQU (OFFSET VID - GDT_START)
	SELDATA32 		EQU (OFFSET DATA32 - GDT_START)
	SELZERO32 		EQU (OFFSET ZERO32 - GDT_START)
	SELCODE32 		EQU (OFFSET CODE32 - GDT_START)
	SELLDT 			EQU (OFFSET LDT - GDT_START)

	;DEFINE OUR SELECTORS AS DW
	_SELCODE16  	DW SELCODE16
	_SELDATA16  	DW SELDATA16
	_SELVID     	DW SELVID
	_SELDATA32  	DW SELDATA32
	_SELZERO32  	DW SELZERO32
	_SELCODE32  	DW SELCODE32
	_SELLDT     	DW SELLDT


	;DEFINE OUR RAW SWITCHING ROUTINES
	PM_2_RM 		DD OFFSET PM_2_RM_RX    ;BY DEFAULT OUR SWITCHING ROUTINES
					DD SELCODE16            ;WILL BE FOR RAW/XMS BUT LATER IT MAY
			
	RM_2_PM 		DW OFFSET RM_2_PM_RX    ;BECOME VCPI
					DW SEGS16

	;DEFINE OUR PM 2 RM STACKS
	PM2RM_STKEND 	DW ?       				;LAST AVAIL STACK   (SS)
	PM2RM_STKCUR 	DW ?       				;CURRENT            (SS)
	PM2RM_STKLEN 	DW 80H     				;INCREMENTAL(PARA)  (SP)
	PM2RM_STKS 		DW 8         			;# OF STACKS

	;.DATA
	;DEFINE OTHER VARIABLES NEEDED
	MODE 			DB 0        			;DEFINES WHAT DRIVERS ARE INSTALLED
	MODE_RAW 		EQU 0 					;NONE
	MODE_XMS 		EQU 1 					;XMS (HIMEM.SYS)

	XMS_MAX 		DW 1024 			 	;MAX RAM TO ALLOC IS 1024 KBS
	XMS_MIN 		DW 64   			 	;MIN RAM TO ALLOC IS 64 KBS
	XMS_LEFT 		DW ?    				;INT 15H WILL REPORT THIS MUCH IS FREE
	XMS_BASE 		DD ?    				;THE START OF OUR XMS RAM WE HAVE ALLOC
	XMS_SIZE 		DD ?    				;THE SIZE OF OUR XMS RAM
	XMS_CALL 		DD ?    				;SEG:OFF TO CALL XMS DRIVER
	XMS_EMB 		DW ?    			 	;OUR EMB HANDLE ALLOC'ED FROM XMS

	CPU 			DB ?         			;DETECTED CPU  (3=386 4=486 5=586)

	PRG_BASE16 		DD ?                    ;SEGS16 * 10H
	PRG_BASE32 		DD ?                    ;SEGS32 * 10H

	OLD_INT15H 		DD ?                    ;OLD RMODE INT 15H HANDLER
	OLD_INT21H 		DD ?                    ;OLD RMODE INT 21H HANDLER

	INT3VECTOR 		DD OFFSET INTS+3
					DD SELCODE16
					
	PICSLAVE  		DB 70H                  ; PIC SLAVE BASE INTERRUPT
	PICMASTER 		DB 8H                   ; PIC MASTER BASE INTERRUPT

	PSP 			DW ?                    ;PROGRAM SEGMENT PREFIX

	;MESSAGES
	MSG_WELCOME 	DB 'DOS EXTENDER TUTORIAL : STAGE #2',13,10,'$'
	MSG_XMS_LOW 	DB 'INSUFFICENT XMS MEMORY FOUND!',13,10,'$'
	MSG_XMS_LOCK 	DB 'UNABLE TO LOCK XMS MEMORY BLOCK!',13,10,'$'
	MSG_80386 		DB '80386 OR BETTER REQUIRED!',13,10,'$'
	MSG_V86 		DB 'ANOTHER PMODE SOFTWARE IS ALREADY LOADED!',13,10,'$'
	MSG_CLEAN_BOOT 	DB 'PLEASE USE A CLEAN BOOT TO USE THIS TUTORIAL!',13,10,'$'
	MSG_A20 		DB 'UNABLE TO ENABLE A20!',13,10,'$'
	
DATA16SEG ENDS

CODE16SEG SEGMENT USE16  ;START THE 16BIT CODE SEGMENT

	;THIS SECTION IS USED TO REPORT ERRORS AND QUIT THE PROGRAM
	EXIT16ERROR:
		MOV 	AH, 9
		INT 	21H  							;PRINT ERROR MESSAGE
		MOV 	DX, OFFSET MSG_CLEAN_BOOT	
		MOV 	AH, 9	
		INT 	21H  							;PRINT CLEAN BOOT MESSAGE
		MOV 	AX,4C00H	
		INT 	21H  							;EXIT PROGRAM

	;THIS WILL DETECT IF THE CPU IS A 80386 OR BETTER
	;RETURN : CL = PROCESSOR TYPE  (2=286 3=386 4=486)
	
	DETECT_PROCESSOR PROC             			; GET PROCESSOR: 286, 386, 486, OR 586
		
		XOR 	CX, CX                      	; PROCESSOR TYPE 0 IN CASE OF EXIT
	
		PUSHF                           		; TRANSFER FLAGS TO BX
		POP 	BX	
	
		MOV 	AX, BX                      	; TRY TO CLEAR HIGH 4 BITS OF FLAGS
		AND 	AH, 0FH	
	
		PUSH 	AX                         		; TRANSFER AX TO FLAGS
		POPF	
		PUSHF                           		; TRANSFER FLAGS BACK TO AX
		POP 	AX	
	
		AND 	AH, 0F0H                    	; ISOLATE HIGH 4 BITS
		CMP 	AH, 0F0H
		JE 		SHORT DETECT_PROCESSORDONE   	; IF BITS ARE SET, CPU IS 8086/8

		MOV 	CL, 2                        	; PROCESSOR TYPE 2 IN CASE OF EXIT

		OR 		BH, 0F0H                      	; TRY TO SET HIGH 4 BITS OF FLAGS

		PUSH 	BX                         		; TRANSFER BX TO FLAGS
		POPF
		PUSHF                           		; TRANSFER FLAGS TO AX
		POP 	AX

		AND 	AH, 0F0H                     	; ISOLATE HIGH 4 BITS
		JZ 		SHORT DETECT_PROCESSORDONE   	; IF BITS ARE NOT SET, CPU IS 80286

		INC 	CX                          	; PROCESSOR TYPE 3 IN CASE OF EXIT

		PUSH 	EAX                        		; PRESERVE 32BIT REGISTERS
		PUSH 	EBX     

		PUSHFD                          		; TRANSFER EFLAGS TO EBX
		POP 	EBX

		MOV 	EAX, EBX                     	; TRY TO FLIP AC BIT IN EFLAGS
		XOR 	EAX, 40000H

		PUSH 	EAX                        		; TRANSFER EAX TO EFLAGS
		POPFD
		PUSHFD                          		; TRANSFER EFLAGS BACK TO EAX
		POP 	EAX

		XOR 	EAX, EBX                     	; AC BIT FLIPED?
		JZ 		SHORT DETECT_PROCESSORDONE2  	; IF NO, CPU IS 386

		INC 	CX                          	; PROCESSOR TYPE 4 IN CASE OF EXIT

		MOV 	EAX, EBX                     	; TRY TO FLIP ID BIT IN EFLAGS
		XOR 	EAX, 200000H

		PUSH 	EAX                        		; TRANSFER EAX TO EFLAGS
		POPFD
		PUSHFD                          		; TRANSFER EFLAGS BACK TO EAX
		POP 	EAX

		XOR 	EAX, EBX                     	; ID BIT FLIPED?
		JZ 		SHORT DETECT_PROCESSORDONE2  	; IF NO, CPU IS 486

		INC 	CX                          	; PROCESSOR TYPE 5, CPU IS 586

		DETECT_PROCESSORDONE2:
		POP 	EBX                         	; RESTORE 32BIT REGISTERS
		POP 	EAX    

		DETECT_PROCESSORDONE:
		RET                             		; RETURN
		
	DETECT_PROCESSOR ENDP

	INT15H PROC                       			; THIS IS THE NEW INT 15H HANDLER
	
	  CMP 	AH, 88H                      		;IT WILL REPORT HOW MUCH RAM IF FREE MINUS
	  JNZ 	CHAIN_INT15H                		;WHAT WE HAVE TAKEN
	  MOV 	AX, CS:XMS_LEFT
	  IRET
	  
	CHAIN_INT15H:
	  JMP 	CS:[OLD_INT15H]
	  
	INT15H ENDP

	;THIS NEXT PROC WILL ENABLE THE A20 GATE SO WE CAN ACCESS RAM ABOVE 1 MB
	
	ENABLEA20 PROC                    			; HARDWARE ENABLE GATE A20
	
		PUSHF
		PUSH 	FS
		PUSH 	GS
		CLI

		XOR 	AX, AX                       	; SET A20 TEST SEGMENTS 0 AND 0FFFFH
		MOV 	FS, AX
		DEC 	AX
		MOV 	GS, AX

		CALL 	ENABLEA20TEST              		; IS A20 ALREADY ENABLED?
		JZ 		SHORT ENABLEA20DONE          	; IF YES, DONE

		IN 		AL, 92H                       	; PS/2 A20 ENABLE
		OR 		AL, 2
		JMP 	SHORT $+2
		JMP 	SHORT $+2
		JMP 	SHORT $+2
		OUT 	92H, AL

		CALL 	ENABLEA20TEST              		; IS A20 ENABLED?
		JZ 		SHORT ENABLEA20DONE          	; IF YES, DONE

		CALL 	ENABLEA20KBWAIT            		; AT A20 ENABLE
		JNZ 	SHORT ENABLEA20F0

		MOV 	AL, 0D1H
		OUT 	64H, AL

		CALL 	ENABLEA20KBWAIT
		JNZ 	SHORT ENABLEA20F0

		MOV 	AL, 0DFH
		OUT 	60H, AL

		CALL 	ENABLEA20KBWAIT

		ENABLEA20F0:                      		; WAIT FOR A20 TO ENABLE
		MOV 	CX, 800H                     	; DO 800H TRIES

		ENABLEA20L0:
		CALL 	ENABLEA20TEST              		; IS A20 ENABLED?
		JZ 		ENABLEA20DONE                	; IF YES, DONE

		IN	 	AL, 40H                       	; GET CURRENT TICK COUNTER
		JMP 	SHORT $+2
		JMP 	SHORT $+2
		JMP 	SHORT $+2
		IN 		AL, 40H
		MOV 	AH, AL

		ENABLEA20L1:                      		; WAIT A SINGLE TICK
		IN 		AL, 40H
		JMP 	SHORT $+2
		JMP 	SHORT $+2
		JMP 	SHORT $+2
		IN 		AL, 40H
		CMP 	AL, AH
		JE 		ENABLEA20L1

		DEC 	CX
		JNZ 	ENABLEA20L0                 	; LOOP FOR ANOTHER TRY

		MOV 	AX, ERROR                    	; ERROR, A20 DID NOT ENABLE
		RET

		ENABLEA20DONE:
		POP 	GS
		POP 	FS
		POPF
		XOR 	AX, AX
		RET

		ENABLEA20KBWAIT:                  		; WAIT FOR SAFE TO WRITE TO 8042
		XOR 	CX, CX
		
		ENABLEA20KBWAITL0:
		JMP 	SHORT $+2
		JMP 	SHORT $+2
		JMP 	SHORT $+2
		IN 		AL, 64H                       	; READ 8042 STATUS
		TEST 	AL, 2                       	; BUFFER FULL?
		LOOPNZ 	ENABLEA20KBWAITL0        		; IF YES, LOOP
		RET

		ENABLEA20TEST:                    		; TEST FOR ENABLED A20
		MOV 	AL, FS:[0]                   	; GET BYTE FROM 0:0
		MOV 	AH, AL                       	; PRESERVE OLD BYTE
		NOT 	AL                          	; MODIFY BYTE
		XCHG 	AL, GS:[10H]                	; PUT MODIFIED BYTE TO 0FFFFH:10H
		CMP 	AH, FS:[0]                   	; SET ZERO IF BYTE AT 0:0 NOT MODIFIED
		MOV 	GS:[10H], AL                 	; PUT BACK OLD BYTE AT 0FFFFH:10H
		
		RET                             		; RETURN, ZERO IF A20 ENABLED
	
	ENABLEA20 ENDP

	START16 PROC                      			;THIS IS WHERE OUR PROGRAM STARTS

		PUSH 	ES                         		;SAVE THE PSP

		CLD

		MOV 	AX, CS
		MOV 	DS, AX         
		MOV 	ES, AX                       	;SET DS=ES=CS
	
		POP 	PSP                         	;LOAD PSP FROM STACK
	
		MOV 	DX, OFFSET MSG_WELCOME       	;-+
		MOV 	AH, 9                        	; |
		INT 	21H                         	;PRINT WELCOME MESSAGE

		;DETERMINE IF CPU IS A 80386 OR BETTER
		CALL 	DETECT_PROCESSOR
		CMP 	CL, 3
		JAE 	OK_386
		MOV 	DX, OFFSET MSG_80386
		JMP 	EXIT16ERROR
		
		OK_386:
		MOV 	CPU, CL  						;SAVE FOR LATER

		;DETERMINE IF WE ARE IN V86 MODE (IF YES THEN MOST LIKELY EMM386,QEMM OR
		; WINDOZE IS LOADED SO WE CAN NOT CONTINUE)
		
		PUSHFD   								;PUSH 32BIT FLAGS
		POP 	EAX  							;POP INTO EAX
		TEST 	EAX, 20000H   					;CHECK BIT 17 (VM)
		JZ 		OK_V86
		MOV 	DX, OFFSET MSG_V86
		JMP 	EXIT16ERROR
		
		OK_V86:

		;DETERMINE IF XMS IS LOADED
		MOV 	AX, 4300H
		INT 	2FH
		CMP 	AL, 80H
		JNZ 	XMS_NOT_INSTALLED
		JMP 	XMS_INSTALLED
		
		XMS_NOT_INSTALLED:

		;ALLOC MEMORY FROM INT 15H
		;THIS IS COMPLEX AND I WILL DESCRIBE HOW IT WORKS LATER
		MOV 	AH, 88H
		INT 	15H      						;GET TOTAL XMS 1K BLOCKS FREE
		CMP 	AX, XMS_MIN
		JAE 	R1
		MOV 	DX, OFFSET MSG_XMS_LOW
		JMP 	EXIT16ERROR
		R1: 	  								;OK THERE IS ENOUGH RAM
		MOV 	CX, AX
		SUB 	AX, XMS_MAX
		JNC 	R2
		MOV 	AX,0    						;LEAVE NO MEMORY
		R2:	
		MOV 	XMS_LEFT, AX
		SUB 	CX, AX          				;SIZE OF OUR XMS RAM
		XOR 	EBX, EBX				
		MOV 	BX, AX				
		MOV 	EAX, 1024*1024  				;1MB
		SHL 	EBX, 10         				;*1K
		ADD 	EAX, EBX        				;EAX = 1MB + XMS_LEFT * 1K  => XMS_BASE
		MOV 	XMS_BASE, EAX				
		XOR 	EAX, EAX				
		MOV 	AX, CX				
		SHL 	EAX, 10         				;*1K
		MOV 	XMS_SIZE, EAX   				;EAX = # OF 1K BLOCKS * 1K => XMS_SIZE

		;INSTALL OUR OWN INT 15H HANDLER
		MOV 	AX, 3515H
		INT 	21H            					;GET INT 15H
		MOV 	WORD PTR[OLD_INT15H+2], ES
		MOV 	WORD PTR[OLD_INT15H+0], BX
		PUSH 	DS
		POP 	ES

		MOV 	AX, 2515H
		MOV 	DX, OFFSET INT15H
		INT 	21H            					;SET INT 15H

		;ENABLE THE A20 SO WE CAN ACCESS RAM ABOVE 1MB.
		CALL 	ENABLEA20
		CMP 	AX, ERROR
		JNZ 	R3
		MOV 	DX, OFFSET MSG_A20
		JMP 	EXIT16ERROR
		R3:
		JMP 	CONT_INIT
		
		;-----------------------------------------------------------------------------
		
		XMS_INSTALLED:
		MOV 	MODE, MODE_XMS
		;CALL A NON-DESCTRUCTIVE DOS FUNC (TO AVOID BUGS IN SOME XMS DRIVERS)
		MOV 	AH, 2CH
		INT 	21H                             ; GET TIME (BUT THIS IS IGNORED)
		MOV 	AX, 4310H
		INT 	2FH                             ; GET XMS ENTRY-POINT
		MOV 	WORD PTR [XMS_CALL+2], ES
		MOV 	WORD PTR [XMS_CALL], BX
		PUSH 	CS                              ;-+
		POP 	ES                              ;RESTORE ES

		;ENABLE A20 THRU XMS DRIVER
		MOV 	AH, 3
		CALL 	[XMS_CALL]                      ; GLOBAL ENABLE A20
		CMP 	AX, 1
		JZ 		X1
		MOV 	DX, OFFSET MSG_A20
		JMP 	EXIT16ERROR
		
		X1:
		MOV 	AH, 8
		CALL 	[XMS_CALL]                      ; QUERY FREE EXTENDED MEMORY
		
		;AX=RAM FREE (1K BLOCKS)  (MAX=64 MBS)
		CMP 	AX, XMS_MIN
		JAE 	X2
		
		XE1:
		MOV 	DX, OFFSET MSG_XMS_LOW
		JMP 	EXIT16ERROR
		
		X2:
		CMP 	AX, XMS_MAX
		JB 		X3
		MOV 	AX, XMS_MAX
		
		X3:
		XOR 	EDX, EDX
		MOV 	DX, AX
		SHL 	EDX, 10                         ;-+   ;*1K
		MOV 	XMS_SIZE, EDX                   ; |
		SHR 	EDX, 10                     	;FIND TOTAL SIZE OF BLOCK
		MOV 	AH, 9
		CALL 	[XMS_CALL]                      ; ALLOC EMB
		CMP 	AX, 1
		JNZ 	XE1
		MOV 	XMS_EMB, DX
		MOV 	AH, 0CH
		CALL 	[XMS_CALL]                      ; LOCK EMB
		CMP 	AX, 1
		JZ X4
		
		MOV 	DX, XMS_EMB
		MOV 	AH, 0AH
		CALL 	[XMS_CALL]                      ; FREE EMB
		MOV 	DX, OFFSET MSG_XMS_LOCK
		JMP 	EXIT16ERROR
		
		X4:
		SHL 	EDX, 16
		MOV 	DX, BX
		MOV 	XMS_BASE, EDX

		CONT_INIT:
		
		;SETUP SOME OTHER VARIABLES
		XOR 	EAX, EAX
		MOV 	AX, CS
		SHL 	EAX, 4                       	; CONVERT TO LINEAR ADDR
		MOV 	PRG_BASE16, EAX

		XOR 	EAX, EAX
		MOV 	AX, SEGS32
		SHL 	EAX, 4                       	; CONVERT TO LINEAR ADDR
		MOV 	PRG_BASE32, EAX

		;SETUP ALL OUR DESCRIPTORS
		MOV 	EAX, PRG_BASE16
		MOV 	CODE16.BASE_LO, AX
		MOV 	DATA16.BASE_LO, AX
		SHR 	EAX, 16
		MOV 	CODE16.BASE_MID, AL
		MOV 	DATA16.BASE_MID, AL
		;  MOV CODE16.BASE_HI,AH               	;NOT NEEDED SINCE AH WILL ALWAYS BE 0
		;  MOV DATA16.BASE_HI,AH               	; "

		MOV 	EAX, PRG_BASE32
		MOV 	CODE32.BASE_LO, AX
		MOV 	DATA32.BASE_LO, AX
		SHR 	EAX, 16
		MOV 	CODE32.BASE_MID, AL
		MOV 	DATA32.BASE_MID, AL
		;  MOV CODE32.BASE_HI,AH               	; "
		;  MOV DATA32.BASE_HI,AH               	; "

		;SETUP GDT AND IDT BASE
		MOV 	EAX, PRG_BASE16
		ADD 	EAX, GDT_START
		MOV 	GDT_ADDR, EAX
		
		MOV 	EAX, PRG_BASE16
		ADD 	EAX, IDT_START
		MOV 	IDT_ADDR, EAX

		;SETUP PM_2_RM STACKS
		;FIRST FIND END OF RAM AFTER EXE
		XOR 	EAX, EAX
		XOR 	EBX, EBX
		MOV 	BX, SEGS32
		MOV 	AX, TOS32
		SHR 	AX, 4
		ADD 	BX, AX                          ;BX => END OF PROGRAM IN RAM
		SHL 	AX, 4
		CMP 	AX, TOS32
		JZ S1
		INC BX
		
		S1:
		;ADD THE PM_2_RM STACKS
		MOV 	PM2RM_STKEND, BX
		MOV 	AX, PM2RM_STKS
		MUL 	PM2RM_STKLEN
		ADD 	BX, AX
		MOV 	PM2RM_STKCUR, BX

		;FREE UNNEEDED RAM
		MOV 	CX, PSP
		MOV 	ES, CX
		SUB 	BX, CX
		MOV 	AH, 4AH
		INT 	21H                              ;RESIZE MEMORY BLOCK

		;SETUP IDT
		MOV 	DI, OFFSET IDT
		MOV 	SI, OFFSET INTS
		XOR 	CX, CX
		MOV 	DX, WORD PTR PICSLAVE
		
		I1:
		MOV 	[DI], SI
		TEST 	CL, 0F8H
		JZ 		I2             					;1ST 8 INTS?    (WHY? - BUG!)
		MOV 	BL, CL
		AND 	BL, 0F8H       					;ISOLATE HIGH 5 BITS
		CMP 	BL, DH
		JZ 		I2             					;LOW IRQS?
		
		CMP 	BL, DL
		JZ 		I2             					;HIGH IRQS?
		OR 		BYTE PTR[DI+5], 1   			;SET AS A TRAP GATE
		
		I2:
		ADD 	DI, 8
		INC 	SI
		INC 	CL
		JNZ 	I1
		
		;SETUP OTHER INTS
		MOV 	WORD PTR[IDT+3*8], OFFSET INT3H

		;INSTALL OUR INT 21H HANDLER
		MOV 	AX, 3521H
		INT 	21H            					;GET INT 21H
		MOV 	WORD PTR[OLD_INT21H+2], ES
		MOV 	WORD PTR[OLD_INT21H+0], BX
		PUSH 	DS
		POP 	ES

		MOV 	AX, 2521H
		MOV 	DX, OFFSET INT21H_RM
		INT 	21H            					;SET INT 21H

		;WE ARE NOW READY TO MOVE TO 16BIT PMODE  

		CLI   									;NO MORE IRQS ALLOWED PAST THIS POINT

		LIDT 	[IDTR]
		LGDT 	[GDTR]

		;CLEAR NT AND IOPL
		PUSHF
		MOV 	BP, SP
		AND 	WORD PTR [BP+1], 08FH 			;40H = NT BIT , 30H = IOPL BITS
		POPF 

		;GOTO PMODE!
		MOV 	EAX, CR0
		OR 		AL, 1           				;SET PM BIT
		MOV 	CR0, EAX       					;WE ARE NOW IN 16BIT PMODE
		DB 		0EAH           					; JMP FAR PTR SELCODE:$+4
		DW 		$+4,SELCODE16  					;  (CLEAR PREFETCH QUE)

		MOV 	AX, SELDATA16  					;RELOAD ALL VALUES
		MOV 	DS, AX
		MOV 	FS, AX
		MOV 	GS, AX
		MOV 	ES, AX
	                
		MOV 	SS, AX
		MOV 	SP, TOS16

		;LOAD OUR LDT (WHICH IS EMPTY)  (THIS IS NOT NECESSARY)

		MOV 	AX, SELLDT
		LLDT 	AX

		;SETUP A IRETD THAT WILL JUMP INTO OUR 32BIT SEGMENT

		PUSHFD
		PUSH 	DWORD PTR SELCODE32
		PUSH 	DWORD PTR OFFSET START32
		IRETD   								;GOTO 32BIT SEGMENT

	START16 ENDP

;-----------------------------------------------------------------------------

	; PM 2 RM & RM 2 PM   SWITCHING PROC FOR RAW/XMS
	; SAVE/RESTORE PROCS

	PM_2_RM_RX PROC  							;SWITCHES TO RMODE  (RAW/XMS)

		;  AX = NEW DS
		;  CX = NEW ES
		;  DX = NEW SS
		;  BX = NEW SP
		;  SI = NEW CS
		;  DI = NEW IP

		PUSH 	AX   							;SAVE AX
		MOV 	DS, CS:_SELZERO32
		XOR 	EAX, EAX
		MOV 	AX, DX
		SHL 	EAX, 4
		MOVZX 	EBX, BX
		ADD 	EAX, EBX
		PUSHF
		CLI
		POP 	DS:[EAX-2]
		MOV 	DS:[EAX-4], SI
		MOV 	DS:[EAX-6], DI
		POP 	DI    							;POP AX INTO DI
		LIDT 	CS:RM_IDTR
		
		MOV 	AX, SELDATA16
		MOV 	DS, AX
		MOV 	ES, AX
		MOV 	FS, AX
		MOV 	GS, AX
		MOV 	SS, AX
		
		SUB 	EBX, 6   						;MAKE ROOM FOR IRET DATA
		MOV 	ESP, EBX
			
		MOV 	EAX, CR0
		AND 	AL, 0FEH
		MOV 	CR0, EAX     					;NOW IN RMODE
		
		DB 		0EAH
		DW 		$+4, SEGS16
		
		MOV 	SS, DX
		MOV 	DS, DI       					;AX WAS POPED INTO DI
		MOV 	ES, CX
		XOR 	AX, AX
		MOV 	FS, AX
		MOV 	GS, AX
		
		IRET            						;GOTO TARGET ADDR IN REAL MODE
	
	PM_2_RM_RX ENDP

	RM_2_PM_RX PROC  							;SWITCHES TO PMODE FROM RMODE

		;  AX  = NEW DS
		;  CX  = NEW ES
		;  DX  = NEW SS
		;  EBX = NEW ESP
		;  SI  = NEW CS
		;  EDI = NEW EIP

		PUSHFD
		CLI
		PUSH 	AX
		
		LGDT 	CS:GDTR
		LIDT 	CS:IDTR
		
		MOV 	EAX, CR0
		OR 		AL, 1
		MOV 	CR0, EAX
		
		DB 		0EAH
		DW 		$+4, SELCODE16
		
		POP 	DS
		MOV 	ES, CX
		XOR 	AX, AX
		MOV 	FS, AX
		MOV 	GS, AX
		POP 	EAX
		MOV 	SS, DX                       	; LOAD PROTECTED MODE SS:ESP
		MOV 	ESP, EBX
		AND 	AH, 0BFH                     	; SET NT=0 IN OLD EFLAGS
		PUSH 	AX                         		; SET CURRENT FLAGS
		POPF
		PUSH 	EAX                        		; STORE OLD EFLAGS
		PUSH 	ESI                        		; STORE PROTECTED MODE TARGET CS
		PUSH 	EDI                        		; STORE PROTECTED MODE TARGET EIP
		IRETD                           		; GO TO TARGED ADDX IN PROTECTED MODE
	
	RM_2_PM_RX ENDP

	SR_STATE_RX PROC
		RETF   									;NOTHING TO SAVE/RESTORE
	SR_STATE_RX ENDP

	;THIS PROC WAS COPIED ALMOST DIRECTLY FROM PMODE V3.07 - WHY REINVENT THE
	;WHEEL?
	INT3H PROC

												;THIS WILL REDIR INTS (AND IRQS) TO RMODE
		CMP 	DWORD PTR[ESP], OFFSET INTS    	;I ADDED THESE EXTRA CHECKS IN CASE
		JB 		DO3                           	;THIS KERNEL IS DEBUGGED LATER
		
		CMP 	DWORD PTR[ESP], OFFSET INTS+255
		JA 		DO3
		CMP 	WORD PTR[ESP+4], SELCODE16     	;WAS IT FROM OUR INTS TABLE OR IS IT
		JZ 		REDIR                          	; AN EMBEDDED INT 3?
		
		;CONTINUE ON TO NORMAL INT 3 HANDLER
		DO3:
		JMP 	FWORD PTR INT3VECTOR          	; JMP FAR SEL:OFF32 HANDLER
		
		;REDIRECT TO PROPER HANDLER IN RMODE
		REDIR:
		MOV 	[ESP+8], EAX                    ; STORE EAX FOR LATER POPAD
		MOV 	EAX, [ESP]                      ; GET ADDRESS IN REDIRECTION MATRIX
		ADD 	ESP, 8                          ; DISCARD EIP AND CS FROM INT 3
		PUSH 	ECX                             ;-+
		PUSH 	EDX                             ; |
		PUSH 	EBX                             ; |
		PUSH 	ESP                             ; |
		PUSH 	EBP                             ; |
		PUSH 	ESI                             ; |
		PUSH 	EDI                             ;STORE REST OF REGISTERS FOR POPAD
		PUSH 	DS                              ;-+
		PUSH 	ES                              ; |
		PUSH 	FS                              ; |
		PUSH 	GS                              ;STORE ALL SEGMENT REGISTERS

		MOV 	DS, CS:_SELZERO32               ; DS -> 0 (BEGINNING OF MEMORY)
		MOV 	EDI, CS:PRG_BASE16              ; EDI = OFFSET OF SEGS16 FROM 0

		MOV 	DX, CS:PM2RM_STKCUR             ; DX = SS FOR REAL MODE REDIRECTION
		XOR 	EBP, EBP                        ;-+
		MOV 	BP, DX                          ; |
		SHL 	EBP, 4                          ; EBP -> TOP OF REAL MODE STACK
	
		MOV 	BX, CS:PM2RM_STKLEN             ; GET SIZE OF REAL MODE STACK
		SUB 	DX, BX                          ; ADJUST DX TO NEXT STACK LOCATION
		SUB 	DS:PM2RM_STKCUR[EDI], BX        ; UPDATE PTR FOR POSSIBLE REENTERANCY
		SHL 	BX, 4                           ; SET REAL MODE SP TO TOP OF STACK
	
		CMP 	DX, CS:PM2RM_STKEND             ; EXCEEDED REAL MODE STACK SPACE?
		JZ 		CRITICAL_ERROR                  ; IF YES, CRITICAL ERROR (HANG)

		MOV 	DS:[EBP-2], SS                  ; STORE SS:ESP ON REAL MODE STACK
		MOV 	DS:[EBP-6], ESP
	
		SUB 	AX, OFFSET INTS+1               ; AX = INT NUMBER
												; THE +1 IS BECAUSE THE NEXT INSTRUCT
												; TO RETURN TO IS AFTER THE ONE-BYTE
												; INT 3 OPCODE
		MOV 	AH, AL                          ;-+
		AND 	AH, 0F8H                        ; AH = HIGH 5 BITS OF INT NUMBER
	
		CMP 	AH, CS:PICSLAVE                 ; HIGH IRQ?
		JZ 		REDIR_IRQ                       ; IF YES, DO IRQ
		CMP 	AH, CS:PICMASTER                ; LOW IRQ?
		JNZ 	REDIR_INT                       ; IF NO, DO INT (WITH GENERAL REGS)
		
		;-----------------------------------------------------------------------------
		REDIR_IRQ:                             	; AN IRQ REDIRECTION
		MOV 	DS:IRQNUM[EDI], AL              ; MODIFY CODE WITH INTERRUPT NUMBER
	
		MOV 	SI, SEGS16                      ; REAL MODE TARGET CS:IP
		MOV 	DI, OFFSET R1       
		SUB 	BX, 6                           ; ADJUST REAL MODE SP FOR STORED VARS

		DB 		66H                             ; JMP DWORD PTR, AS IN 32BIT OFFSET,
		JMP 	WORD PTR CS:PM_2_RM             ;  NOT SEG:16BIT OFFSET

		R1:
		DB 		0CDH                           	; INT IRQNUM
		IRQNUM 	DB ?

		MOV 	AX, SELZERO32                 	; DS SELECTOR VALUE FOR PROTECTED MODE
		MOV 	CX, AX                         	; ES SELECTOR VALUE FOR PROTECTED MODE
		POP 	EBX                            	; GET PROTECTED MODE SS:ESP FROM STACK
		POP 	DX
		MOV 	SI, SELCODE16                  	; TARGET CS:EIP IN PROTECTED MODE
		MOV 	EDI, OFFSET R2
	
		JMP 	CS:RM_2_PM                    	; GO BACK TO PROTECTED MODE
	
		R2:	
		MOV 	EDI, CS:PRG_BASE16             	; RESLEASE REAL MODE STACK
		MOV 	AX, CS:PM2RM_STKLEN
		ADD 	DS:PM2RM_STKCUR[EDI], AX
	
		POP 	GS                               ;-+
		POP 	FS                               ; |
		POP 	ES                               ; |
		POP 	DS                               ; |
		POPAD                                	;RESTORE ALL REGISTERS
		IRETD

		;-----------------------------------------------------------------------------
		REDIR_INT:                             	; AN INT REDIRECTION
		MOV 	DS:INTNUM[EDI], AL            	; MODIFY CODE WITH INTERRUPT NUMBER
	
		MOV 	ES, CS:_SELZERO32            	; COPY REGISTERS FROM PROTECTED MODE
		LEA 	EDI, [EBP-26H]                 	;  STACK TO REAL MODE STACK
		LEA 	ESI, [ESP+8]                   	; ESP+8 => POPAD
		MOV 	ECX, 8
		CLD	
		REP 	MOVSD ES:[EDI], SS:[ESI]      	; NOTE THE SS OVERRIDE!
	
		MOV 	SI, SEGS16                  	; REAL MODE TARGET CS:IP
		MOV 	DI, OFFSET I1
		SUB 	BX, 26H                      	; ADJUST REAL MODE SP FOR STORED VARS

		DB 		66H                         	; JMP DWORD PTR, AS IN 32BIT OFFSET,
		JMP 	WORD PTR CS:PM_2_RM          	;  NOT SEG:16BIT OFFSET

		I1:
		POPAD                                	; LOAD REGS WITH INT CALL VALUES

		DB 		0CDH                         	; INT INTNUM
		INTNUM 	DB ?

		PUSHAD                               	; STORE REGISTERS ON STACK
		PUSHF                                	; STORE FLAGS ON STACK
		CLI
		CLD

		XOR 	EAX, EAX                      	; EAX = LINEAR PTR TO SS
		MOV 	AX, SS
		SHL 	EAX, 4
		MOVZX 	EBP, SP                         ; EBP = SP

		MOV 	EBX, [BP+22H]                  	; GET PROTECTED MODE SS:ESP FROM STACK
		MOV 	DX, [BP+26H]

		ADD 	EBP, EAX                      	; EBP -> STORED REGS ON STACK

		MOV 	AX, SELZERO32                 	; DS SELECTOR VALUE FOR PMODE ZERO32
		MOV 	CX, DX                         	; ES SELECTOR VALUE FOR PMODE STACK
		MOV 	SI, SELCODE16                  	; TARGET CS:EIP IN PROTECTED MODE
		MOV 	EDI, OFFSET I2
	
		JMP 	CS:RM_2_PM                    	; GO BACK TO PROTECTED MODE
	
		I2:	
		MOV 	AX, DS:[EBP]                  	; MOVE RETURN FLAGS FROM REAL MODE
		AND 	AX, 8D5H                      	;  STACK TO PROTECTED MODE STACK
		MOV 	BX, [ESP+30H]
		AND 	BX, NOT 8D5H
		OR 		AX, BX                        	; MERGE PMODE/RMODE FLAGS
		MOV 	[ESP+30H], AX                 	; PUT FLAGS ONTO IRETD

		LEA 	ESI, [EBP+2]                   	;DS:ESI => RMODE PUSHAD
		LEA 	EDI, [ESP+8]                   	;ES:EDI => PMODE POPAD
		MOV 	ECX, 8
		DB 		67H                            	;-+
		REP 	MOVSD                          	; COPY FROM RMODE STACK TO PMODE STACK

		MOV 	EDI, CS:PRG_BASE16             	; RELEASE  REAL MODE STACK
		MOV 	AX, CS:PM2RM_STKLEN
		ADD 	DS:PM2RM_STKCUR[EDI], AX

		POP 	GS                              ;-+
		POP 	FS                              ; |
		POP 	ES                              ; |
		POP 	DS                              ; |
		POPAD                                	; RESTORE ALL REGS
		IRETD
		
	INT3H ENDP

	CRITICAL_ERROR PROC                    		; SOME UNRECOVERABLE ERROR
		CLI                                  	; MAKE SURE WE ARE NOT INTERRUPTED
		IN 		AL, 61H                        	; BEEP
		OR 		AL, 3
		OUT 	61H, AL
		JMP 	$                             	; NOW HANG
	CRITICAL_ERROR ENDP

	INT21H_RM PROC  							;INT 21H HANDLER (RMODE)
	
		CMP 	AH, 4CH                       	; IS PROGRAM TERMINATING?
		JZ 		EXIT
		JMP 	CS:OLD_INT21H                  	;NO, CONTINUE ON TO OLD INT 21H HANDLER
		
		EXIT:                                  	;YES, PROGRAM IS TERMINATING
		PUSH 	EAX
		XOR 	AX, AX
		MOV 	DS, AX
		MOV 	EAX, CS:OLD_INT21H
		MOV 	DS:[21H*4], EAX              	;RESTORE OLD INT 21H HANDLER
		CMP 	CS:MODE,MODE_XMS
		JZ 		EXIT_XMS                       	; JMP TO XMS CLEAN-UP

		MOV 	EAX, CS:OLD_INT15H             	;INT 15H CLEAN-UP
		MOV 	DS:[15H*4], EAX               	;RESTORE OLD INT 15H HANDLER
		POP 	EAX
		JMP 	CS:OLD_INT21H

		EXIT_XMS:                              	; XMS CLEAN-UP
		MOV 	AH, 0AH
		MOV 	DX, CS:XMS_EMB
		CALL 	CS:[XMS_CALL]                 	; FREE RAM USED
		POP 	EAX
		JMP 	CS:OLD_INT21H                 	; CONTINUE ON TO OLD INT 21H HANDLER
		
	INT21H_RM ENDP

CODE16SEG ENDS

ASSUME CS:SEGS32,DS:SEGS32,SS:SEGS32,ES:NOTHING

DATA32SEG SEGMENT USE32

	X 				DD 0     					;COORDS OF CURSOR ON SCREEN
	Y 				DD 0
	TIMER 			DW 0

												;32BIT MESSAGES
	MSG32_TIMER 	DB ' = TIMER',13,0
	MSG32_WELCOME 	DB 'WELCOME TO 32BIT PMODE!',13,0
	MSG32_KBD 		DB 'TEST OUT THE KEYBOARD, PRESS ESC TO QUIT!',13,0
	KEY 			DB ?, 0
	
DATA32SEG ENDS

CODE32SEG SEGMENT USE32

	START32 PROC
	
												;RELOAD ALL SEGMENT REGS WITH 32BIT SELECTORS
		MOV 	AX, SELDATA32
		MOV 	DS, AX
		MOV 	SS, AX
		MOV 	FS, AX
		MOV 	GS, AX
		MOV 	ESP, TOS32
		MOV 	AX, SELVID
		MOV 	ES, AX

		CALL 	CLRSCR   						;CLEAR THE SCREEN

		MOV 	ESI, OFFSET MSG32_TIMER
		CALL 	PRINT

		MOV 	ESI, OFFSET MSG32_WELCOME
		CALL 	PRINT

		MOV 	AX, SELCODE32
		MOV 	EDX, OFFSET TIMER_IRQ
		MOV 	BL, 8
		CALL 	SETINT

		STI  									;ENABLE IRQS

		G1:
		MOV 	ECX, 0FFFFH
		LOOP 	$            					;MAKE A SMALL DELAY SO IRQ#0 WILL HAVE A CHANCE TO
												;OCCUR WHILE IN PMODE

		MOV 	AH, 0BH
		INT 	21H
		CMP 	AL, 0
		JZ 		G1         						;NO KEY AVAIL?

		MOV 	AX, 0
		INT 	16H

		CMP 	AH, 1      						;IS IT THE ESC SCAN CODE?
		JZ 		QUIT       						;YES THEN QUIT
		MOV 	KEY, AL
		MOV 	ESI, OFFSET KEY
		CALL 	PRINT
		JMP 	G1

		QUIT:
		MOV 	AX, 4C00H
		INT 	21H  							;QUIT PROGRAM

	START32 ENDP

	CLRSCR PROC
	
		XOR 	EDI, EDI         				;LINEAR ADDR OF 0B800:0  (BASE=0B8000H)
		MOV 	ECX, 80*25
		MOV 	AX, 720H         				;07H=WHITE ON BLACK 20H=SPACES
		REP 	STOSW
		MOV 	X, 0
		MOV 	Y, 0
		RET
		
	CLRSCR ENDP

	;ESI = STRING TO PRINT
	PRINT PROC
	
		P0:
		MOV 	EDI, Y
		IMUL 	EDI, EDI,80*2    				;80*2 = # BYTES/ROW (IN TEXT MODE)D
		ADD 	EDI, X
		ADD 	EDI, X            				;ADD TWICE TO SKIP OVER COLOR BYTES TOO
		P1:
		CMP 	BYTE PTR[ESI], 0
		JZ 		P3
		CMP 	BYTE PTR[ESI], 13
		JZ 		P13
		MOVSB                					;DS:ESI => ES:EDI
		INC 	EDI              				;SKIP OVER COLOR BYTE
		INC 	X
		CMP 	X, 80
		JNZ 	P1
		P2:                    					;SKIP TO NEXT LINE
		MOV 	X, 0
		INC 	Y
		CMP 	Y, 25
		JNZ 	P0
		MOV 	Y, 0
		JMP 	P0
		P13:
		INC 	ESI
		JMP 	P2
		P3:
		RET
		
	PRINT ENDP

	TIMER_IRQ PROC
	
												;THIS IS CARLED DURING IRQ#0
		PUSH 	EAX
		PUSH 	ES
		PUSH 	DS
		MOV 	ES, CS:_SELVID
		MOV 	DS, CS:_SELDATA32
		MOV 	AX, TIMER
		INC 	TIMER
		MOV 	BYTE PTR ES:[0], AL
		MOV 	AL, 20H
		OUT 	20H, AL                        	;ACK IRQ
		POP 	DS
		POP 	ES
		POP 	EAX
		IRETD
		
	TIMER_IRQ ENDP

	SETINT PROC
	
		;SETS ONE OF THE EXCEPTION HANDLERS TO A NEW 32BIT LOCATION
		;BY DEFAULT ALL INTS GOTO RMODE
		;IN : AX=SELECTOR
		;   :EDX=OFFSET
		;   : BL=INT #  (CURRENTLY ONLY 0-31 ARE ALLOWED - WE WILL MAKE OUR IDT
		;                FULL SIZE -256 VEKTORZ- IN THE NEXT TUTORIAL) 
		
		MOVZX 	EBX, BL
		MOV 	CX, SELDATA16
		MOV 	DS, CX
		MOV 	ESI, OFFSET IDT
		MOV 	[ESI+EBX*8], DX                	; SET THE OFFSET (0-15)
		MOV 	[ESI+EBX*8+2], AX              	; SET THE SELECTOR
		SHR 	EDX, 16
		MOV 	[ESI+EBX*8+6], DX             	; SET THE OFFSET (16-31)
		MOV 	CX, SELDATA32
		MOV 	DS, CX
		RET
		
	SETINT ENDP

CODE32SEG ENDS

END START16     ;START PROGRAM IN SEGS16:START16

