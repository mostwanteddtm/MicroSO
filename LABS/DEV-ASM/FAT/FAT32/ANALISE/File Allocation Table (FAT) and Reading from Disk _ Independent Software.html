<!DOCTYPE html>
<!-- saved from url=(0113)http://www.independent-software.com/operating-system-development-file-allocation-table-and-reading-from-disk.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Operating System Development: File Allocation Table (FAT) and Reading from Disk | Independent Software</title><meta name="generator" content="Jekyll v3.8.0"><meta property="og:title" content="Operating System Development: File Allocation Table (FAT) and Reading from Disk"><meta name="author" content="Alexander van Oostenrijk"><meta property="og:locale" content="en_US"><meta name="description" content="In the previous parts of this guide, we wrote assembly code for a simple boot sector and set up the GNU toolchain we use for compiling it and writing it to a floppy disk image. We then used the Bochs IA-32 emulator to boot from that image and see it run. Our current boot loader resets the drive system, writes a “loading” messages to the screen, waits for a keypress and reboots. It’s now time to make it do what it’s supposed to do: find our kernel file on the disk, so it can be loaded into memory and run. This article is part of a series on toy operating system development. View the series index"><meta property="og:description" content="In the previous parts of this guide, we wrote assembly code for a simple boot sector and set up the GNU toolchain we use for compiling it and writing it to a floppy disk image. We then used the Bochs IA-32 emulator to boot from that image and see it run. Our current boot loader resets the drive system, writes a “loading” messages to the screen, waits for a keypress and reboots. It’s now time to make it do what it’s supposed to do: find our kernel file on the disk, so it can be loaded into memory and run. This article is part of a series on toy operating system development. View the series index"><link rel="canonical" href="http://www.independent-software.com/operating-system-development-file-allocation-table-and-reading-from-disk.html"><meta property="og:url" content="http://www.independent-software.com/operating-system-development-file-allocation-table-and-reading-from-disk.html"><meta property="og:site_name" content="Independent Software"><meta property="og:image" content="http://www.independent-software.com/assets/svg/monolith.svg"><meta property="og:type" content="article"><meta property="article:published_time" content="2012-04-12T10:37:09+02:00"> <script src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/f(5).txt"></script><script src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/ca-pub-3185318852689730.js.download"></script><script async="" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/analytics.js.download"></script><script type="application/ld+json"> {"description":"In the previous parts of this guide, we wrote assembly code for a simple boot sector and set up the GNU toolchain we use for compiling it and writing it to a floppy disk image. We then used the Bochs IA-32 emulator to boot from that image and see it run. Our current boot loader resets the drive system, writes a “loading” messages to the screen, waits for a keypress and reboots. It’s now time to make it do what it’s supposed to do: find our kernel file on the disk, so it can be loaded into memory and run. This article is part of a series on toy operating system development. View the series index","author":{"@type":"Person","name":"Alexander van Oostenrijk"},"@type":"BlogPosting","url":"http://www.independent-software.com/operating-system-development-file-allocation-table-and-reading-from-disk.html","image":"http://www.independent-software.com/assets/svg/monolith.svg","headline":"Operating System Development: File Allocation Table (FAT) and Reading from Disk","dateModified":"2012-04-12T10:37:09+02:00","datePublished":"2012-04-12T10:37:09+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.independent-software.com/operating-system-development-file-allocation-table-and-reading-from-disk.html"},"@context":"http://schema.org"}</script><link href="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/css(1)" rel="stylesheet"><link rel="stylesheet" href="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.independent-software.com/feed.xml" title="Independent Software"><script> if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) { (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-62113986-2', 'auto'); ga('send', 'pageview'); } </script><script src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/embed.js.download" data-timestamp="1542826278844"></script><link rel="preload" href="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/f(6).txt" as="script"><script type="text/javascript" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/f(6).txt"></script><link rel="preload" href="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/f(7).txt" as="script"><script type="text/javascript" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/f(7).txt"></script><link rel="preload" href="http://pagead2.googlesyndication.com/pagead/js/r20181107/r20180604/show_ads_impl.js" as="script"><link rel="preload" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.d49f53e192b9080ef8880a7c9b24f1c3.css"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.18932c85febf9520158697cdc31f08ae.js"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.e7b46487e9e041aabc7c7cff31722578.js"><link rel="preload" as="script" href="https://disqus.com/next/config.js"><script src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/alfalfa.4a5fcca1fe50a757044dfd331b660625.js.download" async="" charset="UTF-8"></script></head><body><nav style="position: fixed"><div class="wrapper"> <a class="logo" href="http://www.independent-software.com/"><img src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/independent-software-logo.svg"></a> <input type="checkbox" id="nav-trigger" class="nav-trigger"> <label for="nav-trigger"> <svg viewBox="0 0 18 15" width="18px" height="15px"><path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path> </svg> </label><div class="trigger"> <a href="http://www.independent-software.com/about-independent-software.html">About</a> <a href="http://www.independent-software.com/philosophy.html">Philosophy</a> <a href="http://www.independent-software.com/web-development.html">Web Development</a> <a href="http://www.independent-software.com/portfolio.html">Portfolio</a> <a href="http://www.independent-software.com/blog.html">Blog</a></div></div></nav><main aria-label="Content" class="post"><article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting"><div class="post-image"><div class="post-image-inner" style="background-image: url(/assets/svg/monolith.svg);"></div></div><header class="post-header"><div class="post-header-content"><div class="categories"> <a href="http://www.independent-software.com/category/osdev.html" class="category">osdev</a> <a href="http://www.independent-software.com/category/asm.html" class="category">asm</a></div><h1 class="post-title p-name" itemprop="name headline"><div class="subtitle">OPERATING SYSTEM DEVELOPMENT</div><div class="title"> FILE ALLOCATION TABLE (FAT) AND READING FROM DISK</div></h1></div></header><div class="clear">-</div><section><header class="post-data"><p class="post-meta"> <time class="dt-published" datetime="2012-04-12T10:37:09+02:00" itemprop="datePublished">Apr 12, 2012 </time></p></header><div class="post-content e-content" itemprop="articleBody"><p>In the previous parts of this guide, we wrote assembly code for a simple boot sector and set up the GNU toolchain we use for compiling it and writing it to a floppy disk image. We then used the Bochs IA-32 emulator to boot from that image and see it run.</p><p>Our current boot loader resets the drive system, writes a “loading” messages to the screen, waits for a keypress and reboots. It’s now time to make it do what it’s supposed to do: find our kernel file on the disk, so it can be loaded into memory and run.</p><p>This article is part of a <strong>series on toy operating system development.</strong></p><p><a href="http://www.independent-software.com/operating-system-development.html" class="btn">View the series index</a></p><script async="" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/f(8).txt"></script> <ins class="adsbygoogle" style="display: block; height: 90px;" data-ad-client="ca-pub-3185318852689730" data-ad-slot="5695790800" data-ad-format="auto" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:800px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:800px;background-color:transparent;"><iframe width="800" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:800px;height:90px;" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/saved_resource(1).html"></iframe></ins></ins></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <!--more--><h2 id="reading-from-disk">Reading from disk</h2><p>Before we get into how to find a file, we need to get some basics sorted first: we need some way to actually read data from our disk. Reading from a disk is done through calling BIOS interrupts (built-in functions that come with the BIOS of any computer). We’ll require interrupt 0x13, subfunction 2. Its arguments are these:</p><div class="table"><table rules="groups"><thead><tr><th style="text-align: left">Register</th><th style="text-align: left">Value</th></tr></thead><tbody><tr><td style="text-align: left"><code class="highlighter-rouge">al</code></td><td style="text-align: left">Number of sectors to read</td></tr><tr><td style="text-align: left"><code class="highlighter-rouge">ah</code></td><td style="text-align: left">Subfunction 2</td></tr><tr><td style="text-align: left"><code class="highlighter-rouge">ch</code></td><td style="text-align: left">Low 8 bits of cylinder</td></tr><tr><td style="text-align: left"><code class="highlighter-rouge">cl</code></td><td style="text-align: left">High 2 bits of cylinder, 6 bits for sector</td></tr><tr><td style="text-align: left"><code class="highlighter-rouge">dh</code></td><td style="text-align: left">Head number</td></tr><tr><td style="text-align: left"><code class="highlighter-rouge">dl</code></td><td style="text-align: left">Drive number</td></tr><tr><td style="text-align: left"><code class="highlighter-rouge">es:bx</code></td><td style="text-align: left">Data buffer</td></tr></tbody></table></div><p>The interrupt tries to read one or more sectors from disk, and sets the carry flag if it fails. Failures are common, and read operations should always be tried several times before giving up.</p><h2 id="logical-block-addressing-lba">Logical Block Addressing (LBA)</h2><p>Did you notice the <em>track</em> and <em>head</em> parameters? So far we’ve been talking about sectors only. In facts, we’ve assumed that a disk is simply a long sequential list of sectors. That would be nice, but reality is not nice in this case. We’ve been thinking in terms of what is known as <em>Logical Block Addressing</em> (LBA), while actual disks work differently. Disks can actually have multiple sides that are read by multiple reading heads. Also, sectors are grouped in tracks or cylinders (like on a vinyl record) which further complicates matters. However, the math required to convert an LBA number to a head, cylinder and sector combination is this:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">Sector</span>   <span class="o">=</span> <span class="p">(</span><span class="n">LBA</span> <span class="n">mod</span> <span class="n">SectorsPerTrack</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">Cylinder</span> <span class="o">=</span> <span class="p">(</span><span class="n">LBA</span> <span class="o">/</span> <span class="n">SectorsPerTrack</span><span class="p">)</span> <span class="o">/</span> <span class="n">NumHeads</span>
<span class="n">Head</span>     <span class="o">=</span> <span class="p">(</span><span class="n">LBA</span> <span class="o">/</span> <span class="n">SectorsPerTrack</span><span class="p">)</span> <span class="n">mod</span> <span class="n">NumHeads</span></code></pre></figure><p>What we need to do, then, is write a function that converts an LBA number into these low-level values, reads a sector, and gives it back. That way, the rest of our code can focus on thinking in terms of logical block addresses which avoids headaches.</p><h2 id="read-sector-code">Read sector code</h2><p>Here is the code that reads a logical sector from disk:</p><figure class="highlight"><pre><code class="language-as" data-lang="as"><span class="c"># buffer at ES:BX. This function uses interrupt 13h, subfunction ah=2.</span>
<span class="p">.</span><span class="kr">func</span> <span class="n">ReadSector</span>
<span class="n">ReadSector</span><span class="o">:</span>
  <span class="k">xor</span>     <span class="n">cx</span><span class="p">,</span> <span class="n">cx</span>                      <span class="c"># Set try count = 0</span>
 
 <span class="n">readsect</span><span class="o">:</span>
  <span class="k">push</span>    <span class="n">ax</span>                          <span class="c"># Store logical block</span>
  <span class="k">push</span>    <span class="n">cx</span>                          <span class="c"># Store try number</span>
  <span class="k">push</span>    <span class="n">bx</span>                          <span class="c"># Store data buffer offset</span>
 
  <span class="c"># Calculate cylinder, head and sector:</span>
  <span class="c"># Cylinder = (LBA / SectorsPerTrack) / NumHeads</span>
  <span class="c"># Sector   = (LBA mod SectorsPerTrack) + 1</span>
  <span class="c"># Head     = (LBA / SectorsPerTrack) mod NumHeads</span>
 
  <span class="k">mov</span>     <span class="n">bx</span><span class="p">,</span> <span class="n">iTrackSect</span>              <span class="c"># Get sectors per track</span>
  <span class="k">xor</span>     <span class="n">dx</span><span class="p">,</span> <span class="n">dx</span>
  <span class="k">div</span>     <span class="n">bx</span>                          <span class="c"># Divide (dx:ax/bx to ax,dx)</span>
                                      <span class="c"># Quotient (ax) =  LBA / SectorsPerTrack</span>
                                      <span class="c"># Remainder (dx) = LBA mod SectorsPerTrack</span>
  <span class="k">inc</span>     <span class="n">dx</span>                          <span class="c"># Add 1 to remainder, since sector</span>
  <span class="k">mov</span>     <span class="n">cl</span><span class="p">,</span> <span class="n">dl</span>                      <span class="c"># Store result in cl for int 13h call.</span>
 
  <span class="k">mov</span>     <span class="n">bx</span><span class="p">,</span> <span class="n">iHeadCnt</span>                <span class="c"># Get number of heads</span>
  <span class="k">xor</span>     <span class="n">dx</span><span class="p">,</span> <span class="n">dx</span>
  <span class="k">div</span>     <span class="n">bx</span>                          <span class="c"># Divide (dx:ax/bx to ax,dx)</span>
                                      <span class="c"># Quotient (ax) = Cylinder</span>
                                      <span class="c"># Remainder (dx) = head</span>
  <span class="k">mov</span>     <span class="n">ch</span><span class="p">,</span> <span class="n">al</span>                      <span class="c"># ch = cylinder                      </span>
  <span class="k">xchg</span>    <span class="n">dl</span><span class="p">,</span> <span class="n">dh</span>                      <span class="c"># dh = head number</span>
 
  <span class="c"># Call interrupt 0x13, subfunction 2 to actually</span>
  <span class="c"># read the sector.</span>
  <span class="c"># al = number of sectors</span>
  <span class="c"># ah = subfunction 2</span>
  <span class="c"># cx = sector number</span>
  <span class="c"># dh = head number</span>
  <span class="c"># dl = drive number</span>
  <span class="c"># es:bx = data buffer</span>
  <span class="c"># If it fails, the carry flag will be set.</span>
  <span class="k">mov</span>     <span class="n">ax</span><span class="p">,</span> <span class="mh">0x0201</span>                  <span class="c"># Subfunction 2, read 1 sector</span>
  <span class="k">mov</span>     <span class="n">dl</span><span class="p">,</span> <span class="n">iBootDrive</span>              <span class="c"># from this drive</span>
  <span class="k">pop</span>     <span class="n">bx</span>                          <span class="c"># Restore data buffer offset.</span>
  <span class="k">int</span>     <span class="mh">0x13</span>
  <span class="k">jc</span>      <span class="n">readfail</span>
 
  <span class="c"># On success, return to caller.</span>
  <span class="k">pop</span>     <span class="n">cx</span>                          <span class="c"># Discard try number</span>
  <span class="k">pop</span>     <span class="n">ax</span>                          <span class="c"># Get logical block from stack</span>
  <span class="k">ret</span>
 
  <span class="c"># The read has failed.</span>
  <span class="c"># We will retry four times total, then jump to boot failure.</span>
 <span class="n">readfail</span><span class="o">:</span>   
  <span class="k">pop</span>     <span class="n">cx</span>                          <span class="c"># Get try number             </span>
  <span class="k">inc</span>     <span class="n">cx</span>                          <span class="c"># Next try</span>
  <span class="k">cmp</span>     <span class="n">cx</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="mi">4</span>              <span class="c"># Stop at 4 tries</span>
  <span class="k">je</span>      <span class="n">bootFailure</span>
 
  <span class="c"># Reset the disk system:</span>
  <span class="k">xor</span>     <span class="n">ax</span><span class="p">,</span> <span class="n">ax</span>
  <span class="k">int</span>     <span class="mh">0x13</span>
 
  <span class="c"># Get logical block from stack and retry.</span>
  <span class="k">pop</span>     <span class="n">ax</span>
  <span class="k">jmp</span>     <span class="n">readsect</span>
<span class="p">.</span><span class="kr">endfunc</span></code></pre></figure><p>This code will attempt to read the sector with LBA specified in <code class="highlighter-rouge">AX</code> up to four times before giving up and jumping to <em>bootFailure</em>. After each failed read attempt, the disk system is reset. Most of the code focuses on doing the divisions required to get the values needed by the interrupt call. If all goes well, the sector’s 512 bytes are placed in <code class="highlighter-rouge">ES:BX</code>.</p><p>As a side note, we’re actually lucky to have interrupt 0x13 at this stage. Once we’ve put our processor in protected mode, we won’t have access to the BIOS anymore (all its code only runs in 16-bit real mode) and we’ll have to access the disk drive ourselves which is <em>very</em> tricky.</p><h2 id="introduction-to-fat">Introduction to FAT</h2><p>There are <a href="http://en.wikipedia.org/wiki/List_of_file_systems">many file systems</a> in use these days (NTFS, ext, BFS, UFS, etc.) and we need to pick one to use for our bootable disk. <em>FAT</em> (“File Allocation Table”) is not the most advanced system available, but it’s simple, and on Windows we have the tools to format a disk with it. Plus, <a href="http://www.chrysocome.net/rawwrite">rawrite</a> and ImageFS understand it. At a later stage in the development of a toy OS, you can implement support for bags of other file systems if you want.</p><p>There is no actual requirement to use any file system. A (floppy) disk is just a bag of bytes, grouped in sectors, clusters and tracks (we’ll get to that), that you can read from and write to. The BIOS expects the first sector of a bootable to disk to be a boot sector, but that’s the only requirement. However, at some point we’ll want to store files and it’s a good idea to pick a file system now, so FAT it is.</p><p>FAT comes in different flavors. There’s FAT12, FAT16 and FAT32. The difference is in the size of the disk supported. For FAT12, references to sectors on disk can be up to 12 bits (a maximum value of 4,096 sectors), while with FAT32 we can point to 4,294,967,296 sectors. Since we’re working with floppy disks, FAT12 is enough. The discussion below applies to all FAT versions.</p><p>The basic structure of a 720 KB floppy disk formatted with FAT is this:</p><div class="table"><table rules="groups"><thead><tr><th style="text-align: left">Region</th><th style="text-align: right">Size</th></tr></thead><tbody><tr><td style="text-align: left">Boot sector</td><td style="text-align: right">1</td></tr><tr><td style="text-align: left">File allocation table (FAT)</td><td style="text-align: right">18</td></tr><tr><td style="text-align: left">Root directory</td><td style="text-align: right">14</td></tr><tr><td style="text-align: left">Data area</td><td style="text-align: right">1407</td></tr></tbody></table></div><p>A 720 KB floppy disk contains 1440 512-byte sectors, some of which are reserved as shown. The remaining 1,407 sectors contain the data of our files.</p><h2 id="the-boot-sector">The boot sector</h2><p>Here is a quick refresher of the layout of the boot sector (see also <a href="http://www.independent-software.com/operating-system-development-boot-sector-structure.html">the first part of this guide</a>).</p><div class="table"><table rules="groups"><thead><tr><th style="text-align: left">Offset</th><th style="text-align: right">Size</th><th style="text-align: left">Section</th><th style="text-align: left">Contents</th><th style="text-align: right">Typical value</th></tr></thead><tbody><tr><td style="text-align: left">0000</td><td style="text-align: right">3</td><td style="text-align: left">Code</td><td style="text-align: left">Jump to rest of code</td><td style="text-align: right">&nbsp;</td></tr></tbody><tbody><tr><td style="text-align: left">0003</td><td style="text-align: right">8</td><td style="text-align: left">BPB</td><td style="text-align: left">OEM name</td><td style="text-align: right">Great-OS</td></tr><tr><td style="text-align: left">0011</td><td style="text-align: right">2</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Bytes per sector</td><td style="text-align: right">512</td></tr><tr><td style="text-align: left">0013</td><td style="text-align: right">1</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Number of sectors per cluster</td><td style="text-align: right">1</td></tr><tr><td style="text-align: left">0014</td><td style="text-align: right">2</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Number of reserved sectors</td><td style="text-align: right">1</td></tr><tr><td style="text-align: left">0016</td><td style="text-align: right">1</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Number of FAT tables</td><td style="text-align: right">2</td></tr><tr><td style="text-align: left">0017</td><td style="text-align: right">2</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Number of root directory entries (usually 224)</td><td style="text-align: right">224</td></tr><tr><td style="text-align: left">0019</td><td style="text-align: right">2</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Total number of sectors</td><td style="text-align: right">2880</td></tr><tr><td style="text-align: left">0021</td><td style="text-align: right">1</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Media descriptor</td><td style="text-align: right">0xf0</td></tr><tr><td style="text-align: left">0022</td><td style="text-align: right">2</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Number of sectors per FAT</td><td style="text-align: right">9</td></tr><tr><td style="text-align: left">0024</td><td style="text-align: right">2</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Number of sectors/track</td><td style="text-align: right">9</td></tr><tr><td style="text-align: left">0026</td><td style="text-align: right">2</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Number of heads</td><td style="text-align: right">2</td></tr><tr><td style="text-align: left">0028</td><td style="text-align: right">2</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Number of hidden sectors</td><td style="text-align: right">0</td></tr></tbody><tbody><tr><td style="text-align: left">0030</td><td style="text-align: right">2</td><td style="text-align: left">EBPB</td><td style="text-align: left">Number of hidden sectors (high word)</td><td style="text-align: right">0</td></tr><tr><td style="text-align: left">0032</td><td style="text-align: right">4</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Total number of sectors in filesystem</td><td style="text-align: right">&nbsp;</td></tr><tr><td style="text-align: left">0036</td><td style="text-align: right">1</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Logical drive number</td><td style="text-align: right">0</td></tr><tr><td style="text-align: left">0037</td><td style="text-align: right">1</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Reserved</td><td style="text-align: right">&nbsp;</td></tr><tr><td style="text-align: left">0038</td><td style="text-align: right">1</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Extended signature</td><td style="text-align: right">0x29</td></tr><tr><td style="text-align: left">0039</td><td style="text-align: right">4</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Serial number</td><td style="text-align: right">&nbsp;</td></tr><tr><td style="text-align: left">0043</td><td style="text-align: right">11</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Volume label</td><td style="text-align: right">MYVOLUME</td></tr><tr><td style="text-align: left">0054</td><td style="text-align: right">8</td><td style="text-align: left">&nbsp;</td><td style="text-align: left">Filesystem type</td><td style="text-align: right">FAT16</td></tr></tbody><tbody><tr><td style="text-align: left">0062</td><td style="text-align: right">448</td><td style="text-align: left">Code</td><td style="text-align: left">Boot code</td><td style="text-align: right">&nbsp;</td></tr></tbody><tbody><tr><td style="text-align: left">0510</td><td style="text-align: right">2</td><td style="text-align: left">Required</td><td style="text-align: left">Boot signature</td><td style="text-align: right">0xaa55</td></tr></tbody></table></div><p>I’ve filled this table with the values you would typically get for a 720 KB floppy disk formatted with FAT. The values in the boot sector are used to determine where exactly on the disk the FAT tables and the root directory live.</p><h2 id="the-root-directory">The root directory</h2><p>In order to find a file on the disk, we need to start by looking at the root directory. This is a list of up to 224 entries (according to the boot sector) of 32 bytes each. Each entry contains data about a file:</p><div class="table"><table rules="groups"><thead><tr><th style="text-align: left">Offset</th><th style="text-align: right">Size</th><th style="text-align: left">Description</th></tr></thead><tbody><tr><td style="text-align: left">0x00</td><td style="text-align: right">8</td><td style="text-align: left">File name</td></tr><tr><td style="text-align: left">0x08</td><td style="text-align: right">3</td><td style="text-align: left">File extension</td></tr><tr><td style="text-align: left">0x0b</td><td style="text-align: right">1</td><td style="text-align: left">Attribute</td></tr><tr><td style="text-align: left">0x0c</td><td style="text-align: right">1</td><td style="text-align: left">Reserved</td></tr><tr><td style="text-align: left">0x0d</td><td style="text-align: right">1</td><td style="text-align: left">Creation timestamp</td></tr><tr><td style="text-align: left">0x0e</td><td style="text-align: right">2</td><td style="text-align: left">Creation time</td></tr><tr><td style="text-align: left">0x10</td><td style="text-align: right">2</td><td style="text-align: left">Creation date</td></tr><tr><td style="text-align: left">0x12</td><td style="text-align: right">2</td><td style="text-align: left">Last access date</td></tr><tr><td style="text-align: left">0x14</td><td style="text-align: right">2</td><td style="text-align: left">Reserved</td></tr><tr><td style="text-align: left">0x16</td><td style="text-align: right">2</td><td style="text-align: left">Last modified time</td></tr><tr><td style="text-align: left">0x18</td><td style="text-align: right">2</td><td style="text-align: left">Last modified date</td></tr><tr><td style="text-align: left">0x1a</td><td style="text-align: right">2</td><td style="text-align: left">Cluster</td></tr><tr><td style="text-align: left">0x1c</td><td style="text-align: right">4</td><td style="text-align: left">File size (bytes)</td></tr></tbody></table></div><p>So the root directory is a list of files on disk. In order to find our kernel file, all we need to do is read it and look for the kernel filename (“KERNEL.BIN” would be good). The directory entry then tells us in which cluster the file resides.</p><h2 id="finding-a-file-on-disk">Finding a file on disk</h2><p>The original boot sector code for DOS and Windows 95 required that the OS kernel file (IO.SYS) be the first file in the root directory of the boot disk. This allowed the programmer to write less code: he did not have to scan the disk’s root directory looking for the file but could simply assume that the file would reside at a fixed position. We can do better, though, by actually scanning the root directory to find our file – and you will see that it’s still possible to squeeze all required code in the 448 bytes that we’re allowed to use.</p><p>In order to find a file, we need to take the following steps:</p><ul><li>Prepare a memory area to load sectors of the root directory into (one sector at a time will do)</li><li>Calculate the size of the root directory in sectors</li><li>Figure out where the root directory starts on disk (see above)</li><li>For each sector:<ul><li>Read the sector into memory</li><li>Scan it to see if it contains the filename we’re looking for</li><li>If found, calculate its starting sector and file size</li></ul></li><li>If not found, the boot process fails</li></ul><h2 id="root-directory-size">Root directory size</h2><p>The size of the root directory in sectors is the number of entries it contains, times 32 bytes:</p><figure class="highlight"><pre><code class="language-as" data-lang="as"><span class="c"># The number of sectors that the root directory occupies</span>
<span class="c"># is equal to its max number of entries, times 32 bytes per</span>
<span class="c"># entry, divided by sector size.</span>
<span class="c"># E.g. (32 * rootsize) / 512</span>
<span class="c"># This normally yields 14 sectors on a FAT12 disk.</span>
<span class="c"># We calculate this total, then store it in cx for later use in a loop.</span>
<span class="k">mov</span>     <span class="n">ax</span><span class="p">,</span> <span class="mi">32</span>
<span class="k">xor</span>     <span class="n">dx</span><span class="p">,</span> <span class="n">dx</span>
<span class="k">mul</span>     <span class="n">word</span> <span class="n">ptr</span> <span class="n">iRootSize</span>
<span class="k">div</span>     <span class="n">word</span> <span class="n">ptr</span> <span class="n">iSectSize</span>          <span class="c"># Divide (dx:ax,sectsize) to (ax,dx)</span>
<span class="k">mov</span>     <span class="n">cx</span><span class="p">,</span> <span class="n">ax</span>
<span class="k">mov</span>     <span class="n">root_scts</span><span class="p">,</span> <span class="n">cx</span>
<span class="c"># root_scts is now the number of sectors in the root directory.</span></code></pre></figure><h2 id="root-directory-start">Root directory start</h2><p>To get started, we’ll first need to know where the root directory begins. The information we need is in the boot sector, where the following values are important:</p><ul><li>Number of FAT tables (2)</li><li>Number of sectors per FAT (9)</li><li>Number of reserved sectors (1)</li><li>Number of hidden sectors (0)</li></ul><p>The root directory comes after and reserved or hidden sectors and the file allocation table (FAT). The starting cluster of the root directory is therefore:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">root_sector</span> <span class="o">=</span> <span class="p">(</span><span class="n">FAT</span> <span class="n">tables</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="err">#</span><span class="n">sectors</span> <span class="n">per</span> <span class="n">FAT</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">reserved</span> <span class="n">sectors</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">hidden</span> <span class="n">sectors</span><span class="p">)</span></code></pre></figure><p>The one reserved sector is of, course, the boot sector. There are no hidden sectors on our disk.</p><figure class="highlight"><pre><code class="language-as" data-lang="as"><span class="c"># Calculate start sector root directory:</span>
<span class="c"># root_strt = number of FAT tables * sectors per FAT</span>
<span class="c">#           + number of hidden sectors</span>
<span class="c">#           + number of reserved sectors</span>
<span class="k">xor</span>   <span class="n">ax</span><span class="p">,</span> <span class="n">ax</span>                      <span class="c"># find the root directory</span>
<span class="k">mov</span>   <span class="n">al</span><span class="p">,</span> <span class="n">byte</span> <span class="n">ptr</span> <span class="n">iFatCnt</span>        <span class="c"># ax = number of FAT tables</span>
<span class="k">mov</span>   <span class="n">bx</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iFatSize</span>       <span class="c"># bx = sectors per FAT</span>
<span class="k">mul</span>   <span class="n">bx</span>                          <span class="c"># ax = #FATS * sectors per FAT</span>
<span class="k">add</span>   <span class="n">ax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iHiddenSect</span>    <span class="c"># Add hidden sectors to ax</span>
<span class="k">adc</span>   <span class="n">ax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iHiddenSect</span><span class="o">+</span><span class="mi">2</span>
<span class="k">add</span>   <span class="n">ax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iResSect</span>       <span class="c"># Add reserved sectors to ax</span>
<span class="k">mov</span>   <span class="n">root_strt</span><span class="p">,</span> <span class="n">ax</span>
<span class="c"># root_strt is now the number of the first root sector</span></code></pre></figure><h2 id="reading-and-scanning-each-sector">Reading and scanning each sector</h2><p>We can now use the ReadSector function we developed earlier to read the sectors into memory, one by one. For each sector, we then loop through the entries and check each filename (the first 11 bytes of the directory entry) for a match:</p><figure class="highlight"><pre><code class="language-as" data-lang="as">	
<span class="c"># Load a sector from the root directory.</span>
<span class="c"># If sector reading fails, a reboot will occur.</span>
<span class="n">read_next_sector</span><span class="o">:</span>
<span class="k">push</span>   <span class="n">cx</span>
<span class="k">push</span>   <span class="n">ax</span>
<span class="k">xor</span>    <span class="n">bx</span><span class="p">,</span> <span class="n">bx</span>
<span class="k">call</span>   <span class="n">ReadSector</span>
 
<span class="n">check_entry</span><span class="o">:</span>
<span class="k">mov</span>    <span class="n">cx</span><span class="p">,</span> <span class="mi">11</span>                      <span class="c"># Directory entries filenames are 11 bytes.</span>
<span class="k">mov</span>    <span class="n">di</span><span class="p">,</span> <span class="n">bx</span>                      <span class="c"># es:di = Directory entry address</span>
<span class="k">lea</span>    <span class="n">si</span><span class="p">,</span> <span class="n">filename</span>                <span class="c"># ds:si = Address of filename we are looking for.</span>
<span class="n">repz</span>   <span class="k">cmpsb</span>                       <span class="c"># Compare filename to memory.</span>
<span class="k">je</span>     <span class="n">found_file</span>                  <span class="c"># If found, jump away.</span>
<span class="k">add</span>    <span class="n">bx</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="mi">32</span>             <span class="c"># Move to next entry. Entries are 32 bytes.</span>
<span class="k">cmp</span>    <span class="n">bx</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iSectSize</span>      <span class="c"># Have we moved out of the sector yet?</span>
<span class="k">jne</span>    <span class="n">check_entry</span>                 <span class="c"># If not, try next directory entry.</span>
 
<span class="k">pop</span>    <span class="n">ax</span>
<span class="k">inc</span>    <span class="n">ax</span>                          <span class="c"># check next sector when we loop again</span>
<span class="k">pop</span>    <span class="n">cx</span>
<span class="k">loopnz</span> <span class="n">read_next_sector</span>            <span class="c"># loop until either found or not</span>
<span class="k">jmp</span>    <span class="n">bootFailure</span>                 <span class="c"># could not find file: abort</span></code></pre></figure><h2 id="getting-the-file-start-position">Getting the file start position</h2><p>Now that we have found the root directory entry for the kernel file, we need to get from it the position of the file (the cluster number):</p><figure class="highlight"><pre><code class="language-as" data-lang="as">  <span class="n">found_file</span><span class="o">:</span>
    <span class="c"># The directory entry stores the first cluster number of the file</span>
    <span class="c"># at byte 26 (0x1a). BX is still pointing to the address of the start</span>
    <span class="c"># of the directory entry, so we will go from there.</span>
    <span class="c"># Read cluster number from memory:</span>
    <span class="k">mov</span>    <span class="n">ax</span><span class="p">,</span> <span class="n">es</span><span class="o">:</span><span class="err">[</span><span class="n">bx</span><span class="o">+</span><span class="mh">0x1a</span><span class="err">]</span>
    <span class="k">mov</span>    <span class="n">file_strt</span><span class="p">,</span> <span class="n">ax</span></code></pre></figure><p>The end result is that <code class="highlighter-rouge">file_strt</code> contains the file’s starting cluster number.</p><h2 id="fat-clusters">FAT Clusters</h2><p>All right, after all this digging through the disk’s root directory, we’ve found our file and we’ve got a <em>cluster number</em> in hand. However, so far we’ve only talked about sectors, not <em>clusters</em> (you can safely ignore the cylinder, track and head story from here on – they have nothing to do with it). A cluster is another logical structure introduced by FAT.</p><p>The idea is that in FAT, a file may occupy a number of sectors. And most files certainly will, because one sector is only 512 bytes. Files on disk will often be much larger than that! So imagine that we have a disk with two of files on it. They’re both 3 sectors in size, and they were physically written to the disk so as to occupy precisely the first 6 sectors of the data area. Now, the first file is deleted. That means we now have 3 empty sectors at the start of the data area. Next, a new file, 4 sectors in size, is copied onto the disk. Where does it go? There’s no space to put new file before the remaining existing file, since there’s only space for 3 sectors. We can only place the new file after the existing file. Maybe at some point a user will want to write a 3-sector file that can fill the gap!</p><p>Naturally, if you consider writing and deleting lots of files on a disk, this will leave the file system fragmented and with lots of gaps that we can’t use. And this is where FAT comes in. With FAT, a file that occupies multiple sectors on disk may be broken up into non-contiguous sectors. So a 3-sector file could occupy physical sectors 40, 21 and 304. The bits and pieces can go wherever there is space and all available space is used to the fullest.</p><p>The problem then is administration. How does FAT know where the loose pieces of each file are? For this, the FAT system uses its namesake, the <em>File Allocation Table</em>. This table lives right before the root directory and contains an index of all the sectors on the disk. There are actually two copies of the FAT on every disk: one is a backup, for safety. You’ll see that the bootsector actually contains a field with the number of FAT tables on the disk.</p><p>The FAT table is actually an index of linked lists of sectors (hello?). An example illustrates how this works. Imagine we have a disk with 10 data sectors on it (we’re ignoring the sectors occupied by boot sector, root directory, FAT etc., and the fact that 10 sectors is a really small disk):</p><div class="table"><table rules="groups"><thead><tr><th style="text-align: left">Sector</th><th style="text-align: left">FAT-Value</th></tr></thead><tbody><tr><td style="text-align: left">0</td><td style="text-align: left">0x001</td></tr><tr><td style="text-align: left">1</td><td style="text-align: left">0x004</td></tr><tr><td style="text-align: left">2</td><td style="text-align: left">0xFF8</td></tr><tr><td style="text-align: left">3</td><td style="text-align: left">0x007</td></tr><tr><td style="text-align: left">4</td><td style="text-align: left">0x006</td></tr><tr><td style="text-align: left">5</td><td style="text-align: left">0x000</td></tr><tr><td style="text-align: left">6</td><td style="text-align: left">0xFF8</td></tr><tr><td style="text-align: left">7</td><td style="text-align: left">0xFF8</td></tr><tr><td style="text-align: left">8</td><td style="text-align: left">0x000</td></tr><tr><td style="text-align: left">9</td><td style="text-align: left">0xFF7</td></tr></tbody></table></div><p>There are actually three files on this disk. From the root directory we get:</p><ul><li>File 1 – cluster index = 0</li><li>File 2 – cluster index = 2</li><li>File 3 – cluster index = 3</li></ul><p>The directory entry for file 1 points to cluster index 0. In the FAT table, the value for this index is <code class="highlighter-rouge">0x001</code>: it points to index 1. Index 1’s value is <code class="highlighter-rouge">0x004</code>: it points to index 4. Index 4’s value is <code class="highlighter-rouge">0x006</code>: is points to index 6. Index 6’s value, finally, is <code class="highlighter-rouge">0xff8</code>, a special value which means that it is the last index of the file.</p><blockquote><p>What this all means is that file 1 occupies sectors 0, 1, 4 and 6. Actually, sector 0 is the sector after the root directory on the disk, but that’s a detail.</p><p>For file 2 we can now determine that it occupies only one sector (sector 2). The FAT-value for this index is 0xff8, so there are no more sectors.</p><p>For file 3, we see that it occupies sectors 3 and 7. You’ll get the idea by now.</p></blockquote><ul><li>Some of the FAT indices have the value <code class="highlighter-rouge">0</code>. That means that the sector is free.</li><li>Any value of <code class="highlighter-rouge">0xff8</code> or higher means end-of-file</li><li>A value of <code class="highlighter-rouge">0xff7</code> means the sector is bad and should not be used.</li></ul><p>A cluster, therefore, is a linked list where each entry points to the next, until the end of the cluster. Each entry relates to an actual physical sector on disk. When reading a file, we’ll have to follow its FAT cluster and read each corresponding sector into memory.</p><p>It sounds simple enough, after all, but there’s a catch: the FAT entries occupy 12 bits each (a byte and a half), which will make reading and using the data bit tricky later. You will now see that since each the FAT consists of 9 sectors, it can address 9*512/1.5 = 3072 sectors, which is more than enough, since our disk has 1440 sectors.</p><h2 id="reading-the-fat">Reading the FAT</h2><p>The FAT lives on the disk, and in order to access it, we’ll have to get it in memory first. The following code does just that: it loads the FAT into a memory segment (I use segment 0x0ee0, so as to place it just under where I’ll be loading the next file):</p><figure class="highlight"><pre><code class="language-as" data-lang="as"><span class="c"># The FAT will be loaded in a special segment.</span>
<span class="c"># Set ES to this segment.</span>
<span class="k">mov</span>   <span class="n">ax</span><span class="p">,</span> <span class="n">fatsegment</span>
<span class="k">mov</span>   <span class="n">es</span><span class="p">,</span> <span class="n">ax</span>
 
<span class="c"># Calculate offset of FAT:</span>
<span class="k">mov</span>   <span class="n">ax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iResSect</span>       <span class="c"># Add reserved sectors to ax</span>
<span class="k">add</span>   <span class="n">ax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iHiddenSect</span>    <span class="c"># Add hidden sectors to ax</span>
<span class="k">adc</span>   <span class="n">ax</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iHiddenSect</span><span class="o">+</span><span class="mi">2</span>
 
<span class="c"># Read all FAT sectors into memory:</span>
<span class="k">mov</span>   <span class="n">cx</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iFatSize</span>       <span class="c"># Number of sectors in FAT</span>
<span class="k">xor</span>   <span class="n">bx</span><span class="p">,</span> <span class="n">bx</span>                      <span class="c"># Memory offset to read into (es:bx)</span>
<span class="n">read_next_fat_sector</span><span class="o">:</span>
<span class="k">push</span>  <span class="n">cx</span>
<span class="k">push</span>  <span class="n">ax</span>
<span class="k">call</span>  <span class="n">ReadSector</span>
<span class="k">pop</span>   <span class="n">ax</span>
<span class="k">pop</span>   <span class="n">cx</span>
<span class="k">inc</span>   <span class="n">ax</span>
<span class="k">add</span>   <span class="n">bx</span><span class="p">,</span> <span class="n">word</span> <span class="n">ptr</span> <span class="n">iSectSize</span>
<span class="k">loopnz</span> <span class="n">read_next_fat_sector</span>       <span class="c"># continue with next sector</span></code></pre></figure><p>After this code has executed, all 9 sectors of the FAT now live in memory at <code class="highlighter-rouge">0ee0:0000</code>.</p><h2 id="reading-a-file">Reading a file</h2><p>Without FAT in memory, we are not ready to read a file from disk. By scanning the root directory we had earlier determined the starting index in the FAT table, so we’re good to go:</p><figure class="highlight"><pre><code class="language-as" data-lang="as"><span class="c"># Set memory segment that will receive the file:</span>
<span class="k">mov</span>     <span class="n">ax</span><span class="p">,</span> <span class="n">loadsegment</span>
<span class="k">mov</span>     <span class="n">es</span><span class="p">,</span> <span class="n">ax</span>
<span class="c"># Set memory offset for loading to 0.</span>
<span class="k">xor</span>     <span class="n">bx</span><span class="p">,</span> <span class="n">bx</span>
 
<span class="c"># Set memory segment for FAT:</span>
<span class="k">mov</span>     <span class="n">cx</span><span class="p">,</span> <span class="n">file_strt</span>             <span class="c"># CX now points to first FAT entry of file</span>
 
<span class="n">read_file_next_sector</span><span class="o">:</span>
<span class="c"># Locate sector:</span>
<span class="k">mov</span>     <span class="n">ax</span><span class="p">,</span> <span class="n">cx</span>                    <span class="c"># Sector to read is equal to current FAT entry</span>
<span class="k">add</span>     <span class="n">ax</span><span class="p">,</span> <span class="n">root_strt</span>             <span class="c"># Plus the start of the root directory</span>
<span class="k">add</span>     <span class="n">ax</span><span class="p">,</span> <span class="n">root_scts</span>             <span class="c"># Plus the size of the root directory</span>
<span class="k">sub</span>     <span class="n">ax</span><span class="p">,</span> <span class="mi">2</span>                     <span class="c"># ... but minus 2</span>
 
<span class="c"># Read sector:</span>
<span class="k">push</span>    <span class="n">cx</span>                        <span class="c"># Read a sector from disk, but save CX</span>
<span class="k">call</span>    <span class="n">ReadSector</span>                <span class="c"># as it contains our FAT entry</span>
<span class="k">pop</span>     <span class="n">cx</span>
<span class="k">add</span>     <span class="n">bx</span><span class="p">,</span> <span class="n">iSectSize</span>             <span class="c"># Move memory pointer to next section</span>
 
<span class="c"># Get next sector from FAT:</span>
<span class="k">push</span>    <span class="n">ds</span>                        <span class="c"># Make DS:SI point to FAT table</span>
<span class="k">mov</span>     <span class="n">dx</span><span class="p">,</span> <span class="n">fatsegment</span>            <span class="c"># in memory.</span>
<span class="k">mov</span>     <span class="n">ds</span><span class="p">,</span> <span class="n">dx</span>
 
<span class="k">mov</span>     <span class="n">si</span><span class="p">,</span> <span class="n">cx</span>                    <span class="c"># Make SI point to the current FAT entry</span>
<span class="k">mov</span>     <span class="n">dx</span><span class="p">,</span> <span class="n">cx</span>                    <span class="c"># (offset is entry value * 1.5 bytes)</span>
<span class="k">shr</span>     <span class="n">dx</span>
<span class="k">add</span>     <span class="n">si</span><span class="p">,</span> <span class="n">dx</span>
 
<span class="k">mov</span>     <span class="n">dx</span><span class="p">,</span> <span class="n">ds</span><span class="o">:</span><span class="p">[si]</span>               <span class="c"># Read the FAT entry from memory</span>
<span class="k">test</span>    <span class="n">cx</span><span class="p">,</span> <span class="mi">1</span>                     <span class="c"># See which way to shift, see if current cluster if odd</span>
<span class="k">jnz</span>     <span class="n">read_next_cluster_odd</span>    
<span class="k">and</span>     <span class="n">dx</span><span class="p">,</span> <span class="mh">0x0fff</span>                <span class="c"># if not mask out upper 4 bits</span>
<span class="k">jmp</span>     <span class="n">read_next_file_cluster_done</span>
<span class="n">read_next_cluster_odd</span><span class="o">:</span>            <span class="c"># if it is odd shift the new cluster 4 to right</span>
<span class="k">shr</span>     <span class="n">dx</span><span class="p">,</span> <span class="mi">4</span>
<span class="n">read_next_file_cluster_done</span><span class="o">:</span>     
<span class="k">pop</span>     <span class="n">ds</span>                        <span class="c"># Restore DS to the normal data segment</span>
<span class="k">mov</span>     <span class="n">cx</span><span class="p">,</span> <span class="n">dx</span>                    <span class="c"># Store the new FAT entry in CX</span>
<span class="k">cmp</span>     <span class="n">cx</span><span class="p">,</span> <span class="mh">0xff8</span>                 <span class="c"># If the FAT entry is greater or equal</span>
<span class="k">jl</span>      <span class="n">read_file_next_sector</span>     <span class="c"># to 0xff8, then we have reached end-of-file</span></code></pre></figure><p>What happens here is that we start with <code class="highlighter-rouge">cx</code> = first sector of file (we know this from the root directory after all). We read that sector into memory, then use the <code class="highlighter-rouge">cx</code> value to access the corresponding index in the FAT. There’s a bit of trickiness where we juggle with the 12-bits issue, but then all that remains is whether to continue reading, or stop because end-of-file (FAT-entry <code class="highlighter-rouge">0xff8</code> or higher) was reached.</p><h2 id="summary">Summary</h2><p>From a bare-bones boot loader, we’ve now come to a point where we can load the kernel (or rather the second-stage boot loader – this will become clear later on)! We’ve seen how the root directory and FAT work, and neatly read both to load the required file from disk. Since we squeezed all this functionality in, the file we’re loading can actually live anywhere in the root of the disk. Gone is the requirement for <a class="vglnk" href="http://sys.com/" rel="nofollow"><span>SYS</span><span>.</span><span>COM</span></a> that DOS and Windows imposed. In our future OS, making a disk bootable should not require a formatting operation. Writing a boot sector and simply coping the OS files onto the disk will suffice.</p><p>So far I’ve shown here some sections of code that still need to be sewn together. In the next part of this guide, we’ll add a small kernel (something along the lines of “hello world”) to be loaded and executed. We’ll then have a complete source that can be compiled and run on Bochs (or from a floppy disk if you’re hardcore).</p><p><a href="http://www.independent-software.com/operating-system-development-using-makefiles-and-second-stage-bootloader.html" class="btn">Continue on to the next part of this guide!</a></p><script async="" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/f(8).txt"></script> <ins class="adsbygoogle" style="display: block; height: 90px;" data-ad-client="ca-pub-3185318852689730" data-ad-slot="5695790800" data-ad-format="auto" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:800px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:800px;background-color:transparent;"><iframe width="800" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:800px;height:90px;" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/saved_resource(2).html"></iframe></ins></ins></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div id="disqus_thread"><iframe id="dsq-app1960" name="dsq-app1960" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/saved_resource(3).html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 662px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div><script> var disqus_config = function () { this.page.url = 'http://www.independent-software.com/operating-system-development-file-allocation-table-and-reading-from-disk.html'; this.page.identifier = 'http://www.independent-software.com/operating-system-development-file-allocation-table-and-reading-from-disk.html'; }; (function() { var d = document, s = d.createElement('script'); s.src = 'https://independent-software.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="<a class="vglnk" href="https://disqus.com/?ref_noscript" rel="nofollow"><span>https</span><span>://</span><span>disqus</span><span>.</span><span>com</span><span>/?</span><span>ref</span><span>_</span><span>noscript</span></a>" rel="nofollow">comments powered by Disqus.</a></noscript></div><a class="u-url" href="http://www.independent-software.com/operating-system-development-file-allocation-table-and-reading-from-disk.html" hidden=""></a></section></article></main><footer> <data class="u-url" href="/"></data><div class="footer-wrapper"><div class="footer-col-wrapper"><div class="footer-col footer-col-1"> <img src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/independent-software-logo.svg" style="width:200px; max-width: 100%"><ul style="margin-top: 20px"><li>1513 Av. Vladimir Lenine</li><li>Maputo, Mozambique</li><li><a href="mailto:info@independent-software.com">info@independent-software.com</a></li><li>+258 82 304 26 35</li></ul></div><div class="footer-col footer-col-2"><h3>Links</h3><ul><li><a href="http://www.independent-software.com/web-development.html">Web Development</a></li><li><a href="http://www.independent-software.com/portfolio.html">Portfolio</a></li><li><a href="http://www.independent-software.com/operating-system-development.html">Operating System Development</a></li></ul></div><div class="footer-col footer-col-3"><h3>Social</h3><ul class="social-media-list"><li><svg class="svg-icon"><use xlink:href="/assets/social.svg#facebook"></use></svg> <a href="https://www.facebook.com/Independent-Software-295360497495620/">Facebook</a></li><li><svg class="svg-icon"><use xlink:href="/assets/social.svg#github"></use></svg> <a href="https://github.com/henck">Github</a></li><li><svg class="svg-icon"><use xlink:href="/assets/social.svg#linkedin"></use></svg> <a href="https://www.linkedin.com/company/independent-software-mozambique-">LinkedIn</a></li><li><svg class="svg-icon"><use xlink:href="/assets/social.svg#twitter"></use></svg> <a href="https://twitter.com/IndependentSw">Twitter</a></li><li><svg class="svg-icon"><use xlink:href="/assets/social.svg#googleplus"></use></svg><a href="https://google.com/+Independent-software">Google+</a></li><li><svg class="svg-icon"><use xlink:href="/assets/social.svg#rss"></use></svg> <a href="http://www.independent-software.com/feed.xml">Atom feed</a></li></ul></div></div></div></footer>
<iframe style="display: none;" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/saved_resource(4).html"></iframe><iframe id="google_osd_static_frame_1097461511579" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/saved_resource(5).html"></iframe></body><iframe id="google_shimpl" style="display: none;" src="./File Allocation Table (FAT) and Reading from Disk _ Independent Software_files/saved_resource(6).html"></iframe></html>