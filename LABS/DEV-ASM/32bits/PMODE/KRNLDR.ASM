.386P 

INCLUDE A20.INC
INCLUDE FAT12.INC

ERROR EQU -1

;FIRST DEFINE ALL SEGMENTS THAT WILL BE NEEDED
CODE16SEG SEGMENT USE16 'CODE'
CODE16SEG ENDS

DATA16SEG SEGMENT USE16
DATA16SEG ENDS

STACK16SEG SEGMENT USE16 STACK
  DB 1024 DUP (?)
  TOS16 EQU $   ;TOP OF STACK
STACK16SEG ENDS

CODE32SEG SEGMENT USE32 'CODE'
CODE32SEG ENDS

DATA32SEG SEGMENT USE32
DATA32SEG ENDS

STACK32SEG SEGMENT USE32 'STACK'
  DB 1024 DUP (?)
  TOS32 EQU $   ; TOP OF STACK
STACK32SEG ENDS

; PUT ALL SEGMENTS IN ONE
SEGS16 GROUP CODE16SEG,DATA16SEG,STACK16SEG
SEGS32 GROUP CODE32SEG,DATA32SEG,STACK32SEG

DESC STRUCT   				; DEFINE OUR DESCRIPTOR STRUCTURE
	LIMIT_LO 	DW ?    	; LIMIT BITS 15-0
	BASE_LO 	DW ?     	; BASE BITS 15-0
	BASE_MID 	DB ?    	; BASE BITS 23-16
	TYPE1 		DB ?       	; TYPE OF SELECTOR
	LIMIT_HI 	DB ?    	; LIMIT BITS 19-16 AND OTHER INFO
	BASE_HI 	DB ?     	; BASE BITS 31-24
DESC ENDS

DATA16SEG SEGMENT USE16  ; START DEFINING OUR 16BIT DATA

	; DEFINE OUR GDTR
	GDTR 		LABEL FWORD
	GDT_LIMIT 	DW GDT_SIZE-1
	GDT_ADDR 	DD ?
	
	; DEFINE OUR IDTR
	IDTR 		LABEL FWORD
	IDT_LIMIT 	DW IDT_SIZE-1
	IDT_ADDR 	DD ?

	; DEFINE OUR GDT
	GDT_START 	EQU $
	NULL 		DESC <0,0,0,0,0,0>
	; THIS IS THE 1ST GDT ENTRY CALLED NULL WHICH WE CAN NOT USE
	
	CODE16 		DESC <0FFFFH,?,?,10011110B,0H,?>
	; LIMIT=64 KBS (THIS IS A 16BIT SEGMENT SO ONLY IP IS USED WHILE RUNNING)
	; BASE=? (THIS WILL BE SETUP LATER IN THE PROGRAM)
	; 10011110B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=1 (CODE)
	;            C=1(CONFORMING), R=1 (READABLE), A=0 (NOT ACCESSED)
	; 0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	DATA16 		DESC <0FFFFH,?,?,10010010B,0H,?>
	; LIMIT=64 KBS
	; BASE=? (THIS WILL BE SETUP LATER IN THE PROGRAM)
	; 10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	; 0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	VID16 		DESC <0FFFFH,8000H,0BH,10010010B,0H,0>
	; LIMIT=64 KBS
	; BASE=0B8000H (MAKES IT EASY TO ACCESS VIDEO RAM WHILE IN PMODE-16)
	; 10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	; 0H = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=0 (16BIT SEGMENT)
	
	CODE32 		DESC <0FFFFH,?,?,10011110B,11001111B,?>
	; LIMIT=4 GBS (0FFFFH * 4K = 4 GBS)
	; BASE=?
	;     THE BEGINNING OF MEMORY)
	; 10011110B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=1 (CODE)
	;            C=1(CONFORMING), R=1 (READABLE), A=0 (NOT ACCESSED)
	; 11001111B = LIMIT BITS 19-16=0FH, G=1 (4K GRANULARITY), D=1 (32BIT SEGMENT)
	
	DATA32 		DESC <0FFFFH,?,?,10010010B,11001111B,?>
	; LIMIT=4 GBS
	; BASE=?
	; 10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	; 11001111B = LIMIT BITS 19-16=0FH, G=1 (4K GRANULARITY), D=1 (32BIT SEGMENT)
	
	VID32 		DESC <0FFFFH,08000H,0BH,10010010B,01000000B,0>
	; LIMIT=64 KBS
	; BASE=0B8000H (EASY ACCESS TO THE VIDEO RAM AREA)
	; 10010010B = P=1 (PRESENT), DPL=0, S=1(CODE/DATA SEGMENT) T=0 (DATA)
	;            E=0 (DO NOT EXPAND DOWN), W=1 (WRITABLE), A=0 (NOT ACCESSED)
	; 01000000B = LIMIT BITS 19-16=0, G=0 (1BYTE GRANULARITY), D=1 (32BIT SEGMENT)
	KERNEL32 	DESC <0FFFFH,0,0,10011110B,11001111B,0>
	
	GDT_SIZE 	EQU ($-GDT_START)

	; DEFINE OUR IDT
	IDT_START 	EQU $
	IDT_DESC_00 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_01 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_02 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_03 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_04 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_05 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_06 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_07 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_08 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_09 DESC <OFFSET INT9,SELCODE16,0,10001110B,0,0>
	IDT_DESC_10 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_11 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_12 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_13 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_14 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_DESC_15 DESC <OFFSET INT0,SELCODE16,0,10001110B,0,0>
	IDT_SIZE 	EQU ($-IDT_START)

	; DEFINE OUR SELECTORS
	SELCODE16 	EQU (OFFSET CODE16 - GDT_START)
	SELDATA16 	EQU (OFFSET DATA16 - GDT_START)
	SELVID16 	EQU (OFFSET VID16 - GDT_START)
	SELDATA32 	EQU (OFFSET DATA32 - GDT_START)
	SELCODE32 	EQU (OFFSET CODE32 - GDT_START)
	SELVID32 	EQU (OFFSET VID32 - GDT_START)
	SELKRNL32 	EQU (OFFSET KERNEL32 - GDT_START)

	PRG_BASE16 	DD ?    						; CS*10H
	PRG_BASE32 	DD ?    						; CS*10H
	
	MESSAGE16	DB 'MESSAGE OF 16 BITS DATA SEGMENT!!'
	
	LENKERNEL32		DB	?

DATA16SEG ENDS

DATA32SEG SEGMENT USE32

	X 			DD 0     						; COORDS OF CURSOR ON SCREEN
	Y 			DD 0
	TIMER 		DB 0

	MSG32_TIMER DB ' = TIMER',13,0,0,0,0,0,0
	
	BUFFER  	DB 10 DUP(0)
	BUFPTR1 	DW 0
	BUFPTR2 	DW 0
	SCANTABLE 	DB 0,0,'1234567890-=',8,0
				DB 'QWERTYUIOP[]',0DH,0
				DB 'ASDFGHJKL;',0,0,'\',0
				DB 'ZXCVBNM,./',0,0,0
				DB ' ',0,0,0,0,0,0,0,0,0,0,0,0,0
				DB '789-456+1230.'
	VIDEO_POS	DD 140h
				
	
	MSG32_WELCOME DB 'WELCOME TO 32BIT PMODE!',13,0,0,0,0,0,0
	
	KERNELARQUIVO   DB	"KRNL32  EXE"           			
	

DATA32SEG ENDS

CODE16SEG SEGMENT USE16  						; START THE 16BIT CODE SEGMENT
	ASSUME CS:SEGS16,DS:SEGS16,SS:SEGS16,ES:NOTHING

		START16:

			CLD
			
			CALL 	LOAD_KERNEL32

			MOV		AX, CS
			MOV		DS, AX         
			MOV		ES, AX         				; SET DS=ES=CS

			; ENABLE THE A20 SO WE CAN ACCESS RAM ABOVE 1MB.
			
			CALL 	ENABLEA20
			
			CMP 	AX, ERROR
			JNZ 	OK_A20
			HLT 								; ERROR A20
			OK_A20:

			; SETUP SOME OTHER VARIABLES
			XOR 	EAX, EAX
			MOV 	AX, CS
			SHL 	EAX, 4    					; LINEAR ADDR
			MOV 	PRG_BASE16,EAX
	
			XOR 	EAX, EAX
			MOV 	AX, SEGS32
			SHL 	EAX, 4
			MOV 	PRG_BASE32, EAX  			; WE WILL NEED THIS LATER

			; SETUP ALL OUR DESCRIPTORS
			MOV 	EAX, PRG_BASE16
			MOV 	CODE16.BASE_LO, AX
			MOV 	DATA16.BASE_LO, AX
			SHR 	EAX, 16
			MOV 	CODE16.BASE_MID, AL
			MOV 	DATA16.BASE_MID, AL
			MOV 	CODE16.BASE_HI, AH
			MOV 	DATA16.BASE_HI, AH
	
			MOV 	EAX, PRG_BASE32
			MOV 	CODE32.BASE_LO, AX
			MOV 	DATA32.BASE_LO, AX
			SHR 	EAX, 16
			MOV 	CODE32.BASE_MID, AL
			MOV 	DATA32.BASE_MID, AL
			MOV 	CODE32.BASE_HI, AH
			MOV 	DATA32.BASE_HI, AH


			; SETUP GDT AND IDT BASE
			MOV 	EAX, PRG_BASE16
			ADD 	EAX, GDT_START
			MOV 	GDT_ADDR, EAX
			MOV 	EAX, PRG_BASE16
			ADD 	EAX, IDT_START
			MOV 	IDT_ADDR, EAX

			; WE ARE NOW READY TO MOVE TO 16BIT PMODE  

			CLI   								; NO MORE IRQS ALLOWED PAST THIS POINT

			LIDT 	[IDTR]
			LGDT 	[GDTR]

			; GOTO PMODE!
			MOV 	EAX, CR0
			OR 		AL, 1           			; SET PM BIT
			MOV 	CR0, EAX       				; WE ARE NOW IN 16BIT PMODE

			PUSHFD
			PUSH 	DWORD PTR SELCODE32
			PUSH 	DWORD PTR OFFSET START32
			IRETD   							; GOTO 32BIT SEGMENT

		INT0 PROC
			; THIS IS CALLED DURING ANY EXCEPTION OR IRQ
			; WE WILL ASSUME IT IS ALWAYS IRQ#0 (TIMER)
			PUSH 	EAX
			PUSH 	ES
			PUSH 	DS
			MOV 	AX, SELVID32
			MOV 	ES, AX
			MOV 	AX, SELDATA32
			MOV 	DS, AX
			
			ASSUME 	DS:SEGS32
			MOV 	AL, TIMER
			INC 	TIMER
			
			ASSUME 	DS:SEGS16
			MOV 	BYTE PTR ES:[0], AL
			MOV 	AL, 20H						; INFORMA O FIM DA INSTRUCAO DE INTERRUPCAO
			OUT 	20H, AL              		; ACK IRQ
			POP 	DS
			POP 	ES
			POP 	EAX
			IRETD
			
		INT0 ENDP
		
		INT9 PROC
			PUSH 	EAX
			PUSH 	ES
			PUSH 	DS
			MOV 	AX, SELVID32
			MOV 	ES, AX
			MOV 	AX, SELDATA32
			MOV 	DS, AX
			ASSUME 	DS:SEGS32
			PUSH 	EBX
			IN 		AL, 60H
			PUSH 	AX
			IN 		AL, 61H
			OR 		AL, 80H
			OUT 	61H, AL
			AND 	AL, 7FH
			OUT 	61H, AL
			POP 	AX
			TEST 	AL, 80H
			JNZ 	KBINT2
			LEA 	BX, SCANTABLE
			XLAT
			CMP 	AL, 0
			JZ 		KBINT2
			MOV		EDI, VIDEO_POS
			MOV		AH, 07h
			STOSW
			ADD		VIDEO_POS, 2
			MOV 	BX, BUFPTR2
			MOV 	[BUFFER+BX], AL
			INC 	BX
			CMP 	BX, 10
			JC 		KBINT3
			MOV 	BX, 0
		KBINT3: 
			CMP 	BX, BUFPTR1
			JZ 		KBINT2
			MOV 	BUFPTR2, BX
		KBINT2: 
			MOV 	AL, 20H
			OUT 	20H, AL
			POP 	EBX
			POP 	DS
			POP 	ES
			POP 	EAX
			IRETD
		INT9 ENDP

CODE16SEG ENDS

CODE32SEG SEGMENT USE32
	ASSUME CS:SEGS32,DS:SEGS32,SS:SEGS32,ES:NOTHING
	
		START32:
			; RELOAD ALL SEGMENT REGS WITH 32BIT SELECTORS
			MOV 	AX, SELDATA32
			MOV 	DS, AX
			MOV 	SS, AX
			MOV 	FS, AX
			MOV 	GS, AX
			MOV 	ESP, TOS32
			MOV 	AX, SELVID32
			MOV 	ES, AX

			CALL 	CLRSCR   					; CLEAR THE SCREEN

			MOV 	ESI, OFFSET MSG32_TIMER
			CALL 	PRINT
			
			MOV		AX, SELKRNL32
			MOV		DS, AX
			MOV		ESI, 0h
			MOV		EDI, 0A0h
			MOV		ECX, 200
		CO:
			LODSB
			MOV		AH, 07h
			STOSW
			INC		SI
			LOOP	CO

			;MOV 	ESI, OFFSET MSG32_WELCOME
			;CALL 	PRINT

		; ENABLE TIMER ONLY
		 COMMENT ^ ************** ENTENDER MELHOR ************
			MOV 	AL, 0FFH
			OUT 	0A1H, AL
			DEC 	AL        					; ENABLE IRQ#0
			OUT 	021H, AL
		 ^************** MESMO DESABILITADO FUNCIONA *******
 
			STI  								; ENABLE IRQS

			JMP 	$  							; THIS IS THE END, I'LL SHOW HOW TO GET BACK TO RMODE
												; IN THE NEXT TUTORIAL SOURCE

		CLRSCR PROC
			XOR 	EDI, EDI         			; LINEAR ADDR OF 0B800:0  (BASE=0B8000H)
			MOV 	ECX, 80*25
			MOV 	AX, 720H         			; 07H=WHITE ON BLACK 20H=SPACES
			REP 	STOSW
			MOV 	X, 0
			MOV 	Y, 0
			RET
		CLRSCR ENDP

		; ESI = STRING TO PRINT
		PRINT PROC
			P0:
			MOV 	EDI, Y
			IMUL 	EDI, EDI, 80*2    			; 80*2 = # BYTES/ROW (IN TEXT MODE)
			ADD   	EDI, X
			ADD 	EDI, X            			; ADD TWICE TO SKIP OVER COLOR BYTES TOO
			P1:
			CMP 	BYTE PTR[ESI], 0
			JZ 		P3
			CMP 	BYTE PTR[ESI], 13
			JZ 		P13
			MOVSB                				; DS:ESI => ES:EDI
			INC 	EDI              			; SKIP OVER COLOR BYTE
			INC 	X
			CMP 	X, 80
			JNZ 	P1
			P2:                    				; SKIP TO NEXT LINE
			MOV 	X, 0
			INC 	Y
			CMP 	Y, 25
			JNZ 	P0
			MOV 	Y, 0
			JMP 	P0
			P13:
			INC 	ESI
			JMP 	P2
			P3:
			RET
		PRINT ENDP

CODE32SEG ENDS

END START16     								; START PROGRAM IN CODE16:START16
