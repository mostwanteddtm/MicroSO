.386P 

INCLUDE A20.INC
INCLUDE IRQ0.INC
INCLUDE IRQ1.INC
INCLUDE IRQ8.INC
INCLUDE INT11h.INC

ERROR EQU -1

CODESEG16 SEGMENT USE16 'CODE'
CODESEG16 ENDS

DATASEG16 SEGMENT USE16
DATASEG16 ENDS


CODESEG32 SEGMENT USE32 'CODE'
CODESEG32 ENDS

DATASEG32 SEGMENT USE32
DATASEG32 ENDS

STACKSEG32 SEGMENT STACK USE32 'STACK'
	DB 1024 DUP (?)
STACKSEG32 ENDS

SEGS16 GROUP CODESEG16,DATASEG16
SEGS32 GROUP CODESEG32,DATASEG32

DESC STRUCT   						; DEFINE OUR DESCRIPTOR STRUCTURE
	LIMIT_LO 		DW ?    		; LIMIT BITS 15-0
	BASE_LO 		DW ?     		; BASE BITS 15-0
	BASE_MID 		DB ?    		; BASE BITS 23-16
	TYPE1 			DB ?       		; TYPE OF SELECTOR
	LIMIT_HI 		DB ?    		; LIMIT BITS 19-16 AND OTHER INFO
	BASE_HI 		DB ?     		; BASE BITS 31-24
DESC ENDS

DATASEG16 SEGMENT USE16 

	GDTR 			LABEL FWORD		; TAMANHO MÁXIMO DE UMA GDT 65535 BYTES
	GDT_LIMIT 		DW GDT_SIZE-1	; TOTAL DE DESCRITORES 8192 * 8 BYTES CADA = 65536 BYTES | (65536 - 1 = 65535)
	GDT_ADDR 		DD ?			; ENDEREÇO DA MATRIZ DE DESCRITORES: GDTR
	
	IDTR 			LABEL FWORD
	IDT_LIMIT 		DW IDT_SIZE-1
	IDT_ADDR 		DD ?
	
	COMMENT ^
											GDT - TABELA GLOBAL DE DESCRITORES DE SEGMENTOS
										
										 GRANULARIDADE: 0 - BYTE 1 - 4 KB 
														  |
	LIMITE DE ACESSO A MEMORIA, P/ ESTE SEGMENTO   0xFFFF |    0xF = [0xFFFFF = 1048575] * 4096(4KB) = 4294963200 BYTES | 4194300 MB | 4 GB
	 _______|_______									  |   __|_
	|				|									  |   |  |
	11111111 11111111 00000000 00000000 00000000 10011010 11001111 00000000
					  |_______________| |______| ||||||||  |	   |______|
							  |				|	 ||||||||  |		  |								 
	SETUP DO SEGMENTO		0xFFFF		  0xFF   ||||||||  |		 0xFF - O SEGMENTO PODE INICIAR DE 0 À 0xFFFFFFFF | 4GB
												 ||||||||  |
												 |||||||| SIZE: 0 SEGMENTO DE 16 BITS | 1 SEGMENTO DE 32 BITS
												 ||||||||
												 |||||||0 - SEMPRE 0 - QUANDO O SEGMENTO É REQUISITADO A CPU MUDA PRA 1
												 ||||||1 -- SOMENTE LEITURA 0 - ESCRITA - 1 
												 |||||0 --- SE 0 - O CÓDIGO SÓ PODE SER EXECUTADO SOMENTE PELO MESMO NIVEL DE ANEL - SE 1 DE QUALQUER NIVEL DE ANEL
												 ||||1 ---- SE 0 - SEGMENTO DE DADOS - SE 1 SEGMENTO DE CÓDIGO
												 |00 ------ NÍVEL DO ANEL. DE: 0 À 3
												 1 -------- ESTE SEMPRE SERÁ 1
												 
	11111111 11111111 00000000 00000000 00000000 10011010 00000000 00000000	
    |_______________|									  |______|	
			|												  |		
		 0xFFFF												 0x0 - EM DESCRITOR DE 16 BITS A GRANULARIDADE SERÁ SEMPRE 0
		 
	LIMITE DE ACESSO DO DESCRITOR EM 16 BITS É DE NO MÁXIMO 64K | 0xFFFF | 65535 BYTES
	^

	GDT_START 		EQU $
	NULLDESC 		DESC <0,0,0,0,0,0>
	CODEDESC16 		DESC <0FFFFH,,,10011110B,0H,>
	DATADESC16 		DESC <0FFFFH,,,10010010B,0H,>
	VIDEODESC16 	DESC <0FFFFH,8000H,0BH,10010010B,0H,0>
	CODEDESC32 		DESC <0FFFFH,,,10011110B,11001111B,>
	DATADESC32 		DESC <0FFFFH,,,10010010B,11001111B,>
	VIDEODESC32 	DESC <0FFFFH,08000H,0BH,10010010B,01000000B,0>
	GDT_SIZE 		EQU ($-GDT_START)

	
	IDT_START 		EQU $
	IDT_DESC_00h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_01h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_02h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_03h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_04h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_05h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_06h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_07h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_08h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_09h 	DESC <OFFSET INT09h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_0Ah 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_0Bh 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_0Ch 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_0Dh 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_0Eh 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_0Fh 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_10h 	DESC <OFFSET INT00h,SELCODEDESC16,0,10001110B,0,0>
	IDT_DESC_11h 	DESC <OFFSET INT11h,SELCODEDESC16,0,10001110B,0,0>
	IDT_12_69h 		DESC 5Eh DUP(<OFFSET INT11h,SELCODEDESC16,0,10001110B,0,0>)
	IDT_DESC_70h	DESC <OFFSET INT70h,SELCODEDESC16,0,10001110B,0,0>
	IDT_SIZE 		EQU ($-IDT_START)

	SELCODEDESC16 	EQU (OFFSET CODEDESC16 - GDT_START)
	SELDATADESC16 	EQU (OFFSET DATADESC16 - GDT_START)
	SELVIDEODESC16 	EQU (OFFSET VIDEODESC16 - GDT_START)
	SELDATADESC32 	EQU (OFFSET DATADESC32 - GDT_START)
	SELCODEDESC32 	EQU (OFFSET CODEDESC32 - GDT_START)
	SELVIDEODESC32 	EQU (OFFSET VIDEODESC32 - GDT_START)

	PRG_BASE16 	DD ?    						
	PRG_BASE32 	DD ?    						

DATASEG16 ENDS

DATASEG32 SEGMENT USE32

	X 			DD 0     						; COORDS OF CURSOR ON SCREEN
	Y 			DD 0
	TIMER 		DB 0

	MSG32_TIMER DB ' = TIMER',13,0,0,0,0,0,0
	
	BUFFER  	DB 10 DUP(0)
	BUFPTR1 	DW 0
	BUFPTR2 	DW 0
	SCANTABLE 	DB '0123456789ABCDEF'
	VIDEO_POS	DD 140h
				
	
	MSG32_WELCOME DB 'WELCOME TO 32BIT PMODE!',13,0,0,0,0,0,0
	
	SOFTWARE_INT  DB 'Custom Software Interrupt 11h !!', 0
	
	CHAR		DB 	30h
	POS			DD	280h

DATASEG32 ENDS

CODESEG16 SEGMENT USE16  						; START THE 16BIT CODE SEGMENT
	ASSUME CS:SEGS16,DS:SEGS16

	START16 PROC

		CLD

		MOV		AX, CS
		MOV		DS, AX         
		MOV		ES, AX         				; SET DS=ES=CS
		
		; ENABLE RTC (REAL TIME CLOCK) - IRQ8
		CALL	ENABLE_IRQ8

		; ENABLE THE A20 SO WE CAN ACCESS RAM ABOVE 1MB.
		CALL 	ENABLEA20
		CMP 	AX, ERROR
		JNZ 	OK_A20
		HLT 								; ERROR A20
		OK_A20:

		; SETUP SOME OTHER VARIABLES
		XOR 	EAX, EAX
		MOV 	AX, CS
		SHL 	EAX, 4    					; LINEAR ADDR
		MOV 	PRG_BASE16,EAX

		XOR 	EAX, EAX
		MOV 	AX, SEGS32
		SHL 	EAX, 4
		MOV 	PRG_BASE32, EAX  			; WE WILL NEED THIS LATER

		; SETUP ALL OUR DESCRIPTORS
		MOV 	EAX, PRG_BASE16
		MOV 	CODEDESC16.BASE_LO, AX
		MOV 	DATADESC16.BASE_LO, AX
		SHR 	EAX, 16
		MOV 	CODEDESC16.BASE_MID, AL
		MOV 	DATADESC16.BASE_MID, AL
		MOV 	CODEDESC16.BASE_HI, AH
		MOV 	DATADESC16.BASE_HI, AH

		MOV 	EAX, PRG_BASE32
		MOV 	CODEDESC32.BASE_LO, AX
		MOV 	DATADESC32.BASE_LO, AX
		SHR 	EAX, 16
		MOV 	CODEDESC32.BASE_MID, AL
		MOV 	DATADESC32.BASE_MID, AL
		MOV 	CODEDESC32.BASE_HI, AH
		MOV 	DATADESC32.BASE_HI, AH

		; SETUP GDT AND IDT BASE
		MOV 	EAX, PRG_BASE16
		ADD 	EAX, GDT_START
		MOV 	GDT_ADDR, EAX
		MOV 	EAX, PRG_BASE16
		ADD 	EAX, IDT_START
		MOV 	IDT_ADDR, EAX

		; WE ARE NOW READY TO MOVE TO 16BIT PMODE  

		CLI   								; NO MORE IRQS ALLOWED PAST THIS POINT

		LIDT 	[IDTR]
		LGDT 	[GDTR]

		; GOTO PMODE!
		MOV 	EAX, CR0
		OR 		AL, 1           			; SET PM BIT
		MOV 	CR0, EAX       				; WE ARE NOW IN 16BIT PMODE
		
		

		PUSHFD
		PUSH 	DWORD PTR SELCODEDESC32
		PUSH 	DWORD PTR OFFSET START32
		IRETD   							; GOTO 32BIT SEGMENT
	
	START16 ENDP

CODESEG16 ENDS

CODESEG32 SEGMENT USE32
	ASSUME CS:SEGS32,DS:SEGS32
	
	START32 PROC
		; RELOAD ALL SEGMENT REGS WITH 32BIT SELECTORS
		MOV 	AX, SELDATADESC32
		MOV 	DS, AX
		MOV 	SS, AX
		MOV 	FS, AX
		MOV 	GS, AX
		MOV 	ESP, 9000h
		MOV 	AX, SELVIDEODESC32
		MOV 	ES, AX

		CALL 	CLRSCR   					; CLEAR THE SCREEN

		MOV 	ESI, OFFSET MSG32_TIMER
		CALL 	PRINT

		MOV 	ESI, OFFSET MSG32_WELCOME
		CALL 	PRINT

	; ENABLE TIMER ONLY
	 COMMENT ^ ************** ENTENDER MELHOR ************
		MOV 	AL, 0FFH
		OUT 	0A1H, AL
		DEC 	AL        					; ENABLE IRQ#0
		OUT 	021H, AL
	 ^************** MESMO DESABILITADO FUNCIONA *******

		STI  								; ENABLE IRQS
		
		INT		11h

		JMP 	$  							; THIS IS THE END, I'LL SHOW HOW TO GET BACK TO RMODE
											; IN THE NEXT TUTORIAL SOURCE
	START32 ENDP

	CLRSCR PROC
		XOR 	EDI, EDI         			; LINEAR ADDR OF 0B800:0  (BASE=0B8000H)
		MOV 	ECX, 80*25
		MOV 	AX, 720H         			; 07H=WHITE ON BLACK 20H=SPACES
		REP 	STOSW
		MOV 	X, 0
		MOV 	Y, 0
		RET
	CLRSCR ENDP

	; ESI = STRING TO PRINT
	PRINT PROC
		P0:
		MOV 	EDI, Y
		IMUL 	EDI, EDI, 80*2    			; 80*2 = # BYTES/ROW (IN TEXT MODE)
		ADD   	EDI, X
		ADD 	EDI, X            			; ADD TWICE TO SKIP OVER COLOR BYTES TOO
		P1:
		CMP 	BYTE PTR[ESI], 0
		JZ 		P3
		CMP 	BYTE PTR[ESI], 13
		JZ 		P13
		MOVSB                				; DS:ESI => ES:EDI
		INC 	EDI              			; SKIP OVER COLOR BYTE
		INC 	X
		CMP 	X, 80
		JNZ 	P1
		P2:                    				; SKIP TO NEXT LINE
		MOV 	X, 0
		INC 	Y
		CMP 	Y, 25
		JNZ 	P0
		MOV 	Y, 0
		JMP 	P0
		P13:
		INC 	ESI
		JMP 	P2
		P3:
		RET
	PRINT ENDP

CODESEG32 ENDS

END START16     								; START PROGRAM IN CODEDESC16:START
